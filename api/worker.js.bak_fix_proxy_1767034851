// __FYD_VINTED_TITLE_FROM_URL_V2__
// Z URL Vinted wyciƒÖgamy "ludzki" tytu≈Ç (slug po my≈õlniku) + ujednolicamy pola,
// ≈ºeby /pojedynczo nie by≈Ço "Vinted 7826..." tylko realny tytu≈Ç.
function __fydDeriveVintedTitleFromUrl(url) {
  try {
    const s = String(url || "");
    const m = s.match(/vinted\.[^/]+\/items\/(\d+)(?:-([^?#/]+))?/i);
    if (!m) return null;

    const id = m[1];
    let slug = (m[2] ? decodeURIComponent(m[2]) : "")
      .replace(/[\-_]+/g, " ")
      .replace(/\s+/g, " ")
      .trim();

    if (!slug) return "Vinted " + id;

    slug = slug
      .split(" ")
      .filter(Boolean)
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join(" ");

    return slug || ("Vinted " + id);
  } catch {
    return null;
  }
}

function __fydEnsureVintedItemFields(it) {
  if (!it || typeof it !== "object") return it;

  const url = String(it.url || it.link || it.href || it.item_url || "");
  if (url) {
    if (!it.url) it.url = url;

    // pr√≥buj ustawiƒá itemKey pod normalizowane URL (kluczowe dla last_key)
    try {
      const itemKey = normalizeKey(url);
      if (itemKey && !it.itemKey) it.itemKey = itemKey;
      if (itemKey && !it.item_key) it.item_key = itemKey;
    } catch {}
  }

  const titleFromUrl = url ? __fydDeriveVintedTitleFromUrl(url) : null;
  const currentTitle = String(it.title || it.name || it.itemTitle || "").trim();

  if ((!currentTitle || /^vinted\s+\d+/i.test(currentTitle)) && titleFromUrl) {
    it.title = titleFromUrl;
    it.name = titleFromUrl;
    it.itemTitle = titleFromUrl;
  } else {
    if (!it.title && currentTitle) it.title = currentTitle;
    if (!it.name && currentTitle) it.name = currentTitle;
    if (!it.itemTitle && currentTitle) it.itemTitle = currentTitle;
  }

  // id pomocniczo (nie wszƒôdzie u≈ºywane)
  const m = url.match(/\/items\/(\d+)/i);
  if (m) {
    const id = m[1];
    if (!it.item_id) it.item_id = id;
    if (!it.vinted_id) it.vinted_id = id;
  }

  return it;
}

function __fydFixVintedItems(items) {
  if (!Array.isArray(items)) return items;
  return items.map((it) => __fydEnsureVintedItemFields(it));
}

import dotenv from "dotenv";
dotenv.config();

// ---- Proxy config (env) ----
// Playwright expects: { server, username?, password? }
  if (!server) return null;

  const username = String(process.env.PROXY_USERNAME || process.env.PROXY_USER || "").trim();
  const password = String(process.env.PROXY_PASSWORD || process.env.PROXY_PASS || "").trim();

  const obj = { server };
  if (username) obj.username = username;
  if (password) obj.password = password;
  return obj;
})();


// __FYD_OUTGOING_TEXT_FIX_V1__
function __fydAppendVintedUrl(text) {
  text = String(text ?? "");
  if (text.includes("vinted.pl/items/")) return text;
  const m = text.match(/\bVinted\s+(\d{6,})\b/);
  if (!m) return text;
  return text + "\nhttps://www.vinted.pl/items/" + m[1];
}

function __fydAppendUrlFromKeyboard(text, payload) {
  try {
    text = String(text ?? "");
    if (text.includes("http://") || text.includes("https://")) return text;

    const kb = payload && payload.reply_markup && payload.reply_markup.inline_keyboard;
    if (!Array.isArray(kb)) return text;

    for (const row of kb) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        const u = btn && typeof btn.url === "string" ? btn.url : "";
        if (u.startsWith("http://") || u.startsWith("https://")) {
          return text + "\n" + u;
        }
      }
    }
    return text;
  } catch {
    return String(text ?? "");
  }
}

function __fydFixOutgoingText(text, payload) {
  text = __fydAppendVintedUrl(text);
  text = __fydAppendUrlFromKeyboard(text, payload);
  return text;
}

import { chromium, request } from "playwright";

/* __FYD_PW_PROXY_PREAUTH_V1__ */
import * as http from "http";
import * as net from "net";

/* __FYD_PW_PREAUTH_CACHE_WRAP_V1__ */
let __FYD_PW_PREAUTH_CACHE = null;
let __FYD_PW_PREAUTH_INFLIGHT = null;
/* __FYD_PW_PREAUTH_CACHE_V3__ */
let __FYD_PW_PREAUTH_PROMISE_V3 = null;
async function __fydStartPreauthProxyIfNeeded() {
  // __FYD_PREAUTH_HARD_DISABLED
  return null;

  /* __FYD_DISABLE_PW_PREAUTH_V1__ */
  // Disabled: prevents spawning local playwright-preauth proxy per request.
  // We rely on Playwright's native proxy auth via launchOpts.proxy (server/username/password).
  return null;

  if (__FYD_PW_PREAUTH_PROMISE_V3) return await __FYD_PW_PREAUTH_PROMISE_V3;
  __FYD_PW_PREAUTH_PROMISE_V3 = (async () => {
    try { return await __fydStartPreauthProxyIfNeeded__impl(); } catch { return null; }
  })();
  return await __FYD_PW_PREAUTH_PROMISE_V3;
}

async function __fydStartPreauthProxyIfNeeded__impl() {
  if (__FYD_PW_PREAUTH_CACHE) return __FYD_PW_PREAUTH_CACHE;
  if (__FYD_PW_PREAUTH_INFLIGHT) return await __FYD_PW_PREAUTH_INFLIGHT;
  __FYD_PW_PREAUTH_INFLIGHT = (async () => {
    const r = await __fydStartPreauthProxyIfNeeded__orig();
    if (r && r.server) __FYD_PW_PREAUTH_CACHE = r;
    return r;
  })();
  try { return await __FYD_PW_PREAUTH_INFLIGHT; }
  finally { __FYD_PW_PREAUTH_INFLIGHT = null; }
}

/* __FYD_PW_PREAUTH_SINGLETON_FROM_LOG_V5__ */

async function __fydStartPreauthProxyIfNeeded__orig(...__args) {

  const g = globalThis;

  if (g.__FYD_PW_PREAUTH_SINGLETON_V5_RESULT) return g.__FYD_PW_PREAUTH_SINGLETON_V5_RESULT;

  if (g.__FYD_PW_PREAUTH_SINGLETON_V5_PROMISE) return await g.__FYD_PW_PREAUTH_SINGLETON_V5_PROMISE;

  g.__FYD_PW_PREAUTH_SINGLETON_V5_PROMISE = (async () => {

    const r = await __fydStartPreauthProxyIfNeeded__orig__impl(...__args);

    g.__FYD_PW_PREAUTH_SINGLETON_V5_RESULT = r;

    return r;

  })();

  return await g.__FYD_PW_PREAUTH_SINGLETON_V5_PROMISE;

}


async function __fydStartPreauthProxyIfNeeded__orig__impl() {
  const en = String(process.env.PROXY_ENABLED || "").trim().toLowerCase();
  if (!["1", "true", "yes", "on"].includes(en)) return null;

  const upstream = String(process.env.PROXY_SERVER || "").trim();
  const user = String(process.env.PROXY_USERNAME || process.env.PROXY_USER || "").trim();
  const pass = String(process.env.PROXY_PASSWORD || process.env.PROXY_PASS || "").trim();

  if (!upstream || !user || !pass) return null;

  if (/^socks5:\/\//i.test(upstream)) {
    console.warn("[proxy] PROXY_SERVER=socks5://... ‚Äî Chromium nie wspiera socks5 auth. Ustaw PROXY_SERVER na http://host:port");
    return null;
  }

  let U;
  try {
    U = new URL(upstream);
  } catch {
    console.warn("[proxy] z≈Çy PROXY_SERVER:", upstream);
    return null;
  }

  const host = U.hostname;
  const port = Number(U.port || 80);
  const auth = Buffer.from(user + ":" + pass).toString("base64");

  const srv = http.createServer();

  srv.on("connect", (req, clientSocket, head) => {
    const [dstHost, dstPortRaw] = String(req.url || "").split(":");
    const dstPort = Number(dstPortRaw || 443);

    const upstreamSocket = net.connect(port, host, () => {
      upstreamSocket.write(
        "CONNECT " + dstHost + ":" + dstPort + " HTTP/1.1\r\n" +
          "Host: " + dstHost + ":" + dstPort + "\r\n" +
          "Proxy-Authorization: Basic " + auth + "\r\n" +
          "Connection: keep-alive\r\n\r\n"
      );
    });

    upstreamSocket.once("data", (chunk) => {
      const s = chunk.toString("utf8");
      if (!/^HTTP\/1\.[01]\s+200\b/i.test(s)) {
        try {
          clientSocket.write("HTTP/1.1 502 Bad Gateway\r\n\r\n");
        } catch {}
        clientSocket.destroy();
        upstreamSocket.destroy();
        return;
      }

      try {
        clientSocket.write("HTTP/1.1 200 Connection Established\r\n\r\n");
      } catch {}
      if (head && head.length) upstreamSocket.write(head);

      clientSocket.pipe(upstreamSocket);
      upstreamSocket.pipe(clientSocket);
    });

    upstreamSocket.on("error", () => {
      try {
        clientSocket.destroy();
      } catch {}
    });
    clientSocket.on("error", () => {
      try {
        upstreamSocket.destroy();
      } catch {}
    });
  });

  await new Promise((res) => srv.listen(0, "127.0.0.1", res));
  const localPort = srv.address().port;
  const localServer = "http://127.0.0.1:" + localPort;

  console.log("[proxy] playwright-preauth local=" + localServer + " upstream=" + upstream);
  return { server: localServer, _srv: srv };
}

import {
  initDb,
  getLinksForWorker,
  getSeenItemKeys,
  insertLinkItems,
  updateLastKey,
  pruneLinkItems,
} from "./db.js";
import _fetch from "node-fetch";
import pg from "pg";

const { Pool } = pg;

// Osobny pool tylko do chat_notifications / link_notification_modes / limity dzienne
const notifyPool = process.env.DATABASE_URL
  ? new Pool({ connectionString: process.env.DATABASE_URL })
  : new Pool();

// ---- FYD helpers (restored) ----

// ---- key normalization (restored) ----
function cleanKey(x) {
  if (x === null || x === undefined) return "";
  const s = String(x).trim();
  if (!s) return "";
  try {
    if (s.startsWith("http://") || s.startsWith("https://")) {
      const u = new URL(s);
      u.hash = "";
      u.search = "";
      return u.toString();
    }
  } catch {}
  return s;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function __fydParseFeatureValue(v) {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (s === "true") return true;
  if (s === "false") return false;
  if (s !== "" && /^[0-9]+$/.test(s)) return Number(s);
  if ((s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"))) {
    try { return JSON.parse(s); } catch {}
  }
  return v;
}

async function getUserLimits(telegramUserId) {
  try {
    const tgid = Number(telegramUserId);
    if (!Number.isFinite(tgid) || tgid <= 0) return null;

    const subQ = `
      SELECT u.id AS user_id,
             COALESCE(p.code, 'free') AS plan_code,
             COALESCE(s.addon_qty, 0) AS addon_qty
      FROM users u
      LEFT JOIN LATERAL (
        SELECT *
        FROM subscriptions
        WHERE user_id = u.id AND status = 'active'
        ORDER BY id DESC
        LIMIT 1
      ) s ON true
      LEFT JOIN plans p ON p.id = s.plan_id
      WHERE u.telegram_user_id = $1
      LIMIT 1
    `;
    const subR = await notifyPool.query(subQ, [tgid]);
    const row = subR?.rows?.[0];
    if (!row) return null;

    const planCode = String(row.plan_code || "free");
    const addonQty = Number(row.addon_qty || 0);

    const pfQ = `
      SELECT pf.feature_key, pf.feature_value
      FROM plan_features pf
      JOIN plans p ON p.id = pf.plan_id
      WHERE p.code = $1
      ORDER BY pf.feature_key
    `;
    const pfR = await notifyPool.query(pfQ, [planCode]);

    const limits = { plan_code: planCode, addon_qty: addonQty };
    for (const r of (pfR?.rows || [])) {
      limits[r.feature_key] = __fydParseFeatureValue(r.feature_value);
    }
    return limits;
  } catch {
    return null;
  }
}
// ---- FYD helpers (restored) END ----


// __FYD_TG_WRAPPED_FETCH_V2
const __FYD_TG_LANG_CACHE = new Map(); // chat_id -> { lang, ts }

async function __fydLangForChat(chatId) {
  const cid = Number(chatId);
  if (!Number.isFinite(cid)) return "en";
  const now = Date.now();
  const hit = __FYD_TG_LANG_CACHE.get(cid);
  if (hit && (now - hit.ts) < 60000) return hit.lang;

  let lang = "";

  // 1) per-chat (grupy te≈º)
  try {
    const r = await notifyPool.query("SELECT lang FROM chat_notifications WHERE chat_id=$1 LIMIT 1", [cid]);
    if (r?.rows?.[0]?.lang) lang = String(r.rows[0].lang);
  } catch {}

  // 2) fallback -> users.lang
  if (!lang) {
    try {
      const r = await notifyPool.query("SELECT lang FROM users WHERE telegram_user_id=$1 LIMIT 1", [cid]);
      if (r?.rows?.[0]?.lang) lang = String(r.rows[0].lang);
    } catch {}
  }

  const raw = String(lang || "").trim().toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  const out = base || "en";
  __FYD_TG_LANG_CACHE.set(cid, { lang: out, ts: now });
  return out;
}

function __fydBtn(lang, key) {
  const L = String(lang || "en");
  const d = {
    en: { disable:"Disable this link", single:"Single", batch:"Batch" },
    pl: { disable:"Wy≈ÇƒÖcz ten link", single:"Pojedynczo", batch:"Zbiorczo" },
    cs: { disable:"Vypnout tento odkaz", single:"Jednotlivƒõ", batch:"Hromadnƒõ" },
  };
  const pack = d[L] || d.en;
  return pack[key] || d.en[key] || String(key);
}

function __fydStripIcons(t) {
  return String(t || "").replace(/^[^\p{L}\p{N}]+/gu, "").trim();
}
function __fydIsDisable(t) {
  t = t.toLowerCase();
  return t.includes("wy≈ÇƒÖcz") || t.includes("wylacz") || t.includes("disable") || t.includes("vypnout");
}
function __fydIsSingle(t) {
  t = t.toLowerCase();
  return t.includes("pojedyncz") || t.includes("single") || t.includes("jednotliv");
}
function __fydIsBatch(t) {
  t = t.toLowerCase();
  return t.includes("zbiorcz") || t.includes("batch") || t.includes("hromad");
}

function __fydNormalizeInlineKeyboard(obj, lang) {
  if (!obj || !Array.isArray(obj.inline_keyboard)) return obj;
  for (const row of obj.inline_keyboard) {
    if (!Array.isArray(row)) continue;
    for (const btn of row) {
      if (!btn || typeof btn !== "object" || typeof btn.text !== "string") continue;
      const base = __fydStripIcons(btn.text);
      if (__fydIsDisable(base)) btn.text = __fydBtn(lang, "disable");
      else if (__fydIsSingle(base)) btn.text = __fydBtn(lang, "single");
      else if (__fydIsBatch(base)) btn.text = __fydBtn(lang, "batch");
    }
  }
  return obj;
}

function __isFormData(body) {
  return body && typeof body === "object"
    && typeof body.get === "function"
    && typeof body.set === "function"
    && typeof body.entries === "function";
}

function __fydParseBodyToPayload(opts) {
  const headers = (opts && opts.headers) ? opts.headers : {};
  const body = opts ? opts.body : undefined;

  if (__isFormData(body)) return { mode: "formdata", payload: null };

  if (typeof body === "string") {
    try {
      const obj = JSON.parse(body);
      return { mode: "json", payload: obj };
    } catch {}
    try {
      const params = new URLSearchParams(body);
      const obj = Object.fromEntries(params.entries());
      return { mode: "urlencoded", payload: obj };
    } catch {}
    return null;
  }

  try {
    if (body && typeof body === "object" && body.constructor && body.constructor.name === "URLSearchParams") {
      const obj = Object.fromEntries(body.entries());
      return { mode: "urlencoded", payload: obj };
    }
  } catch {}

  return null;
}

function __fydWritePayload(opts, mode, payload) {
  const nopts = Object.assign({}, opts || {});
  if (mode === "json") {
    nopts.body = JSON.stringify(payload);
    return nopts;
  }
  if (payload && typeof payload.reply_markup === "object") {
    payload.reply_markup = JSON.stringify(payload.reply_markup);
  }
  nopts.body = new URLSearchParams(payload).toString();
  return nopts;
}

// UWAGA: od tego miejsca ca≈Ça reszta pliku u≈ºywa `fetch` -> idzie przez tƒô bramkƒô
const fetch = async (url, opts) => {
  const u = String(url || "");
  if (!u.includes("api.telegram.org")) return _fetch(url, opts);

  const method = String((opts && opts.method) ? opts.method : "GET").toUpperCase();
  if (method !== "POST") return _fetch(url, opts);

  // 1) FormData (sendPhoto / media) ‚Äî tu V1 przegrywa≈Ç
  const body = opts ? opts.body : undefined;
  if (__isFormData(body)) {
    const chatId = body.get("chat_id");
    const lang = await __fydLangForChat(chatId);

    const rm = body.get("reply_markup");
    if (rm && typeof rm === "string") {
      try {
        const obj = JSON.parse(rm);
        body.set("reply_markup", JSON.stringify(__fydNormalizeInlineKeyboard(obj, lang)));
      } catch {}
    }

    // preview ON dla sendMessage, je≈õli akurat idzie FormData
    if (u.includes("/sendMessage")) {
      try { body.set("disable_web_page_preview", "false"); } catch {}
      try { body.set("link_preview_options", JSON.stringify({ is_disabled: false })); } catch {}
    }

    return _fetch(url, opts);
  }

  // 2) JSON / urlencoded
  const parsed = __fydParseBodyToPayload(opts);
  if (!parsed || (parsed.mode !== "json" && parsed.mode !== "urlencoded")) return _fetch(url, opts);

  const payload = parsed.payload;
  if (!payload || typeof payload !== "object") return _fetch(url, opts);

  const lang = await __fydLangForChat(payload.chat_id);

  if (u.includes("/sendMessage")) {
    payload.disable_web_page_preview = false;
    payload.link_preview_options = { is_disabled: false };
  }

  if (payload.reply_markup) {
    if (typeof payload.reply_markup === "string") {
      try {
        const obj = JSON.parse(payload.reply_markup);
        payload.reply_markup = JSON.stringify(__fydNormalizeInlineKeyboard(obj, lang));
      } catch {}
    } else if (typeof payload.reply_markup === "object") {
      payload.reply_markup = __fydNormalizeInlineKeyboard(payload.reply_markup, lang);
    }
  }

  const nopts = __fydWritePayload(opts, parsed.mode, payload);
  return _fetch(url, nopts);
};
// =================== KONFIG TELEGRAM / WORKER ===================


// __FYD_WORKER_TG_OUTBOUND_NORM_V2
async function __fydLangForChatWorker(chatId) {
  let lang = "en";
  try {
    const cid = Number(chatId);
    if (Number.isFinite(cid) && cid > 0) {
      // private chat: chat_id == telegram_user_id
      const r = await notifyPool.query("SELECT lang FROM users WHERE telegram_user_id=$1 LIMIT 1", [cid]);
      if (r?.rows?.[0]?.lang) lang = String(r.rows[0].lang);
    }
  } catch {}
  const raw = String(lang || "").trim().toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  return base || "en";
}

function __fydTWorker(lang, key) {
  const L = String(lang || "en");
  const d = {
    en: { disable:"Disable this link", single:"Single", batch:"Batch" },
    pl: { disable:"Wy≈ÇƒÖcz ten link", single:"Pojedynczo", batch:"Zbiorczo" },
    cs: { disable:"Vypnout tento odkaz", single:"Jednotlivƒõ", batch:"Hromadnƒõ" },
  };
  const pack = d[L] || d.en;
  return pack[key] || d.en[key] || String(key);
}

function __fydStripIconsWorker(t) {
  return String(t || "").replace(/^[^\p{L}\p{N}]+/gu, "").trim();
}
function __fydIsDisableWorker(t) {
  t = t.toLowerCase();
  return t.includes("wy≈ÇƒÖcz") || t.includes("wylacz") || t.includes("disable") || t.includes("vypnout");
}
function __fydIsSingleWorker(t) {
  t = t.toLowerCase();
  return t.includes("pojedyncz") || t.includes("single") || t.includes("jednotliv");
}
function __fydIsBatchWorker(t) {
  t = t.toLowerCase();
  return t.includes("zbiorcz") || t.includes("batch") || t.includes("hromad");
}

async function __fydNormalizeTgPayloadWorker(url, payload) {
  try {
    if (!payload || typeof payload !== "object") return payload;

    const lang = await __fydLangForChatWorker(payload.chat_id);

    // sendMessage: preview ON (≈ºeby czƒô≈õciej by≈Ç obrazek z link preview)
    const ep = String(url || "").split("?")[0];
    if (ep.includes("/sendMessage")) {
      payload.disable_web_page_preview = false;
      payload.link_preview_options = { is_disabled: false };
    }

    // inline buttons: bez ikon + w jƒôzyku z DB
    let rm = payload.reply_markup;
    if (!rm) return payload;

    let obj = rm;
    let wasString = false;
    if (typeof rm === "string") {
      try { obj = JSON.parse(rm); wasString = true; } catch { return payload; }
    }
    if (!obj || !Array.isArray(obj.inline_keyboard)) return payload;

    for (const row of obj.inline_keyboard) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        if (!btn || typeof btn !== "object" || typeof btn.text !== "string") continue;
        const base = __fydStripIconsWorker(btn.text);
        if (__fydIsDisableWorker(base)) btn.text = __fydTWorker(lang, "disable");
        else if (__fydIsSingleWorker(base)) btn.text = __fydTWorker(lang, "single");
        else if (__fydIsBatchWorker(base)) btn.text = __fydTWorker(lang, "batch");
      }
    }

    payload.reply_markup = wasString ? JSON.stringify(obj) : obj;
    return payload;
  } catch {
    return payload;
  }
}

const __FYD_TG_FETCH_ORIG_V2 = fetch;
async function __fydTgFetch(url, opts) {
  try {
    const u = String(url || "");
    if (!u.includes("api.telegram.org")) return __FYD_TG_FETCH_ORIG_V2(url, opts);

    const method = (opts && opts.method) ? String(opts.method).toUpperCase() : "GET";
    if (method !== "POST") return __FYD_TG_FETCH_ORIG_V2(url, opts);

    const body = opts && opts.body;
    if (typeof body !== "string") return __FYD_TG_FETCH_ORIG_V2(url, opts);

    let payload;
    try { payload = JSON.parse(body); } catch { return __FYD_TG_FETCH_ORIG_V2(url, opts); }

    payload = await __fydNormalizeTgPayloadWorker(u, payload);

    const nopts = Object.assign({}, (opts || {}));
    nopts.body = JSON.stringify(payload);
    return __FYD_TG_FETCH_ORIG_V2(url, nopts);
  } catch {
    return __FYD_TG_FETCH_ORIG_V2(url, opts);
  }
}
const TG = process.env.TELEGRAM_BOT_TOKEN || "";


/* __FYD_PW_PREAUTH_ONCE_V6__ */
let __FYD_PW_PREAUTH_ONCE_V6_RESULT = undefined;
async function __fydGetPreauthProxyOnce() {
  if (__FYD_PW_PREAUTH_ONCE_V6_RESULT !== undefined) return __FYD_PW_PREAUTH_ONCE_V6_RESULT;
  __FYD_PW_PREAUTH_ONCE_V6_RESULT = PROXY;
  return __FYD_PW_PREAUTH_ONCE_V6_RESULT;
}

/* __FYD_PW_PREAUTH_ONCE_V1__ */
async function __fydGetPreauthProxy() {
  return await __fydGetPreauthProxyOnce();
}

const API_BASE = process.env.API_BASE || "http://api:3000";

// ---- PROXY config (worker) ----
const __PROXY_ON = String(process.env.PROXY_ENABLED || "").trim().toLowerCase();
const PROXY_SERVER = process.env.PROXY_SERVER || "";
const PROXY_USERNAME = process.env.PROXY_USERNAME || process.env.PROXY_USER || "";
const PROXY_PASSWORD = process.env.PROXY_PASSWORD || process.env.PROXY_PASS || "";
const PROXY =
  (( __PROXY_ON === "1" || __PROXY_ON === "true" || __PROXY_ON === "yes") && PROXY_SERVER)
    ? { server: PROXY_SERVER, username: PROXY_USERNAME, password: PROXY_PASSWORD }
    : null;



// debug logi
const DEBUG = process.env.DEBUG_WORKER === "true" || process.env.DEBUG === "true";

function logDebug(...args) {
  if (DEBUG) console.log(...args);
}

// ---- FYD: reduce proxy transfer (Playwright) + Vinted previews + link label in offers ----
async function __fydBlockHeavyAssets(target) {
  try {
    await target.route("**/*", (route) => {
      const t = route.request().resourceType();
      if (t === "image" || t === "media" || t === "font") return route.abort();
      return route.continue();
    });
  } catch {}
}

function __fydDecorateItems(link, items) {
  const label = String(link?.label || "").trim();
  if (!label) return items;
  const prefix = label + " ¬∑ ";
  return (items || []).map((it) => {
    const title = it?.title != null ? String(it.title) : "";
    return { ...it, title: prefix + title };
  });
}

// Telegram podglƒÖd dla Vinted: dopnij jawny URL do /items/... na ko≈Ñcu wiadomo≈õci
// (Telegram robi preview po og:image, ale najpewniej gdy ma "go≈Çy" URL w tre≈õci).
function __fydEnsureVintedPreviewUrl(text) {
  const s = String(text || "");
  if (!s.includes("vinted.") || !s.includes("/items/")) return s;

  const m1 = s.match(/https?:\/\/[^\s"']*vinted\.[^\s"']*\/items\/[^\s<>"']+/i);
  const m2 = s.match(/href="(https?:\/\/[^"]*vinted\.[^"]*\/items\/[^"]+)"/i);
  const url = (m1 && m1[0]) || (m2 && m2[1]) || "";
  if (!url) return s;

  const esc = url.replace(/[.*+?^$()|[\]\\]/g, "\\$&");
  const lineRe = new RegExp("(^|\\n)" + esc + "(\\n|$)");
  if (lineRe.test(s)) return s;

  return s.replace(/\s+$/, "") + "\n" + url;
}

// Konfiguracja workera
const LOOP_DELAY_MS = Number(process.env.LOOP_DELAY_MS || 300000);
const SLEEP_BETWEEN_ITEMS_MS = Number(process.env.SLEEP_BETWEEN_ITEMS_MS || 1200);

const MAX_ITEMS_PER_LINK_PER_LOOP = Number(process.env.MAX_ITEMS_PER_LINK_PER_LOOP || 10);
const MIN_BATCH_ITEMS = 1;

const HISTORY_KEEP_PER_LINK = Number(process.env.HISTORY_KEEP_PER_LINK || 500);

const SOURCE_CONFIG = {
  olx: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
  vinted: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
  default: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
};

function getSourceConfig(source) {
  const key = (source || "").toLowerCase();
  return SOURCE_CONFIG[key] || SOURCE_CONFIG.default;
}

// Bufory dla trybu /zbiorcze ‚Äì klucz: "userId:chatId:linkId"
const batchBuffers = new Map();

function normalizeOlxUrl(u = "") {
  try {
    let out = String(u ?? "").trim();
    if (!out) return "";
    if (/^ID[0-9A-Za-z]+$/.test(out)) return out;
    if (!/^https?:\/\//i.test(out)) return out;

    const url = new URL(out);
    url.hash = "";
    url.search = "";
    url.hostname = "www.olx.pl";
    url.pathname = url.pathname.replace(/^\/d\//, "/");
    url.pathname = url.pathname.replace(/\/+$/, "");
    return url.toString().replace(/\/+$/, "");
  } catch {
    return String(u ?? "").trim();
  }
}

function getItemKey(it) {
  return it?.itemKey || it?.item_key || it?.itemKeyNormalized || null;
}

function takeNewItemsUntilLastKey(items, lastKey) {
  if (!lastKey) return { fresh: [], found: false };

  const out = [];
  let found = false;

  for (const it of items || []) {
    const k = getItemKey(it);
    if (!k) continue;
    if (k === lastKey) {
      found = true;
      break;
    }
    out.push(it);
  }

  return { fresh: out, found };
}

function isHourInQuietRange(hour, from, to) {
  if (typeof hour !== "number") return false;
  if (typeof from !== "number" || typeof to !== "number") return false;

  hour = ((hour % 24) + 24) % 24;
  from = ((from % 24) + 24) % 24;
  to = ((to % 24) + 24) % 24;

  if (from === to) return false;

  if (from < to) return hour >= from && hour < to;
  return hour >= from || hour < to;
}

function detectSource(url) {
  try {
    const u = new URL(url);
    const h = (u.hostname || "").toLowerCase();
    if (h.includes("olx.")) return "olx";
    if (h.includes("vinted.")) return "vinted";
    return null;
  } catch {
    return null;
  }
}

function normalizeKey(url) {
  try {
    const u = new URL(url);
    const host = (u.hostname || "").toLowerCase();

    if (host.includes("olx.")) {
      u.hostname = "www.olx.pl";
      const m = u.pathname.match(/\/(d\/)?oferta\/([^/?#]+)(\/.*)?$/);
      if (m) {
        const slug = m[2];
        u.pathname = `/oferta/${slug}`;
      }
      u.search = "";
      u.hash = "";
      return u.toString();
    }

    if (host.includes("vinted.")) {
      if (u.pathname === "/session-refresh") {
        const ref = u.searchParams.get("ref_url");
        if (ref) {
          try {
            const decoded = decodeURIComponent(ref);
            const u2 = new URL(decoded, `${u.protocol}//${u.host}`);
            if (u2.pathname.startsWith("/items/")) {
              const m2 = u2.pathname.match(/^\/items\/(\d+)/i);
              if (m2) u2.pathname = `/items/${m2[1]}`;
              u2.search = "";
              u2.hash = "";
              return u2.toString();
            }
          } catch {}
        }
      }

      if (u.pathname.startsWith("/items/")) {
        const m = u.pathname.match(/^\/items\/(\d+)/i);
        if (m) u.pathname = `/items/${m[1]}`;
        u.search = "";
        u.hash = "";
        return u.toString();
      }
    }

    u.search = "";
    u.hash = "";
    return u.toString();
  } catch {
    return url;
  }
}

// Minimalne escape HTML dla Telegrama
function escapeHtml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

// Parsowanie ceny
function parsePrice(text) {
  if (!text) return { price: null, currency: null };

  const m = String(text).match(/([\d\s.,]+)\s*([A-Za-z‚Ç¨$≈Ç≈Å]+)?/i);
  if (!m) return { price: null, currency: null };

  const numStr = m[1].replace(/\s/g, "").replace(",", ".");
  const price = Number.parseFloat(numStr);
  const rawCurr = (m[2] || "").toUpperCase();

  let currency = null;
  if (/PLN|Z≈Å|ZL/.test(rawCurr)) currency = "PLN";
  else if (/EUR|‚Ç¨/.test(rawCurr)) currency = "EUR";
  else if (/USD|\$/.test(rawCurr)) currency = "USD";
  else if (rawCurr) currency = rawCurr;

  return { price: Number.isFinite(price) ? price : null, currency };
}

// Telegram send (retry 429)

// __FYD_SENDTELEGRAM_LABEL_I18N_V1__
const __FYD_META_CACHE = new Map();

function __fydEsc(x) {
  return String(x || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

function __fydNormLang(x) {
  const raw = String(x || "").trim().toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  return base || "en";
}

const __FYD_I18N = {
  en: { new_listings: "New listings", full_history: "Full history:", btn_disable: "Disable this link", btn_single: "Single", btn_batch: "Batch" },
  pl: { new_listings: "Nowe og≈Çoszenia", full_history: "Pe≈ÇnƒÖ historiƒô zobaczysz w", btn_disable: "Wy≈ÇƒÖcz ten link", btn_single: "Pojedynczo", btn_batch: "Zbiorczo" },
  de: { new_listings: "Neue Angebote", full_history: "Voller Verlauf:", btn_disable: "Link deaktivieren", btn_single: "Einzeln", btn_batch: "Sammel" },
  fr: { new_listings: "Nouvelles annonces", full_history: "Historique complet :", btn_disable: "D√©sactiver ce lien", btn_single: "Unitaire", btn_batch: "Group√©" },
  es: { new_listings: "Nuevos anuncios", full_history: "Historial completo:", btn_disable: "Desactivar este enlace", btn_single: "Individual", btn_batch: "Por lotes" },
  it: { new_listings: "Nuovi annunci", full_history: "Cronologia completa:", btn_disable: "Disattiva questo link", btn_single: "Singolo", btn_batch: "Raggruppato" },
  pt: { new_listings: "Novos an√∫ncios", full_history: "Hist√≥rico completo:", btn_disable: "Desativar este link", btn_single: "Individual", btn_batch: "Em lote" },
  nl: { new_listings: "Nieuwe advertenties", full_history: "Volledige geschiedenis:", btn_disable: "Deze link uitzetten", btn_single: "Los", btn_batch: "Batch" },
  ro: { new_listings: "Anun»õuri noi", full_history: "Istoric complet:", btn_disable: "DezactiveazƒÉ acest link", btn_single: "Individual", btn_batch: "√én lot" },
  cs: { new_listings: "Nov√© inzer√°ty", full_history: "Cel√° historie:", btn_disable: "Vypnout tento odkaz", btn_single: "Jednotlivƒõ", btn_batch: "Hromadnƒõ" },
  hu: { new_listings: "√öj hirdet√©sek", full_history: "Teljes el≈ëzm√©ny:", btn_disable: "Link kikapcsol√°sa", btn_single: "Egyenk√©nt", btn_batch: "Csoportosan" },
};

function __fydT(lang, key) {
  const l = __fydNormLang(lang);
  return (__FYD_I18N[l] && __FYD_I18N[l][key]) || (__FYD_I18N.en && __FYD_I18N.en[key]) || key;
}

async function __fydGetMetaByLinkId(linkId) {
  const now = Date.now();
  const cached = __FYD_META_CACHE.get(linkId);
  if (cached && now - cached.ts < 30 * 1000) return cached;

  try {
    const db = (typeof notifyPool !== "undefined" && notifyPool) ? notifyPool : null;

    if (!db || typeof db.query !== "function") {
      const meta = { id: linkId, label: "", lang: "en", ts: now };
      __FYD_META_CACHE.set(linkId, meta);
      return meta;
    }

    const r = await db.query(
      "SELECT COALESCE(l.label,'') AS label, COALESCE(u.lang,'en') AS lang FROM links l JOIN users u ON u.id=l.user_id WHERE l.id=$1",
      [linkId]
    );
    const row = (r.rows && r.rows[0]) || {};
    const meta = { id: linkId, label: String(row.label || "").trim(), lang: String(row.lang || "en"), ts: now };
    __FYD_META_CACHE.set(linkId, meta);
    return meta;
  } catch {
    const meta = { id: linkId, label: "", lang: "en", ts: now };
    __FYD_META_CACHE.set(linkId, meta);
    return meta;
  }
}

function __fydRewriteTextAndButtons(text, meta, payload) {
  const lang = __fydNormLang(meta.lang);
  let out = String(text || "");

  // üÜï ...
  out = out.replace(
    /^(?:üÜï\s*)?(?:New listings|Nowe og≈Çoszenia|Neue Angebote|Nouvelles annonces|Nuevos anuncios|Nuovi annunci|Novos an√∫ncios|Nieuwe advertenties|Anun»õuri noi|Nov√© inzer√°ty|√öj hirdet√©sek)\s*$/m,
    "üÜï " + __fydT(lang, "new_listings")
  );

  // üîç ... ¬∑ ID N -> je≈õli label istnieje, to podmie≈Ñ tytu≈Ç na label
  if (meta.label) {
    const re = new RegExp("^(\\s*(?:üîç|üîé)\\s*)(.*?)\\s*¬∑\\s*ID\\s*" + meta.id + "\\b", "m");
    out = out.replace(re, function (_, pref) {
      return pref + __fydEsc(meta.label) + " ¬∑ ID " + meta.id;
    });

    // fallback: obs≈Çu≈º te≈º "ID <b>119</b>"
    const re2 = new RegExp("^(\\s*(?:üîç|üîé)\\s*).*?\\s*¬∑\\s*\\bID\\b\\s*(?:<[^>]*>\\s*)?" + meta.id + "(?:\\s*<\\/[^>]+>)?\\s*$", "m");
    out = out.replace(re2, function (_, pref) {
      return pref + __fydEsc(meta.label) + " ¬∑ ID " + meta.id;
    });
  }

  // linia z /najnowsze N (je≈õli wystƒôpuje)
  const reHist = new RegExp("^.*\\/najnowsze\\s+" + meta.id + "\\s*$", "m");
  out = out.replace(reHist, __fydT(lang, "full_history") + " /najnowsze " + meta.id);

  // fallback: podmie≈Ñ te≈º r√≥≈ºne prefiksy
  const reHist2 = new RegExp("^[^\\n]*\\/najnowsze\\s+" + meta.id + "[^\\n]*$", "m");
  out = out.replace(reHist2, __fydT(lang, "full_history") + " /najnowsze " + meta.id);

  // przyciski inline_keyboard
  try {
    const rm = payload && payload.reply_markup;
    if (rm && Array.isArray(rm.inline_keyboard)) {
      for (const row of rm.inline_keyboard) {
        if (!Array.isArray(row)) continue;
        for (const btn of row) {
          if (!btn || typeof btn.text !== "string") continue;
          const t = btn.text.trim();
          if (t === "Wy≈ÇƒÖcz ten link" || t === "Disable this link" || t === "üîï Wy≈ÇƒÖcz ten link") btn.text = __fydT(lang, "btn_disable");
          if (t === "Pojedynczo" || t === "Single" || t === "üì® Pojedynczo") btn.text = __fydT(lang, "btn_single");
          if (t === "Zbiorczo" || t === "Batch" || t === "üì¶ Zbiorczo") btn.text = __fydT(lang, "btn_batch");
        }
      }
    }
  } catch {}

  return out;
}

async function sendTelegram(method, payload) {
  /* __FYD_TG_LIMITS_V1__ */
  // Telegram hard limits: sendMessage text 4096 chars, captions ~1024.
  // Truncujemy, ≈ºeby nie by≈Ço 400: "message is too long".
  try {
    if (method === "sendMessage" && payload && typeof payload.text === "string" && payload.text.length > 3900) {
      payload = { ...payload, text: payload.text.slice(0, 3900) + "\n‚Ä¶(obciƒôte: limit Telegram 4096)" };
    }
    if ((method === "sendPhoto" || method === "sendDocument" || method === "sendVideo" || method === "sendAnimation") &&
        payload && typeof payload.caption === "string" && payload.caption.length > 900) {
      payload = { ...payload, caption: payload.caption.slice(0, 900) + "‚Ä¶" };
    }
  } catch {}
/* __FYD_TG_LIMITS_V1__ END */

  // TG: limit d≈Çugo≈õci + unikaj album√≥w (uciƒôte miniatury)
  try {
    if (typeof method === "string" && payload && typeof payload === "object") {
      const __trim = (str, lim) => {
        const t = String(str || "");
        if (t.length <= lim) return t;
        return t.slice(0, lim - 20) + "\n‚Ä¶(uciƒôto)";
      };

      if (typeof payload.text === "string") payload.text = __trim(payload.text, 3900);
      if (typeof payload.caption === "string") payload.caption = __trim(payload.caption, 900);

      // Albumy -> 1 zdjƒôcie (sendPhoto), ≈ºeby nie by≈Ço ‚Äûuciƒôƒá‚Äù podglƒÖdu
      if (method === "sendMediaGroup" && Array.isArray(payload.media) && payload.media.length) {
        const first = payload.media[0] || {};
        const photo = first.media || first.file_id || first.url;
        const caption = first.caption || payload.caption || "";
        method = "sendPhoto";
        payload = {
          chat_id: payload.chat_id,
          photo,
          caption: __trim(caption, 900),
          parse_mode: first.parse_mode || payload.parse_mode,
        };
      }
    }
  } catch {}


  try {
    if (method === "sendMessage" && payload && typeof payload.text === "string") {
      payload.text = __fydFixOutgoingText(payload.text, payload);
    }
    if (method === "sendPhoto" && payload && typeof payload.caption === "string") {
      payload.caption = __fydFixOutgoingText(payload.caption, payload);
    }
  } catch {}

  // label + i18n nag≈Ç√≥wk√≥w
  try {
    if (method === "sendMessage" && payload && typeof payload.text === "string") {
      const mId = String(payload.text).match(/\bID\b\s*(?:<[^>]*>\s*)?(\d{1,9})/);
      if (mId) {
        const linkId = Number(mId[1]);
        if (Number.isFinite(linkId) && linkId > 0) {
          const meta = await __fydGetMetaByLinkId(linkId);
          payload.text = __fydRewriteTextAndButtons(payload.text, meta, payload);
        }
      }
    }
  } catch {}

  if (!TG) {
    console.error("sendTelegram: brak TELEGRAM_BOT_TOKEN ‚Äì nie wysy≈Çam");
    return;
  }

  const url = `https://api.telegram.org/bot${TG}/${method}`;

  while (true) {
    try {
      const res = await __fydTgFetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const text = await res.text().catch(() => "");

      if (res.status === 429) {
        let retry = 30;
        try {
          const data = JSON.parse(text);
          if (data?.parameters?.retry_after) retry = Number(data.parameters.retry_after) || retry;
        } catch {}
        console.warn(`sendTelegram: 429 retry_after=${retry}s`);
        await sleep(retry * 1000);
        continue;
      }

      if (!res.ok) {
        console.error("sendTelegram: HTTP error", res.status, res.statusText, text);
      }

      break;
    } catch (err) {
      console.error("sendTelegram: exception", err);
      await sleep(2000);
      break;
    }
  }
}

function formatLinkHeader(link) {
  const src = (link.source || detectSource(link.url) || "").toUpperCase();
  let label = link.name || "";
  if (!label) {
    if (src === "OLX") label = "OLX wyszukiwanie";
    else if (src === "VINTED") label = "Vinted wyszukiwanie";
    else label = link.url || "Monitoring";
  }
  const idPart = link.id ? ` ¬∑ <i>ID ${link.id}</i>` : "";
  return `üîç <b>${escapeHtml(label)}</b>${idPart}`;
}

function hiddenLink(url) {
  return `<a href="${escapeHtml(url)}">\u200B</a>`;
}

async function tgSendItem(chatId, link, item) {
  const src = (link.source || detectSource(link.url) || "").toLowerCase();

  // twarde ujednolicenie Vinted item√≥w przed formatowaniem single
  if (src === "vinted") item = __fydEnsureVintedItemFields(item);
  /* __FYD_PHOTO_FALLBACK_V1__ */
  try {
    if (item && !item.photo) {
      item.photo = item.photo_url || item.photoUrl || item.image || item.image_url || item.thumbnail || item.thumb || null;
    }
  } catch {}

  const header = formatLinkHeader(link);

  const title =
    String(item?.title || item?.name || item?.itemTitle || "").trim() ||
    (src === "vinted" ? (__fydDeriveVintedTitleFromUrl(item?.url) || "") : "");

  let caption = `${header}\n\n<b>${escapeHtml(title || "")}</b>\n`;

  if (item.price != null) {
    const priceStr = `${item.price} ${item.currency || ""}`.trim();
    caption += `\nüí∞ ${escapeHtml(priceStr)}`;
  }
  if (item.brand) caption += `\nüè∑Ô∏è ${escapeHtml(item.brand)}`;
  if (item.size) caption += `\nüìè ${escapeHtml(item.size)}`;
  if (item.condition) caption += `\n‚ú® ${escapeHtml(item.condition)}`;

  // wymagane: pe≈Çny URL zawsze w tre≈õci + preview (hidden link)
  const url = String(item.url || "").trim();
  caption += `\n\n${hiddenLink(url)}${escapeHtml(url)}`;

  const keyboard = [
    [{ text: "URL", url }],
    [{ text: "üîï Wy≈ÇƒÖcz ten link", callback_data: `lnmode:${link.id}:off` }],
    [
      { text: "üì® Pojedynczo", callback_data: `lnmode:${link.id}:single` },
      { text: "üì¶ Zbiorczo", callback_data: `lnmode:${link.id}:batch` },
    ],
  ];

  const replyMarkup = { inline_keyboard: keyboard };

  const canSendPhoto =
    src === "vinted" &&
    item.photoUrl &&
    typeof item.photoUrl === "string" &&
    /^https?:\/\//i.test(item.photoUrl);

  if (canSendPhoto) {
    await sendTelegram("sendPhoto", {
      chat_id: chatId,
      photo: item.photoUrl,
      caption,
      parse_mode: "HTML",
      reply_markup: replyMarkup,
    });
  } else {
    await sendTelegram("sendMessage", {
      chat_id: chatId,
      text: caption,
      parse_mode: "HTML",
      disable_web_page_preview: false,
      reply_markup: replyMarkup,
    });
  }

  await sleep(SLEEP_BETWEEN_ITEMS_MS);
}

function buildBatchMessage(link, items, skippedExtra = 0) {
  const header = formatLinkHeader(link);
  let text = `üÜï Nowe og≈Çoszenia\n${header}\n\n`;

  items.forEach((item, idx) => {
    const title = escapeHtml(String(item.title || item.name || item.itemTitle || "").trim());
    const priceStr = item.price != null ? `${item.price} ${item.currency || ""}`.trim() : "";

    text += `${idx + 1}. ${title}\n`;
    if (priceStr) text += `üí∞ ${escapeHtml(priceStr)}\n`;
    text += `${escapeHtml(item.url)}\n\n`;
  });

  if (skippedExtra > 0) text += `+ ${skippedExtra} dodatkowych ofert.\n\n`;
  text += `Pe≈ÇnƒÖ historiƒô zobaczysz w /najnowsze ${link.id}`;

  return text.trim();
}

function makeBatchKey(chatId, userId, linkId) {
  return `${userId}:${chatId}:${linkId}`;
}

async function notifyChatsForLink(link, items, skippedExtra, opts = {}) {
  if (!items || !items.length) return;

  const minBatchItems = opts.minBatchItems || MIN_BATCH_ITEMS;
  const now = new Date();
  const todayStr = now.toISOString().slice(0, 10);
  const nowHour = now.getHours();

  try {
    const res = await notifyPool.query(
      `
      SELECT
        cn.chat_id,
        cn.user_id,
        cn.enabled,
        cn.mode AS chat_mode,
        cn.daily_count,
        cn.daily_count_date,
        LOWER(COALESCE(lnm.mode, cn.mode)) AS effective_mode,
        lnm.mode AS link_mode,
        qh.quiet_enabled,
        qh.quiet_from,
        qh.quiet_to
      FROM links l
      JOIN chat_notifications cn
        ON cn.user_id = l.user_id
       AND (l.chat_id IS NULL OR cn.chat_id = l.chat_id)
      LEFT JOIN LATERAL (
        SELECT mode
        FROM link_notification_modes
        WHERE user_id = cn.user_id
          AND chat_id = cn.chat_id
          AND link_id = l.id
        ORDER BY updated_at DESC NULLS LAST
        LIMIT 1
      ) lnm ON TRUE
      LEFT JOIN chat_quiet_hours qh
        ON qh.chat_id = cn.chat_id
      WHERE l.id = $1
      `,
      [link.id]
    );

    if (!res.rowCount) {
      logDebug(`notifyChatsForLink: link ${link.id} ‚Äì brak chat_notifications`);
      return;
    }

    let chatRows = res.rows.map((row) => ({
      ...row,
      mode: (row.effective_mode || "single").toLowerCase(),
    }));

    // 1) wy≈ÇƒÖczone + OFF
    chatRows = chatRows.filter((row) => row.enabled && row.mode !== "off");
    if (!chatRows.length) return;

    for (const row of chatRows) {
      const chatId = row.chat_id;
      const userId = row.user_id;

      // 2) cisza nocna
      const quietEnabled = !!row.quiet_enabled;
      const quietFrom = typeof row.quiet_from === "number" ? row.quiet_from : 22;
      const quietTo = typeof row.quiet_to === "number" ? row.quiet_to : 7;

      if (quietEnabled && isHourInQuietRange(nowHour, quietFrom, quietTo)) continue;

      // 3) liczniki dzienne
      let dailyCount = row.daily_count || 0;

      let dailyDateStr = null;
      if (row.daily_count_date) {
        dailyDateStr = row.daily_count_date.toISOString
          ? row.daily_count_date.toISOString().slice(0, 10)
          : String(row.daily_count_date).slice(0, 10);
      }
      if (dailyDateStr !== todayStr) {
        dailyCount = 0;
        dailyDateStr = todayStr;
      }

      const maxDaily = await getDailyLimitForUserId(notifyPool, userId);
      if (dailyCount >= maxDaily) {
        await notifyPool.query(
          `
          UPDATE chat_notifications
          SET daily_count = $1,
              daily_count_date = $2
          WHERE chat_id = $3 AND user_id = $4
          `,
          [dailyCount, dailyDateStr, chatId, userId]
        );
        continue;
      }

      const mode = row.mode === "batch" ? "batch" : "single";
      let sentSomething = false;

      if (mode === "single") {
        for (const item of items) {
          await tgSendItem(chatId, link, item);
          sentSomething = true;
        }
      } else {
        const key = makeBatchKey(chatId, userId, link.id);
        const existing = batchBuffers.get(key) || { items: [], skippedExtra: 0 };

        existing.items.push(...items);
        if (typeof skippedExtra === "number" && skippedExtra > 0) {
          existing.skippedExtra += skippedExtra;
        }

        if (existing.items.length < minBatchItems && existing.skippedExtra === 0) {
          batchBuffers.set(key, existing);
        } else {
          const text = buildBatchMessage(link, existing.items, existing.skippedExtra);
          await sendTelegram("sendMessage", {
            chat_id: chatId,
            text,
            parse_mode: "HTML",
            disable_web_page_preview: false,
            reply_markup: {
              inline_keyboard: [
                [{ text: "üîï Wy≈ÇƒÖcz ten link", callback_data: `lnmode:${link.id}:off` }],
                [
                  { text: "üì® Pojedynczo", callback_data: `lnmode:${link.id}:single` },
                  { text: "üì¶ Zbiorczo", callback_data: `lnmode:${link.id}:batch` },
                ],
              ],
            },
          });
          batchBuffers.delete(key);
          sentSomething = true;
        }
      }

      if (sentSomething) {
        const increment = mode === "single" ? items.length : 1;
        dailyCount += increment;

        await notifyPool.query(
          `
          UPDATE chat_notifications
          SET last_notified_at = NOW(),
              daily_count = $1,
              daily_count_date = $2
          WHERE chat_id = $3 AND user_id = $4
          `,
          [dailyCount, dailyDateStr, chatId, userId]
        );
      }
    }
  } catch (err) {
    console.error("B≈ÇƒÖd notifyChatsForLink:", err);
  }
}

// ---------- Scraping OLX ----------
async function scrapeOlx(url) {
  const launchOpts = { args: ["--no-sandbox", "--disable-dev-shm-usage"] };
  if (PROXY) launchOpts.proxy = PROXY;

  const browser = await chromium.launch(launchOpts);
  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });

  context.setDefaultTimeout(45000);
  context.setDefaultNavigationTimeout(45000);
  let page = await context.newPage();

try {
  await page.route("**/*", (route) => {
    const t = route.request().resourceType();
    if (t === "image" || t === "media" || t === "font") return route.abort();
    return route.continue();
  });
} catch {}
await __fydBlockHeavyAssets(page);
  const setupPage = async (p) => {
    await p.route(/.*/i, (route) => {
      const t = route.request().resourceType();
      if (t === "image" || t === "media" || t === "font") return route.abort();
      return route.continue();
    });
    p.setDefaultNavigationTimeout(60000);
    p.setDefaultTimeout(60000);
  };

  function deriveOlxTitleFromUrl(u) {
    try {
      const uu = new URL(u);
      const parts = uu.pathname.split("/").filter(Boolean);
      if (!parts.length) return null;
      let last = parts[parts.length - 1];
      last = last.replace(/\.[a-z0-9]+$/i, "");
      let slugParts = last.split("-");
      slugParts = slugParts.filter((p) => {
        const up = p.toUpperCase();
        if (up.startsWith("CID")) return false;
        if (up.startsWith("ID") && up.length > 2) return false;
        return true;
      });
      if (!slugParts.length) return null;
      const pretty = slugParts
        .join(" ")
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
      return pretty || null;
    } catch {
      return null;
    }
  }

  try {
    await setupPage(page);

    let lastErr = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        await page.goto(url, { waitUntil: "domcontentloaded", timeout: 60000 });
        await page.waitForSelector('div[data-cy="l-card"]', { timeout: 25000 });
        await page.waitForTimeout(800);
        lastErr = null;
        break;
      } catch (e) {
        lastErr = e;
        if (page.isClosed()) {
          page = await context.newPage();
          await setupPage(page);
        }
        await new Promise((r) => setTimeout(r, 1500 * attempt));
      }
    }
    if (lastErr) throw lastErr;

    const rawItems = await page.$$eval('div[data-cy="l-card"]', (cards) => {
      const results = [];
      for (const card of cards) {
        const linkEl = card.querySelector('a[href*="/oferta/"], a[href*="/d/oferta/"]');
        if (!linkEl) continue;

        const url = (() => {
          try {
            const u = new URL(linkEl.href);
            u.hash = "";
            u.search = "";
            u.pathname = u.pathname.replace(/^\/d\/oferta\//, "/oferta/");
            return u.toString();
          } catch {
            return (linkEl.href || "").split("#")[0].split("?")[0].replace("/d/oferta/", "/oferta/");
          }
        })();

        let title = "";
        const titleEl =
          card.querySelector('[data-cy="ad-card-title"]') ||
          card.querySelector('[data-testid="ad-title"]') ||
          linkEl.querySelector("h6") ||
          linkEl.querySelector("h3") ||
          card.querySelector("h6") ||
          card.querySelector("h3");
        if (titleEl) title = (titleEl.innerText || titleEl.textContent || "").trim();
        if (!title && linkEl.getAttribute("title")) title = linkEl.getAttribute("title").trim();
        if (!title) title = (linkEl.innerText || linkEl.textContent || "").trim();

        let priceText = "";
        const priceEl = card.querySelector('[data-testid="ad-price"]') || card.querySelector('[data-cy="ad-card-price"]');
        if (priceEl) priceText = (priceEl.innerText || priceEl.textContent || "").trim();

        const img = card.querySelector("img");
        let photoUrl = null;
        if (img) {
          photoUrl = img.src || img.getAttribute("src") || img.getAttribute("data-src") || (img.getAttribute("srcset") || "").split(" ")[0] || null;
        }

        const text = card.innerText || card.textContent || "";
        const hasOlxDelivery = /Przesy≈Çka OLX/i.test(text);

        results.push({ url, title, rawPrice: priceText, photoUrl, hasOlxDelivery });
      }
      return results;
    });

    const items = rawItems.map((it) => {
      let finalTitle = it.title || "";
      if (!finalTitle || /^wyr√≥≈ºnione$/i.test(finalTitle)) {
        const fromUrl = deriveOlxTitleFromUrl(it.url);
        if (fromUrl) finalTitle = fromUrl;
      }

      const { price, currency } = parsePrice(it.rawPrice);
      const u = normalizeOlxUrl(it.url);
      const itemKey = normalizeKey(u);

      return {
        url: u,
        title: finalTitle,
        price,
        currency,
        brand: null,
        size: null,
        condition: null,
        photoUrl: it.photoUrl,
        hasOlxDelivery: it.hasOlxDelivery,
        buyUrl: it.hasOlxDelivery ? it.url : null,
        itemKey,
        item_key: itemKey,
      };
    });

    return items;
  } finally {
    await page.close().catch(() => null);
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

// ---------- Scraping Vinted ----------
function pickArrayFromApi(data) {
  if (!data || typeof data !== "object") return [];
  if (Array.isArray(data.items)) return data.items;
  if (Array.isArray(data.catalog_items)) return data.catalog_items;
  if (Array.isArray(data?.data?.items)) return data.data.items;
  if (Array.isArray(data?.data?.catalog_items)) return data.data.catalog_items;
  return [];
}

function getVintedFallbackCurrency(linkUrl) {
  try {
    const u = new URL(linkUrl);
    const cur = u.searchParams.get("currency");
    if (cur) return cur.toUpperCase();
    const h = (u.hostname || "").toLowerCase();
    if (h.endsWith(".pl")) return "PLN";
    return "EUR";
  } catch {}
  return null;
}

function buildVintedApiUrl(catalogUrl) {
  const u = new URL(catalogUrl);
  const api = new URL("/api/v2/catalog/items", u.origin);

  const inP = u.searchParams;
  const outP = api.searchParams;

  outP.set("page", inP.get("page") || "1");
  outP.set("per_page", "96");

  const scalarKeys = ["search_text", "currency", "price_from", "price_to", "order", "search_by_image_uuid"];
  for (const k of scalarKeys) {
    const v = inP.get(k);
    if (v != null && v !== "") outP.set(k, v);
  }
  if (!outP.get("order")) outP.set("order", "newest_first");

  for (const [k, v] of inP.entries()) {
    if (k === "time") continue;
    if (k === "catalog[]") outP.append("catalog_ids[]", v);
    else if (k === "catalog_ids[]") outP.append("catalog_ids[]", v);
    else if (k === "size_ids[]") outP.append("size_ids[]", v);
    else if (k === "brand_ids[]") outP.append("brand_ids[]", v);
    else if (k === "status_ids[]") outP.append("status_ids[]", v);
    else if (k === "color_ids[]") outP.append("color_ids[]", v);
    else if (k === "material_ids[]") outP.append("material_ids[]", v);
  }

  return api.toString();
}

function getVintedItemIdFromUrl(urlOrKey) {
  try {
    const u = new URL(urlOrKey);
    const m = u.pathname.match(/^\/items\/(\d+)(?:-|\/|$)/i);
    if (!m) return null;
    const n = Number(m[1]);
    return Number.isFinite(n) ? n : null;
  } catch {
    const s = String(urlOrKey || "").trim();
    if (/^\d+$/.test(s)) return Number(s);
    return null;
  }
}

function parseVintedMeta(titleAttr, fallbackTitle) {
  if (!titleAttr) {
    return { title: fallbackTitle || "", brand: null, size: null, condition: null, rawPriceFromTitle: null };
  }

  const segments = titleAttr.split(/\s*,\s*/);
  let title = segments[0] || fallbackTitle || "";

  let brand = null;
  let size = null;
  let condition = null;
  let rawPriceFromTitle = null;

  for (let i = 1; i < segments.length; i++) {
    const seg = segments[i] || "";
    const lower = seg.toLowerCase();
    let m;

    m = seg.match(/^marka:\s*(.+)$/i);
    if (m) { brand = m[1].trim(); continue; }

    m = seg.match(/^(stan|condition):\s*(.+)$/i);
    if (m) { condition = m[2].trim(); continue; }

    m = seg.match(/^rozmiar:\s*(.+)$/i);
    if (m) { size = m[1].trim(); continue; }

    if (/\d/.test(seg) && !/zawiera/i.test(lower)) rawPriceFromTitle = seg.trim();
  }

  return { title, brand, size, condition, rawPriceFromTitle };
}

/* __FYD_VINTED_PW_FORCE2_HELPER_V2__
   Playwright fallback dla Vinted katalogu:
   - bierze URL + titleAttr + text + photoUrl
   - mapuje do normalnych item√≥w (title/price/currency/photo) jak DOM fallback
*/
async function __fydVintedCatalogViaPlaywright(catalogUrl) {
  const url = String(catalogUrl || "").trim();
  if (!url) return [];

  let origin = "";
  try { origin = new URL(url).origin; } catch {}

  const fallbackCurrency = getVintedFallbackCurrency(url);

  const browser = await chromium.launch({ headless: true, args: ["--no-sandbox", "--disable-dev-shm-usage"] });
  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });
  context.setDefaultTimeout(45000);
  context.setDefaultNavigationTimeout(45000);
  const page = await context.newPage();

// __FYD_BLOCK_ASSETS_V1
try {
  await page.route("**/*", (route) => {
    const req = route.request();
    const t = req.resourceType();
    if (t === "image" || t === "media" || t === "font") return route.abort();
    return route.continue();
  });
} catch {}
try {
  await page.route("**/*", (route) => {
    const t = route.request().resourceType();
    if (t === "image" || t === "media" || t === "font") return route.abort();
    return route.continue();
  });
} catch {}
await __fydBlockHeavyAssets(page);
  try {
    await page.route(/.*/i, (route) => {
      const t = route.request().resourceType();
      if (t === "media" || t === "font") return route.abort();
      // obrazki zostawiamy "jak jest" (czƒôsto atrybuty sƒÖ i bez pobrania, ale nie blokujemy na si≈Çƒô)
      return route.continue();
    });

    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 });
    await page.waitForTimeout(2200);

    await page.waitForSelector('main a[href^="/items/"]', { timeout: 12000 }).catch(() => null);

    const raw = await page.$$eval('main a[href^="/items/"]', (anchors) => {
      const seen = new Set();
      const results = [];

      function extractPhotoUrl(rootEl) {
        let el = rootEl;
        for (let depth = 0; depth < 6 && el; depth++) {
          const img = el.querySelector("img");
          if (img) {
            const srcset = img.getAttribute("srcset") || "";
            const primaryFromSrcset = srcset.split(" ")[0] || null;
            return (
              img.src ||
              img.getAttribute("src") ||
              img.getAttribute("data-src") ||
              primaryFromSrcset
            );
          }
          el = el.parentElement;
        }
        return null;
      }

      for (const a of anchors) {
        const href = a.href;
        if (!href || !href.includes("/items/")) continue;
        if (seen.has(href)) continue;
        seen.add(href);

        const titleAttr = a.getAttribute("title") || "";
        const text = a.textContent ? a.textContent.trim() : "";
        const photoUrl = extractPhotoUrl(a);

        results.push({ url: href, titleAttr, text, photoUrl });
      }
      return results;
    }).catch(() => []);

    const mappedItems = (raw || [])
      .map((it) => {
        const meta = parseVintedMeta(it.titleAttr, it.text);
        const rawPrice = meta.rawPriceFromTitle || "";
        const { price, currency } = parsePrice(rawPrice);

        const itemKey = normalizeKey(it.url);
        const vintedId = getVintedItemIdFromUrl(itemKey);

        return {
          url: it.url,
          title: meta.title || it.text || "",
          price,
          currency: currency || fallbackCurrency,
          brand: meta.brand,
          size: meta.size,
          condition: meta.condition,
          photoUrl: it.photoUrl ? String(it.photoUrl) : null,
          itemKey,
          item_key: itemKey,
          vintedId,
        };
      })
      .filter(Boolean);

    return __fydFixVintedItems(mappedItems);
  } finally {
    await page.close().catch(() => null);
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

async function scrapeVinted(url) {
  let origin = "";
  try { origin = new URL(url).origin; } catch {}

  const fallbackCurrency = getVintedFallbackCurrency(url);

  // 1) API (pw request)
  try {
    const apiUrl = buildVintedApiUrl(url);

    const api = await request.newContext({
      proxy: PROXY || undefined,
      baseURL: origin || undefined,
      extraHTTPHeaders: {
        "user-agent":
          "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "accept-language": "pl-PL,pl;q=0.9,en;q=0.8",
      },
    });

    try {
      if (origin) {
        await api.get("/", {
          headers: { accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" },
        });
      }

      const res = await api.get(apiUrl, {
        headers: {
          accept: "application/json, text/plain, */*",
          "x-requested-with": "XMLHttpRequest",
          referer: url,
        },
      });

      const txt = await res.text().catch(() => "");
      if (!res.ok()) throw new Error(`HTTP_${res.status()}`);

      let apiData = null;
      try { apiData = JSON.parse(txt); } catch { throw new Error("JSON_PARSE"); }

      const arr = pickArrayFromApi(apiData);
      if (arr && arr.length) {
        const mapped = arr
          .map((it) => {
            const id =
              typeof it?.id === "number"
                ? it.id
                : Number.isFinite(Number(it?.id))
                ? Number(it.id)
                : null;

            const urlAbs =
              it?.url && typeof it.url === "string"
                ? it.url.startsWith("http")
                  ? it.url
                  : origin
                  ? new URL(it.url, origin).toString()
                  : it.url
                : id && origin
                ? `${origin}/items/${id}`
                : null;

            if (!urlAbs) return null;

            const title = it?.title || it?.name || it?.description || it?.brand_title || "";

            const priceAmount = it?.price?.amount ?? it?.price?.value ?? it?.price ?? it?.total_item_price?.amount ?? null;
            const price =
              priceAmount != null && String(priceAmount).trim() !== ""
                ? Number(String(priceAmount).replace(",", "."))
                : null;

            const currency = it?.price?.currency_code || it?.currency || fallbackCurrency || null;

            const photoUrl =
              it?.photo?.url ||
              it?.photo?.full_size_url ||
              it?.photo?.high_resolution?.url ||
              (Array.isArray(it?.photos) && it.photos[0]?.url) ||
              null;

            const brand = it?.brand_title || it?.brand || it?.brand_name || null;
            const size = it?.size_title || it?.size || it?.size_name || null;
            const condition = it?.status_title || it?.status || it?.item_condition || null;

            const itemKey = normalizeKey(urlAbs);
            const vintedId = getVintedItemIdFromUrl(itemKey) || id || null;

            return {
              url: urlAbs,
              title: String(title || "").trim(),
              price: Number.isFinite(price) ? price : null,
              currency: currency ? String(currency).toUpperCase() : null,
              brand: brand ? String(brand).trim() : null,
              size: size ? String(size).trim() : null,
              condition: condition ? String(condition).trim() : null,
              photoUrl: photoUrl ? String(photoUrl) : null,
              itemKey,
              item_key: itemKey,
              vintedId: typeof vintedId === "number" ? vintedId : null,
            };
          })
          .filter(Boolean);

        return __fydFixVintedItems(mapped);
      }
    } finally {
      await api.dispose().catch(() => null);
    }
  } catch (e) {
    logDebug("Vinted API failed -> fallback DOM:", e?.message || e);
    // fallback playwright catalog (rich DOM)
    try {
      const items = await __fydVintedCatalogViaPlaywright(url);
      console.log(`[vinted-pw] fallback items=${items.length} url=${url}`);
      return items;
    } catch (e2) {
      console.log("[vinted-pw] fallback FAIL:", (e2 && e2.message) ? e2.message : e2);
    }
  }

  // 2) DOM fallback (klasyczny)
  const launchOpts = { args: ["--no-sandbox", "--disable-dev-shm-usage"] };
  if (PROXY) launchOpts.proxy = PROXY;

  const browser = await chromium.launch(launchOpts);
  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });

  context.setDefaultTimeout(45000);
  context.setDefaultNavigationTimeout(45000);
  const page = await context.newPage();

try {
  await page.route("**/*", (route) => {
    const t = route.request().resourceType();
    if (t === "image" || t === "media" || t === "font") return route.abort();
    return route.continue();
  });
} catch {}
await __fydBlockHeavyAssets(page);
  try {
    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 });
    await page.waitForTimeout(2000);

    await page.waitForSelector('main a[href^="/items/"]', { timeout: 12000 }).catch(() => null);

    const rawItems = await page
      .$$eval('main a[href^="/items/"]', (anchors) => {
        const seen = new Set();
        const results = [];

        function extractPhotoUrl(rootEl) {
          let el = rootEl;
          for (let depth = 0; depth < 6 && el; depth++) {
            const img = el.querySelector("img");
            if (img) {
              const srcset = img.getAttribute("srcset") || "";
              const primaryFromSrcset = srcset.split(" ")[0] || null;
              return (
                img.src ||
                img.getAttribute("src") ||
                img.getAttribute("data-src") ||
                primaryFromSrcset
              );
            }
            el = el.parentElement;
          }
          return null;
        }

        for (const a of anchors) {
          const href = a.href;
          if (!href || !href.includes("/items/")) continue;
          if (seen.has(href)) continue;
          seen.add(href);

          const titleAttr = a.getAttribute("title") || "";
          const text = a.textContent ? a.textContent.trim() : "";
          const photoUrl = extractPhotoUrl(a);

          results.push({ url: href, titleAttr, text, rawPrice: "", photoUrl });
        }

        return results;
      })
      .catch(() => []);

    const mappedItems = (rawItems || [])
      .map((it) => {
        const meta = parseVintedMeta(it.titleAttr, it.text);
        const rawPrice = meta.rawPriceFromTitle || it.rawPrice;
        const { price, currency } = parsePrice(rawPrice);
        const itemKey = normalizeKey(it.url);
        const vintedId = getVintedItemIdFromUrl(itemKey);

        return {
          url: it.url,
          title: meta.title || it.text || "",
          price,
          currency: currency || fallbackCurrency,
          brand: meta.brand,
          size: meta.size,
          condition: meta.condition,
          photoUrl: it.photoUrl,
          itemKey,
          item_key: itemKey,
          vintedId,
        };
      })
      .filter(Boolean);

    return __fydFixVintedItems(mappedItems);
  } finally {
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

// ---------- Filtrowanie ----------
function matchFilters(item, filters = {}) {
  if (!filters || Object.keys(filters).length === 0) return true;

  const price = typeof item.price === "number" ? item.price : null;

  if (filters.minPrice != null && price != null && price < filters.minPrice) return false;
  if (filters.maxPrice != null && price != null && price > filters.maxPrice) return false;

  if (Array.isArray(filters.brand) && filters.brand.length) {
    const brandLower = (item.brand || "").toLowerCase();
    const ok = filters.brand.some((b) => brandLower.includes(String(b).toLowerCase()));
    if (!ok) return false;
  }

  if (Array.isArray(filters.sizes) && filters.sizes.length) {
    const sizeLower = (item.size || "").toLowerCase();
    const ok = filters.sizes.some((s) => sizeLower === String(s).toLowerCase());
    if (!ok) return false;
  }

  if (Array.isArray(filters.conditions) && filters.conditions.length) {
    const condLower = (item.condition || "").toLowerCase();
    const ok = filters.conditions.some((c) => condLower.includes(String(c).toLowerCase()));
    if (!ok) return false;
  }

  return true;
}

function safeParseFilters(raw) {
  if (!raw) return {};
  if (typeof raw === "object") return raw;
  if (typeof raw === "string") {
    try { return JSON.parse(raw); } catch { return {}; }
  }
  return {};
}

function sortItemsForNotify(source, items) {
  const src = (source || "").toLowerCase();
  if (src === "vinted") {
    return [...(items || [])].sort((a, b) => {
      const ai = typeof a.vintedId === "number" ? a.vintedId : -1;
      const bi = typeof b.vintedId === "number" ? b.vintedId : -1;
      return bi - ai;
    });
  }
  return items || [];
}

async function processLink(link) {
  const source = (link.source || detectSource(link.url) || "").toLowerCase();
  if (!source) return;

  const tgUserId = link.telegram_user_id || null;
  const limits = tgUserId ? await getUserLimits(tgUserId) : null;

  if (limits?.sources_allowed && Array.isArray(limits.sources_allowed) && !limits.sources_allowed.includes(source)) {
    console.log(`[link ${link.id}] SOURCE_NOT_ALLOWED_BY_PLAN source=${source}`);
    return;
  }

  console.log(`Worker: checking ${link.url}`);

  let scraped = [];
  if (source === "olx") scraped = await scrapeOlx(link.url);
  else if (source === "vinted") scraped = await scrapeVinted(link.url);
  else return;

  // twarde ujednolicenie Vinted item√≥w ju≈º na wej≈õciu
  if (source === "vinted") scraped = __fydFixVintedItems(scraped);

  const lastKey = cleanKey(
    source === "olx"
      ? normalizeOlxUrl(String(link.last_key ?? ""))
      : String(link.last_key ?? "")
  );

  const cfg = getSourceConfig(source);
  const maxPerLoop = Number(limits?.max_items_per_link_per_loop || cfg.maxPerLoop);
  const minBatchItems = cfg.minBatchItems;

  const filters = safeParseFilters(link.filters);
  const filtered = (scraped || []).filter((it) => matchFilters(it, filters));
  if (!filtered.length) return;

  const orderedAll = source === "vinted" ? sortItemsForNotify(source, filtered) : filtered;

  // baseline: nowy link -> ustaw last_key i nie wysy≈Çaj
  if (!lastKey) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey) await updateLastKey(link.id, newestKey);
    return;
  }

  const { fresh: freshByLastKey, found } = takeNewItemsUntilLastKey(orderedAll, lastKey);

  if (!found) {
    const newestKey = getItemKey(orderedAll[0]);

    const keysToCheck = orderedAll.map(getItemKey).filter(Boolean);
    const seenSet = await getSeenItemKeys(link.id, keysToCheck);

    let freshNotSeen = orderedAll.filter((it) => {
      const k = getItemKey(it);
      return k && !seenSet.has(k);
    });

    if (!freshNotSeen.length) {
      if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
      return;
    }

    if (source === "vinted") freshNotSeen = __fydFixVintedItems(freshNotSeen);

    await insertLinkItems(link.id, freshNotSeen);

    const toSend = freshNotSeen.slice(0, maxPerLoop);
    const skipped = freshNotSeen.length - toSend.length;

    await notifyChatsForLink(link, toSend, skipped, { minBatchItems });

    if (newestKey) await updateLastKey(link.id, newestKey);

    const keep = Number(limits?.history_keep_per_link || HISTORY_KEEP_PER_LINK);
    if (Number.isFinite(keep) && keep > 0) await pruneLinkItems(link.id, keep);
    return;
  }

  if (!freshByLastKey.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
    return;
  }

  const keysToCheck = freshByLastKey.map(getItemKey).filter(Boolean);
  const seenSet = await getSeenItemKeys(link.id, keysToCheck);

  let freshNotSeen = freshByLastKey.filter((it) => {
    const k = getItemKey(it);
    return k && !seenSet.has(k);
  });

  if (!freshNotSeen.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
    return;
  }

  if (source === "vinted") freshNotSeen = __fydFixVintedItems(freshNotSeen);

  await insertLinkItems(link.id, freshNotSeen);

  const toSend = freshNotSeen.slice(0, maxPerLoop);
  const skipped = freshNotSeen.length - toSend.length;

  if (toSend.length) await notifyChatsForLink(link, toSend, skipped, { minBatchItems });

  const newestKey = getItemKey(orderedAll[0]);
  if (newestKey) await updateLastKey(link.id, newestKey);

  const keep = Number(limits?.history_keep_per_link || HISTORY_KEEP_PER_LINK);
  if (Number.isFinite(keep) && keep > 0) await pruneLinkItems(link.id, keep);
}

async function loopOnce() {
  await initDb();
  const links = await getLinksForWorker();
  console.log(`Worker: found links: ${links.length}`);

  // grupujemy per telegram_user_id (≈ºeby cap by≈Ç per user)
  const byUser = new Map(); // tgId(str) -> links[]
  for (const link of links) {
    const tgId = link.telegram_user_id ? String(link.telegram_user_id) : "__no_tg__";
    if (!byUser.has(tgId)) byUser.set(tgId, []);
    byUser.get(tgId).push(link);
  }

  for (const [tgId, userLinks] of byUser.entries()) {
    const sorted = [...userLinks].sort((a, b) => Number(a.id) - Number(b.id));

    let toProcess = sorted;

    if (tgId !== "__no_tg__") {
      const lim = await getUserLimits(tgId);
      const cap = Number(lim?.links_limit_total ?? lim?.links_limit ?? 0);
      if (cap > 0) toProcess = sorted.slice(0, cap);
      if (cap > 0 && sorted.length > cap) {
        console.log(`[user ${tgId}] cap=${cap} active_links=${sorted.length} -> processing=${toProcess.length}`);
      }
    }

    for (const link of toProcess) {
      try {
        await processLink(link);
      } catch (err) {
        console.error(`Worker: error for link ${link.id}`, err);
      }
    }
  }
}

async function main() {
  console.log("Worker start");
  console.log(`[config] LOOP_DELAY_MS=${LOOP_DELAY_MS}ms SLEEP_BETWEEN_ITEMS_MS=${SLEEP_BETWEEN_ITEMS_MS}ms MAX_ITEMS_PER_LINK_PER_LOOP=${MAX_ITEMS_PER_LINK_PER_LOOP}`);

  while (true) {
    try {
      await loopOnce();
    } catch (err) {
      console.error("Worker: loopOnce error", err);
    }
    await sleep(LOOP_DELAY_MS);
  }
}

main().catch((err) => {
  console.error("Worker fatal error", err);
  process.exit(1);
});
