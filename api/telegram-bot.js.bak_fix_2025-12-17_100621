import dotenv from "dotenv";
import crypto from "crypto";


/* FYD_PANEL_LOGIN_HELPERS */
async function resolveUserIdFromChat(chatId) {
  const { rows } = await pool.query(
    `SELECT user_id
     FROM chat_notifications
     WHERE chat_id = $1
     ORDER BY updated_at DESC
     LIMIT 1`,
    [String(chatId)]
  );
  return rows[0]?.user_id ?? null;
}

async function createPanelLoginToken(userId, minutes = 10) {
  const token = crypto.randomBytes(24).toString("base64url");
  const mins = Number(minutes);
  await pool.query(
    `INSERT INTO panel_login_tokens (token, user_id, expires_at)
     VALUES ($1, $2, now() + ($3::text || ' minutes')::interval)`,
    [token, userId, Number.isFinite(mins) ? mins : 10]
  );
  return token;
}
dotenv.config();

import fetch from "node-fetch";
import pg from "pg";

import {
  initDb,
  ensureUser,
  getUserWithPlanByTelegramId,
  getUserById,
  getLinksByUserId,
  countActiveLinksForUserId,
  countEnabledLinksForUserId,
  insertLinkForUserId,
  deactivateLinkForUserId,
  setQuietHours,
  disableQuietHours,
  getQuietHours,
  setUserTelegramChatId,
} from "./db.js";
import { clearLinkNotificationMode } from "./db.js";

import {
  getEffectiveLinkLimit,
  formatPlanStatus,
  isPlanActive,
  buildLimitReachedMessage,
  getPerLinkItemLimit,
} from "./plans.js";

import { getLang, t } from "./i18n/index.js";

const { Pool } = pg;

const TG = process.env.TELEGRAM_BOT_TOKEN || "";
const DATABASE_URL = process.env.DATABASE_URL || "";

if (!TG) {
  console.error("Brak TELEGRAM_BOT_TOKEN w env, wychodzƒô.");
  process.exit(1);
}

if (!DATABASE_URL) {
  console.error("Brak DATABASE_URL w env ‚Äì bot mo≈ºe mieƒá problem z DB.");
}

const pool = new Pool({
  connectionString: DATABASE_URL,
});

// limit dzienny powiadomie≈Ñ na jeden chat ‚Äì informacyjnie do /status
const MAX_DAILY_NOTIFICATIONS = 200;

// ---------- helpery og√≥lne ----------

async function dbQuery(sql, params = []) {
  const client = await pool.connect();
  try {
    return await client.query(sql, params);
  } finally {
    client.release();
  }
}

// Minimalne escape HTML dla Telegrama (parse_mode=HTML)
function escapeHtml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

async function tgApi(method, payload) {
  const url = `https://api.telegram.org/bot${TG}/${method}`;
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  return res.json().catch(() => ({}));
}

async function tgSend(chatId, text, extra = {}) {
  const MAX_LEN = 3500; // bezpieczny margines dla Telegrama (limit ~4096)
  const full = String(text ?? "");

  const parts = [];
  if (full.length <= MAX_LEN) {
    parts.push(full);
  } else {
    let rest = full;
    while (rest.length > 0) {
      let cut = rest.lastIndexOf("\n", MAX_LEN);
      if (cut < 1000) cut = MAX_LEN; // jak nie ma sensownego \n, tnij twardo
      parts.push(rest.slice(0, cut));
      rest = rest.slice(cut);
    }
  }

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const extraForThis = i === 0 ? extra : {}; // nie duplikuj klawiatur/markup√≥w
    try {
      const res = await tgApi("sendMessage", {
        chat_id: chatId,
        text: part,
        parse_mode: "HTML",
        disable_web_page_preview: true,
        ...extraForThis,
      });

      if (!res || res.ok !== true) {
        console.error("Telegram send failed:", res?.description || res);
        console.error("chatId=", chatId, "textLen=", String(part).length);
      } else {
        console.log("Telegram sent:", res.result?.message_id, "chatId=", chatId, "len=", String(part).length);
      }
    } catch (err) {
      console.error("Telegram send error:", err.message || err);
    }
  }
}

async function tgAnswerCb(callbackQueryId, text, showAlert = false) {
  try {
    await tgApi("answerCallbackQuery", {
      callback_query_id: callbackQueryId,
      text,
      show_alert: !!showAlert,
    });
  } catch (e) {
    // ignore
  }
}

// ---------- mapowanie Telegram ID -> user_id (aliasy) ----------

async function resolveUserIdFromTg(tgId) {
  const tid = String(tgId);

  // standard: pobieramy user po telegram_id
  const user = await getUserWithPlanByTelegramId(tid);
  return user?.id || null;
}

// je≈õli nie ma chat_notifications ‚Äì tworzymy domy≈õlnie W≈ÅƒÑCZONE + single
async function ensureChatNotificationsRow(chatId, userId) {
  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, daily_count, daily_count_date, created_at, updated_at)
    VALUES ($1, $2, TRUE, 'single', 0, CURRENT_DATE, NOW(), NOW())
    ON CONFLICT (chat_id, user_id) DO NOTHING
    `,
    [String(chatId), Number(userId)]
  );
}

// ---------- long polling z getUpdates ----------

let offset = 0;

async function fetchUpdates() {
  const url = new URL(`https://api.telegram.org/bot${TG}/getUpdates`);
  url.searchParams.set("timeout", "30");
  if (offset) url.searchParams.set("offset", String(offset));

  const res = await fetch(url.href);
  if (!res.ok) throw new Error(`getUpdates HTTP ${res.status}`);

  const data = await res.json();
  if (!data.ok) throw new Error(`getUpdates Telegram error: ${data.description}`);

  return data.result;
}

// ---------- pomocnik do budowy STATUS ----------

async function buildStatusMessage(chatId, user) {
  const userId = user.id;

  let text = "‚ÑπÔ∏è Status bota\n\n";
let chatDefaultMode = "pojedynczo"; // fallback

  // 1) Plan
  let planPart = "";
  try {
    planPart = formatPlanStatus(user);
  } catch (e) {
    console.error("buildStatusMessage: formatPlanStatus error", e);
    planPart = "Plan: (b≈ÇƒÖd odczytu)\nLimit wyszukiwa≈Ñ: ?\n≈ÅƒÖcznie wyszukiwa≈Ñ: ?";
  }
  text += planPart.trim() + "\n\n";
  // 1b) Liczniki link√≥w (limit = ≈ÇƒÖcznie, osobno: w≈ÇƒÖczone)
  try {
    const totalLinks = await countActiveLinksForUserId(userId); // ≈ÇƒÖcznie (limit)
    const enabledLinks = await countEnabledLinksForUserId(userId); // active=TRUE
    const limitTotal = getEffectiveLinkLimit(user);

    text +=
      `Aktywne wyszukiwania (w≈ÇƒÖczone): ${enabledLinks}/${limitTotal}\n` +
      `≈ÅƒÖcznie wyszukiwa≈Ñ (w bazie): ${totalLinks}/${limitTotal}\n\n`;
  } catch (e) {
    console.error("buildStatusMessage: link counters error", e);
  }



  // 2) Ustawienia powiadomie≈Ñ dla TEGO czatu
  const todayStr = new Date().toISOString().slice(0, 10);
  try {
    const res = await dbQuery(
      `
      SELECT enabled, mode, daily_count, daily_count_date
      FROM chat_notifications
      WHERE chat_id = $1 AND user_id = $2
      `,
      [String(chatId), userId]
    );

    if (!res.rowCount) {
      text +=
        "Ten czat: brak konfiguracji.\n" +
        "Domy≈õlnie: powiadomienia W≈ÅƒÑCZONE, tryb: pojedynczo, 0/200 dzisiaj.\n" +
        "Skonfigurujesz to komendami /on /off /pojedyncze /zbiorcze.\n\n";
    } else {
      const row = res.rows[0];
      const enabled = row.enabled !== false;
const mode =
  (row.mode || "single").toLowerCase() === "batch" ? "zbiorczo" : "pojedynczo";
chatDefaultMode = mode;

      let daily = row.daily_count || 0;
      let dateStr = null;
      if (row.daily_count_date) {
        dateStr = row.daily_count_date.toISOString
          ? row.daily_count_date.toISOString().slice(0, 10)
          : String(row.daily_count_date).slice(0, 10);
      }
      if (dateStr !== todayStr) daily = 0;

      text +=
        `${enabled ? "‚úÖ Powiadomienia W≈ÅƒÑCZONE" : "‚õî Powiadomienia WY≈ÅƒÑCZONE"}\n` +
        `Tryb domy≈õlny na tym czacie: ${mode}\n` +
        `Dzisiejsze powiadomienia: ${daily}/${MAX_DAILY_NOTIFICATIONS}\n` +
        "Zmiana: /on /off /pojedyncze /zbiorcze\n\n";
    }
  } catch (e) {
    console.error("buildStatusMessage: chat_notifications error", e);
    text += "Ustawienia powiadomie≈Ñ: (b≈ÇƒÖd odczytu)\n\n";
  }

  // 2b) Cisza nocna
  try {
    const qh = await getQuietHours(String(chatId));
    if (qh && qh.quiet_enabled) {
      text += `Cisza nocna: W≈ÅƒÑCZONA, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00\n\n`;
    } else {
      text += "Cisza nocna: wy≈ÇƒÖczona\n\n";
    }
  } catch (e) {
    console.error("buildStatusMessage: quiet_hours error", e);
    text += "Cisza nocna: (b≈ÇƒÖd odczytu)\n\n";
  }

  // 3) Lista link√≥w ≈ÇƒÖcznie usera + tryb per-link w tym czacie
  try {
    const resLinks = await dbQuery(
      `
      SELECT
        l.id,
        l.name,
        l.url,
        l.source,
        l.active,
        lnm.mode AS link_mode
      FROM links l
      LEFT JOIN link_notification_modes lnm
        ON lnm.user_id = l.user_id
       AND lnm.chat_id = $2
       AND lnm.link_id = l.id
      WHERE l.user_id = $1
        
      AND l.active = TRUE
      ORDER BY l.id ASC
      LIMIT 25
      `,
      [userId, String(chatId)]
    );

    if (!resLinks.rowCount) {
      text += "W≈ÇƒÖczone wyszukiwania: brak.\n";
    } else {
      text += "W≈ÇƒÖczone wyszukiwania:\n";
      for (const row of resLinks.rows) {
        const src = (row.source || "").toUpperCase() || "LINK";
        const name = row.name || row.url;
const lm = row.link_mode == null ? null : String(row.link_mode).toLowerCase();
const mode =
  lm === null ? chatDefaultMode
  : lm === "batch" ? "zbiorczo"
  : lm === "off" ? "OFF"
  : "pojedynczo";

        const state = row.active ? "‚úÖ" : "‚õî";
        text += `‚Ä¢ ${state} ${row.id} ‚Äì ${escapeHtml(name)} (${src}) ‚Äì tryb na tym czacie: ${mode}
`;
      }

      text +=
        "\nTryb per link zmienisz: /pojedyncze_ID /zbiorcze_ID /off_ID (np. /zbiorcze_18)";
    }
  } catch (e) {
    console.error("buildStatusMessage: links error", e);
    text += "W≈ÇƒÖczone wyszukiwania: (b≈ÇƒÖd odczytu)\n";
  }

  return text.trim();
}

// ---------- /help /start ----------

async function handleHelp(msg, user) {
  const chatId = msg.chat.id;
  const lang = getLang(user);
  const text = t(lang, "help.text");
  await tgSend(chatId, text);
}

// ---------- /lista ----------

async function handleLista(msg, user) {
  const chatId = msg.chat.id;

  try {
    const links = await getLinksByUserId(user.id, true);

    if (!links.length) {
      await tgSend(chatId, t(getLang(user), "list.empty"));
      return;
    }

    let text = "üìã Aktywne monitorowane linki:\n\n";
    for (const row of links) {
      text += `ID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}\n`;
      text += `<code>${escapeHtml(row.url)}</code>\n\n`;
    }
    text += "Wy≈ÇƒÖcz: <code>/usun ID</code>\nnp. <code>/usun 18</code>";

    await tgSend(chatId, text);
  } catch (err) {
    console.error("handleLista error:", err);
    await tgSend(chatId, t(getLang(user), "list.error"));
  }
}

// ---------- /usun ----------

async function handleUsun(msg, user, argText) {
  const chatId = msg.chat.id;
  const lang = getLang(user);

  const id = Number(String(argText || "").trim());
  if (!Number.isFinite(id) || id <= 0) {
    await tgSend(chatId, t(lang, "delete.usage"));
    return;
  }

  try {
    // pr√≥bujemy wy≈ÇƒÖczyƒá (zwykle UPDATE ... WHERE active=true)
    const row = await deactivateLinkForUserId(user.id, id);

    if (!row) {
      // sprawd≈∫ czy link istnieje, ale ju≈º jest WY≈Å.
      const chk = await dbQuery(
        "SELECT id, active FROM links WHERE id = $1 AND user_id = $2 LIMIT 1",
        [Number(id), Number(user.id)]
      );

      if (chk.rowCount && chk.rows[0] && chk.rows[0].active === false) {
        await tgSend(chatId, t(lang, "delete.alreadyOff", { id: String(id) }));
        return;
      }

      await tgSend(chatId, t(lang, "delete.notFoundHint", { id: String(id) }));
      return;
    }

    const name = escapeHtml(row.name || "(bez nazwy)");
    const url = escapeHtml(row.url || "");

    await tgSend(chatId, t(lang, "delete.okDetailed", { id: String(id), name, url }));
  } catch (err) {
    console.error("handleUsun error:", err);
    await tgSend(chatId, t(lang, "delete.error"));
  }
}

// ---------- /dodaj ----------

async function handleDodaj(msg, user, argText) {
  const chatId = msg.chat.id;
  const lang = getLang(user);

  if (!argText) {
    await tgSend(chatId, t(lang, "add.usage"));
    return;
  }

  const parts = String(argText).trim().split(/\s+/);
  const url = parts[0];
  const name = parts.slice(1).join(" ").trim() || null;

  if (!url || !/^https?:\/\//i.test(url)) {
    await tgSend(chatId, t(lang, "add.invalidUrl"));
    return;
  }

  const activePlan = isPlanActive(user, new Date());
  if (!activePlan) {
    const pn = String(user.plan_name || "").toLowerCase();

    if (pn === "trial" && user.trial_used) {
      await tgSend(chatId, t(lang, "add.trialExpired"));
      return;
    }

    if (pn === "starter" || pn === "growth" || pn === "platinum") {
      await tgSend(chatId, t(lang, "add.paidPlanExpired"));
      return;
    }

    await tgSend(
      chatId,
      t(lang, user.trial_used ? "add.noActivePlanTrialUsed" : "add.noActivePlanTrialAvailable")
    );
    return;
  }

  const activeLinks = await countActiveLinksForUserId(user.id);
  const limit = getEffectiveLinkLimit(user);

  if (activeLinks >= limit) {
    const msgText = buildLimitReachedMessage(user, activeLinks, limit);
    await tgSend(chatId, escapeHtml(msgText));
    return;
  }

  try {
    // duplikat URL u usera?
    const dupe = await dbQuery(
      `SELECT id, active FROM links WHERE user_id = $1 AND url = $2 ORDER BY id DESC LIMIT 1`,
      [Number(user.id), String(url)]
    );
    const ex = dupe.rows?.[0] || null;

    if (ex) {
      if (ex.active) {
        await tgSend(chatId, t(lang, "add.duplicateActive", { id: String(ex.id) }));
        return;
      }

      const targetChatId = String(user.telegram_chat_id || msg.chat.id);

      await dbQuery(
        `
        UPDATE links
        SET active = TRUE,
            name = COALESCE($3, name),
            chat_id = COALESCE($4, chat_id)
        WHERE id = $1 AND user_id = $2
        `,
        [Number(ex.id), Number(user.id), name ? String(name) : null, targetChatId]
      );

      await tgSend(chatId, t(lang, "add.reenabled", { id: String(ex.id) }));
      return;
    }

    const targetChatId = String(user.telegram_chat_id || msg.chat.id);

    const row = await insertLinkForUserId(user.id, name, url, targetChatId, null);

    await tgSend(
      chatId,
      t(lang, "add.ok", {
        id: String(row.id),
        name: escapeHtml(row.name || "(bez nazwy)"),
        url: escapeHtml(row.url || url),
        activeCount: String(activeLinks + 1),
        limit: String(limit),
      })
    );
  } catch (err) {
    console.error("handleDodaj error:", err);
    await tgSend(chatId, t(lang, "add.error"));
  }
}

  // plan aktywny?
  const activePlan = isPlanActive(user, new Date());
  if (!activePlan) {
    // Trial wygas≈Ç
    if (String(user.plan_name || "").toLowerCase() === "trial" && user.trial_used) {
      await tgSend(
        chatId,
        [
          "‚è∞ Tw√≥j plan Trial wygas≈Ç.",
          "Monitoring w Trial jest ju≈º niedostƒôpny.",
          "",
          "Aby dalej korzystaƒá z bota, wybierz plan p≈Çatny (Starter / Growth / Platinum).",
        ].join("\n")
      );
      return;
    }

    // plan p≈Çatny wygas≈Ç
    const pn = String(user.plan_name || "").toLowerCase();
    if (pn === "starter" || pn === "growth" || pn === "platinum") {
      await tgSend(
        chatId,
        [
          "‚è∞ Tw√≥j plan wygas≈Ç.",
          "Aby dodaƒá nowe linki i wznowiƒá monitoring, przed≈Çu≈º plan w panelu klienta.",
        ].join("\n")
      );
      return;
    }

    await tgSend(
      chatId,
      [
        "Nie masz aktywnego planu z monitoringiem link√≥w.",
        user.trial_used
          ? "Trial zosta≈Ç ju≈º wykorzystany. Wykup plan Starter / Growth / Platinum."
          : "Mo≈ºesz uruchomiƒá jednorazowo Trial (3 dni / 5 link√≥w) albo wybraƒá plan Starter / Growth / Platinum.",
      ].join("\n")
    );
    return;
  }

  // limit link√≥w
  const activeLinks = await countActiveLinksForUserId(user.id);
  const limit = getEffectiveLinkLimit(user);

  if (activeLinks >= limit) {
    const msgText = buildLimitReachedMessage(user, activeLinks, limit);
    await tgSend(chatId, escapeHtml(msgText));
    return;
  }

  try {
    const row = await insertLinkForUserId(user.id, name, url);

    await tgSend(
      chatId,
      [
        "‚úÖ Doda≈Çem nowy link do monitorowania:",
        "",
        `ID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}`,
        `<code>${escapeHtml(row.url)}</code>`,
        "",
        `Aktywne linki: ${activeLinks + 1}/${limit}`,
        "",
        "Linki sprawdzisz komendƒÖ: <code>/lista</code>",
      ].join("\n")
    );
  } catch (err) {
    console.error("handleDodaj error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy dodawaniu linku.");
  }
}

// ---------- /status ----------

async function handleStatus(msg, user) {
  const chatId = String(msg.chat.id);

  try {
    await ensureChatNotificationsRow(chatId, user.id);
    const statusText = await buildStatusMessage(chatId, user);
    await tgSend(chatId, statusText);
  } catch (err) {
    console.error("handleStatus error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy pobieraniu statusu.");
  }
}

// ---------- /on /off ----------

async function handleNotificationsOn(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, updated_at)
    VALUES ($1, $2, TRUE, 'single', NOW())
    ON CONFLICT (chat_id, user_id) DO UPDATE SET
      enabled = TRUE,
      updated_at = NOW()
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "‚úÖ Powiadomienia W≈ÅƒÑCZONE na tym czacie.");
}

async function handleNotificationsOff(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, updated_at)
    VALUES ($1, $2, FALSE, 'single', NOW())
    ON CONFLICT (chat_id, user_id) DO UPDATE SET
      enabled = FALSE,
      updated_at = NOW()
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "‚õî Powiadomienia WY≈ÅƒÑCZONE na tym czacie.");
}

// ---------- /pojedyncze /zbiorcze (domy≈õlny tryb czatu) ----------

async function handleModeSingle(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    UPDATE chat_notifications
    SET mode = 'single', updated_at = NOW()
    WHERE chat_id = $1 AND user_id = $2
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "üì® Ustawiono tryb: <b>pojedynczo</b> (domy≈õlny na tym czacie).");
}

async function handleModeBatch(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    UPDATE chat_notifications
    SET mode = 'batch', updated_at = NOW()
    WHERE chat_id = $1 AND user_id = $2
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "üì¶ Ustawiono tryb: <b>zbiorczo</b> (domy≈õlny na tym czacie).");
}

// ---------- tryb per-link na tym czacie ----------

async function setPerLinkMode(chatId, userId, linkId, mode) {
  const m = String(mode || "").toLowerCase();
  const finalMode = m === "batch" ? "batch" : m === "off" ? "off" : "single";

  // zabezpieczenie: link musi nale≈ºeƒá do usera
  const chk = await dbQuery(
    `SELECT id FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
    [Number(linkId), Number(userId)]
  );
  if (!chk.rowCount) return { ok: false, reason: "Link nie nale≈ºy do Twojego konta." };

  await dbQuery(
    `
    INSERT INTO link_notification_modes (user_id, chat_id, link_id, mode, updated_at)
    VALUES ($1, $2, $3, $4, NOW())
    ON CONFLICT (user_id, chat_id, link_id) DO UPDATE SET
      mode = EXCLUDED.mode,
      updated_at = NOW()
    `,
    [Number(userId), String(chatId), Number(linkId), finalMode]
  );

  return { ok: true, mode: finalMode };
}

// ---------- cisza nocna ----------

async function handleQuiet(msg) {
  const chatId = String(msg.chat.id);
  const arg = (msg.text || "").trim().split(/\s+/).slice(1).join(" ").trim();

  if (!arg) {
    const qh = await getQuietHours(chatId);
    if (qh?.quiet_enabled) {
      await tgSend(chatId, `üåô Cisza nocna: <b>W≈ÅƒÑCZONA</b>, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00`);
    } else {
      await tgSend(chatId, "üåô Cisza nocna: <b>wy≈ÇƒÖczona</b>.\nUstaw: <code>/cisza 22-7</code>");
    }
    return;
  }

  const m = arg.match(/^(\d{1,2})\s*-\s*(\d{1,2})$/);
  if (!m) {
    await tgSend(chatId, "Podaj zakres jako HH-HH, np. <code>/cisza 22-7</code>");
    return;
  }

  const fromHour = Number(m[1]);
  const toHour = Number(m[2]);

  if (
    !Number.isFinite(fromHour) || !Number.isFinite(toHour) ||
    fromHour < 0 || fromHour > 23 || toHour < 0 || toHour > 23
  ) {
    await tgSend(chatId, "Godziny muszƒÖ byƒá w zakresie 0‚Äì23, np. <code>/cisza 22-7</code>");
    return;
  }

  await setQuietHours(chatId, fromHour, toHour);
  await tgSend(chatId, `üåô Ustawiono ciszƒô nocnƒÖ: <b>${fromHour}:00‚Äì${toHour}:00</b>`);
}

async function handleQuietOff(msg) {
  const chatId = String(msg.chat.id);
  await disableQuietHours(chatId);
  await tgSend(chatId, "üåô Cisza nocna: <b>WY≈ÅƒÑCZONA</b>");
}

// ---------- /najnowsze ----------

async function handleNajnowsze(msg, user, argText) {
  const chatId = String(msg.chat.id);
  const linkId = Number(argText);

  if (!Number.isFinite(linkId) || linkId <= 0) {
    await tgSend(chatId, "U≈ºycie: <code>/najnowsze ID</code>\nnp. <code>/najnowsze 18</code>");
    return;
  }

  // link musi nale≈ºeƒá do usera
  const chk = await dbQuery(
    `SELECT id, name, url, source FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
    [linkId, user.id]
  );

  if (!chk.rowCount) {
    await tgSend(chatId, `Nie widzƒô linku <b>${linkId}</b> na Twoim koncie. Sprawd≈∫ <code>/lista</code>.`);
    return;
  }

  const perLimit = getPerLinkItemLimit(user);

  const itemsQ = await dbQuery(
    `
    SELECT title, price, currency, url, first_seen_at
    FROM link_items
    WHERE link_id = $1
    ORDER BY first_seen_at DESC, id DESC
    LIMIT $2
    `,
    [linkId, perLimit]
  );

  const linkRow = chk.rows[0];
  const header = `üßæ Najnowsze oferty\n<b>${escapeHtml(linkRow.name || ("ID " + linkRow.id))}</b> <i>(ID ${linkRow.id})</i>\n`;

  if (!itemsQ.rowCount) {
    await tgSend(chatId, header + "\nBrak zapisanej historii dla tego linku (jeszcze).");
    return;
  }

  // buduj wiadomo≈õƒá (limit d≈Çugo≈õci Telegrama ~4096)
  let out = header + "\n";
  let i = 1;
  for (const it of itemsQ.rows) {
    const title = escapeHtml(it.title || "(bez tytu≈Çu)");
    const priceStr =
      it.price != null ? `${it.price} ${it.currency || ""}`.trim() : "";
    const line =
      `${i}. <b>${title}</b>` +
      (priceStr ? `\nüí∞ ${escapeHtml(priceStr)}` : "") +
      (it.url ? `\n${escapeHtml(it.url)}` : "") +
      "\n\n";

    if ((out + line).length > 3800) {
      out += "‚Ä¶ (uciƒôto ‚Äì limit d≈Çugo≈õci wiadomo≈õci)\n";
      break;
    }
    out += line;
    i++;
  }

  await tgSend(chatId, out.trim(), { disable_web_page_preview: true });
}

// ---------- callback_query z przycisk√≥w (lnmode:ID:mode) ----------

async function handleCallback(update) {
  const cq = update.callback_query;
  if (!cq) return;

  const data = cq.data || "";
  const chatId = cq.message?.chat?.id;
  const fromId = cq.from?.id ? String(cq.from.id) : null;

  if (!chatId || !fromId) {
    await tgAnswerCb(cq.id, "Brak danych czatu/u≈ºytkownika.");
    return;
  }

  const userId = await resolveUserIdFromTg(fromId);
  if (!userId) {
    await tgAnswerCb(cq.id, "Nie widzƒô Ciƒô w bazie. U≈ºyj /start lub /dodaj.");
    return;
  }

  await ensureChatNotificationsRow(String(chatId), userId);

  // lnmode:<linkId>:<off|single|batch>
  const m = data.match(/^lnmode:(\d+):(off|single|batch)$/i);
  if (m) {
    const linkId = Number(m[1]);
    const mode = String(m[2]).toLowerCase();

    const res = await setPerLinkMode(String(chatId), userId, linkId, mode);
    if (!res.ok) {
      await tgAnswerCb(cq.id, res.reason || "Nie uda≈Ço siƒô ustawiƒá trybu.", true);
      return;
    }

    const pretty =
      res.mode === "batch" ? "zbiorczo" : res.mode === "off" ? "OFF" : "pojedynczo";

    await tgAnswerCb(cq.id, `Ustawiono: ${pretty}`);
    return;
  }

  await tgAnswerCb(cq.id, t(getLang(null), "common.unknownAction"));
}

// ---------- obs≈Çuga pojedynczego update ----------


// ---------- /panel ----------
async function handlePanel(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = getLang(user);

  const baseRaw = String(process.env.PANEL_BASE_URL || "").trim();
  const base = baseRaw.replace(/\/+$/, "");
  if (!base) {
    await tgSend(chatId, t(lang, "common.panelUnavailableNoBase"));
    return;
  }

  const minutes = Number(process.env.PANEL_TOKEN_MINUTES || "10");

  try {
    const token = await createPanelLoginToken(user.id, minutes);
    const url = `${base}/api/auth/login?token=${encodeURIComponent(token)}`;
    await tgSend(chatId, t(lang, "common.panelLink", { url, minutes }));
  } catch (e) {
    console.error("handlePanel error:", e);
    await tgSend(chatId, t(lang, "common.panelFallback", { base }));
  }
}


async function handleUpdate(update) {
  if (update.callback_query) {
    // TYLKO prywatny czat (callback) ‚Äì bez grup/kana≈Ç√≥w
    const cq = update.callback_query;
    const cchat = cq && cq.message && cq.message.chat;
    if (!cchat || cchat.type !== "private") {
      try {
        if (cchat && cchat.id) {
          await tgSend(cchat.id, "Bot dzia≈Ça tylko w prywatnej rozmowie (bez grup).");
        }
      } catch (e) {}
      return;
    }

    await handleCallback(update);
    return;
  }

  const msg = update.message;
  if (!msg || !msg.text) return;

  // TYLKO prywatny czat (bez grup / kana≈Ç√≥w)
  if (!msg.chat || msg.chat.type !== "private") {
    try {
      if (msg.chat && msg.chat.id) {
        await tgSend(msg.chat.id, t(getLang(null), "common.privateOnly"));
      }
    } catch (e) {}
    return;
  }

  const chatId = msg.chat.id;
  const from = msg.from || {};
  const tgId = from.id ? String(from.id) : null;
let text = (msg.text ?? "").trim();

// NORMALIZACJA: pozw√≥l na spacjƒô zamiast "_"
const m = text.match(/^\/(on|off|pojedyncze|pojedynczo|zbiorcze)\s+(\d+)\b/i);
if (m) {
  const cmd = m[1].toLowerCase() === "pojedynczo" ? "pojedyncze" : m[1].toLowerCase();
  text = `/${cmd}_${m[2]}`;
}

  console.log("TG message:", chatId, text);

  if (!tgId) {
    await tgSend(chatId, t(getLang(null), "common.noTelegramId"));
    return;
  }

  // rejestracja / aktualizacja profilu
  await initDb();
// W grupach mo≈ºe nie byƒá from (anonimowy admin / sender_chat)
if (!from || !from.id) {
  console.warn("TG update bez from.id (anon admin / sender_chat) ‚Äì pomijam komendƒô");
  return;
}


await ensureUser(
  from.id,
  from.username || null,
  from.first_name || null,
  from.last_name || null,
  from.language_code || null
);

  // alias / user
  const resolvedId = await resolveUserIdFromTg(tgId);

  let user = null;
  if (resolvedId === 1) {
    user = await getUserById(1);
  } else {
    user = await getUserWithPlanByTelegramId(tgId);
  }

  if (!user) {
    await tgSend(
      chatId,
      "Nie widzƒô Ciƒô jeszcze w bazie.\nNajpierw u≈ºyj /dodaj (zarejestruje konto), a potem /status."
    );
    return;
  }

  // 1 user = 1 prywatny chat_id (blokujemy inne czaty)
  const privateChatId = Number(chatId);
  if (!user.telegram_chat_id) {
    const bound = await setUserTelegramChatId(user.id, privateChatId);
    if (!bound) {
      await tgSend(chatId, t(getLang(user), "common.bindChatFail"));
      return;
    }
    user.telegram_chat_id = bound;
  } else if (Number(user.telegram_chat_id) !== privateChatId) {
    await tgSend(chatId, t(getLang(user), "common.wrongChat"));
    return;
  }

  await ensureChatNotificationsRow(String(user.telegram_chat_id), user.id);

  // parsowanie komend
  const [commandRaw, ...rest] = text.split(/\s+/);
  const command = commandRaw.toLowerCase().split("\@")[0];
  const argText = rest.join(" ").trim();

// komendy per-link: /pojedyncze_18 /zbiorcze_18 /off_18 /on_18
const perLink = command.match(/^\/(pojedyncze|zbiorcze|off|on)_(\d+)$/i);
if (perLink) {
  const kind = perLink[1].toLowerCase();
  const linkId = Number(perLink[2]);

  // /on_ID = usu≈Ñ override (wraca do domy≈õlnego trybu czatu)
  if (kind === "on") {
    // zabezpieczenie: link musi nale≈ºeƒá do usera
    const chk = await dbQuery(
      `SELECT id FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
      [Number(linkId), Number(user.id)]
    );
    if (!chk.rowCount) {
      await tgSend(chatId, `‚ùå Link <b>${linkId}</b> nie nale≈ºy do Twojego konta.`);
      return;
    }

    await clearLinkNotificationMode(user.id, String(chatId), linkId);

    // odczytaj domy≈õlny tryb czatu (≈ºeby ≈Çadnie potwierdziƒá)
    const cn = await dbQuery(
      `SELECT mode FROM chat_notifications WHERE chat_id = $1 AND user_id = $2 LIMIT 1`,
      [String(chatId), Number(user.id)]
    );
    const chatMode =
      (cn.rows[0]?.mode || "single").toLowerCase() === "batch" ? "zbiorczo" : "pojedynczo";

    await tgSend(chatId, t(getLang(user), "delete.ok", { id: String(id) }));
    return;
  }

  const mode = kind === "zbiorcze" ? "batch" : kind === "off" ? "off" : "single";
  const res = await setPerLinkMode(String(chatId), user.id, linkId, mode);

  if (!res.ok) {
    await tgSend(chatId, `‚ùå ${escapeHtml(res.reason || "Nie uda≈Ço siƒô ustawiƒá trybu.")}`);
    return;
  }

  const pretty =
    res.mode === "batch" ? "zbiorczo" : res.mode === "off" ? "OFF" : "pojedynczo";

  await tgSend(chatId, t(getLang(user), "delete.ok", { id: String(id) }));
  return;
}

  if (command.startsWith("/start") || command.startsWith("/help")) {
    await handleHelp(msg, user);
  } else if (command === "/panel") {
    await handlePanel(msg, user);
  } else if (command.startsWith("/lista")) {
    await handleLista(msg, user);
  } else if (command.startsWith("/usun")) {
    await handleUsun(msg, user, argText);
  } else if (command.startsWith("/dodaj")) {
    await handleDodaj(msg, user, argText);
  } else if (command.startsWith("/status") || command.startsWith("/config")) {
    await handleStatus(msg, user);
  } else if (command === "/on") {
    await handleNotificationsOn(msg, user);
  } else if (command === "/off") {
    await handleNotificationsOff(msg, user);
  } else if (command === "/pojedyncze") {
    await handleModeSingle(msg, user);
  } else if (command === "/zbiorcze") {
    await handleModeBatch(msg, user);
  } else if (command.startsWith("/cisza_off")) {
    await handleQuietOff(msg);
  } else if (command.startsWith("/cisza")) {
    await handleQuiet(msg);
  } else if (command.startsWith("/najnowsze")) {
    await handleNajnowsze(msg, user, argText);
  } else {
    await tgSend(chatId, t(getLang(user), "common.unknownCommand"));
}
}

// ---------- main loop ----------

async function main() {
  console.log("telegram-bot.js start");

  await initDb();

  while (true) {
    try {
      const updates = await fetchUpdates();

      for (const u of updates) {
        offset = u.update_id + 1;
        try {
          await handleUpdate(u);
        } catch (e) {
          console.error("handleUpdate error:", e);
        }
      }
    } catch (e) {
      console.error("polling error:", e);
      // kr√≥tka pauza przy b≈Çƒôdach sieci
      await new Promise((r) => setTimeout(r, 1500));
    }
  }
}

main().catch((err) => {
  console.error("telegram-bot fatal error", err);
  process.exit(1);
});
