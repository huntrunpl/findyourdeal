        const linkEl = card.querySelector(
          'a[href*="/oferta/"], a[href*="/d/oferta/"]'
        );
        if (!linkEl) continue;

        const url = linkEl.href;

        let title = "";

        const titleEl =
          card.querySelector('[data-cy="ad-card-title"]') ||
          card.querySelector('[data-testid="ad-title"]') ||
          linkEl.querySelector("h6") ||
          linkEl.querySelector("h3") ||
          card.querySelector("h6") ||
          card.querySelector("h3");

        if (titleEl && titleEl.textContent) title = titleEl.textContent.trim();
        if (!title && linkEl.getAttribute("title"))
          title = linkEl.getAttribute("title").trim();
        if (!title && linkEl.textContent) title = linkEl.textContent.trim();

        let priceText = "";
        const priceEl =
          card.querySelector('[data-testid="ad-price"]') ||
          card.querySelector('[data-cy="ad-card-price"]');
        if (priceEl && priceEl.textContent)
          priceText = priceEl.textContent.trim();

        const img = card.querySelector("img");
        let photoUrl = null;
        if (img) {
          photoUrl =
            img.src ||
            img.getAttribute("src") ||
            img.getAttribute("data-src") ||
            (img.getAttribute("srcset") || "").split(" ")[0] ||
            null;
        }

        const text = card.textContent || "";
        const hasOlxDelivery = /Przesyłka OLX/i.test(text);

        results.push({
          url,
          title,
          rawPrice: priceText,
          photoUrl,
          hasOlxDelivery,
        });
      }

      return results;
    });

    if (rawItems[0]) logDebug("OLX first item debug:", rawItems[0]);

    const items = rawItems.map((it) => {
      let finalTitle = it.title || "";
      if (!finalTitle || /^wyróżnione$/i.test(finalTitle)) {
        const fromUrl = deriveOlxTitleFromUrl(it.url);
        if (fromUrl) finalTitle = fromUrl;
      }

      const { price, currency } = parsePrice(it.rawPrice);
      const itemKey = normalizeKey(it.url);

      return {
        url: it.url,
        title: finalTitle,
        price,
        currency,
        brand: null,
        size: null,
        condition: null,
        photoUrl: it.photoUrl,
        hasOlxDelivery: it.hasOlxDelivery,
        buyUrl: it.hasOlxDelivery ? it.url : null,
        itemKey,
        item_key: itemKey, // zgodność z DB/debug
      };
    });

    return items;
  } finally {
    await browser.close();
  }
}

// ---------- Scraping Vinted ----------

function pickArrayFromApi(data) {
  if (!data || typeof data !== "object") return [];
  if (Array.isArray(data.items)) return data.items;
  if (Array.isArray(data.catalog_items)) return data.catalog_items;
  if (Array.isArray(data?.data?.items)) return data.data.items;
  if (Array.isArray(data?.data?.catalog_items)) return data.data.catalog_items;
  return [];
}

async function scrapeVinted(url) {
  let q = "";
  let origin = "";
  try {
    const u = new URL(url);
    q = u.searchParams.get("search_text") || "";
    origin = u.origin;
  } catch {
    // ignore
  }

  const fallbackCurrency = getVintedFallbackCurrency(url);

  // 1) API Vinted przez Playwright request (BEZ Chromium, ale z cookies)
  try {
    const apiUrl = buildVintedApiUrl(url);
    logDebug(`Vinted API url: ${apiUrl}`);

    if (!origin) {
      try {
        origin = new URL(apiUrl).origin;
      } catch {
        // ignore
      }
    }

    const api = await request.newContext({
 proxy: PROXY || undefined,      
baseURL: origin || undefined,
      extraHTTPHeaders: {
        "user-agent":
          "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "accept-language": "pl-PL,pl;q=0.9,en;q=0.8",
      },
    });

    try {
      // Warm-up: złap anon cookies / token
      if (origin) {
        await api.get("/", {
          headers: {
            accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
        });
      }

      // Drugi warm-up: wejście na realny /catalog (często dopiero to ustawia tokeny)
      try {
        await api.get(url, {
          headers: {
            accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            referer: origin ? origin + "/" : undefined,
          },
        });
      } catch {
        // ignore
      }

      const res = await api.get(apiUrl, {
        headers: {
          accept: "application/json, text/plain, */*",
          "x-requested-with": "XMLHttpRequest",
          referer: url,
        },
      });

      const txt = await res.text().catch(() => "");
      if (!res.ok()) {
        logDebug(`Vinted API HTTP ${res.status()}: ${txt.slice(0, 180)}`);
        throw new Error(`HTTP_${res.status()}`);
      }

      let apiData = null;
      try {
        apiData = JSON.parse(txt);
      } catch {
        logDebug("Vinted API JSON_PARSE error");
        throw new Error("JSON_PARSE");
      }

      const arr = pickArrayFromApi(apiData);
      if (arr && arr.length) {
        const mapped = arr
          .map((it) => {
            const id =
              typeof it?.id === "number"
                ? it.id
                : Number.isFinite(Number(it?.id))
                ? Number(it.id)
                : null;

            const urlAbs =
              it?.url && typeof it.url === "string"
                ? it.url.startsWith("http")
                  ? it.url
                  : origin
                  ? new URL(it.url, origin).toString()
                  : it.url
                : id && origin
                ? `${origin}/items/${id}`
                : null;

            if (!urlAbs) return null;

            const title =
              it?.title ||
              it?.name ||
              it?.description ||
              it?.brand_title ||
              "";

            const priceAmount =
              it?.price?.amount ??
              it?.price?.value ??
              it?.price ??
              it?.total_item_price?.amount ??
              null;

            const price =
              priceAmount != null && String(priceAmount).trim() !== ""
                ? Number(String(priceAmount).replace(",", "."))
                : null;

            const currency =
              it?.price?.currency_code ||
              it?.currency ||
              fallbackCurrency ||
              null;

            const photoUrl =
              it?.photo?.url ||
              it?.photo?.full_size_url ||
              it?.photo?.high_resolution?.url ||
              (Array.isArray(it?.photos) && it.photos[0]?.url) ||
              null;

            const brand =
              it?.brand_title || it?.brand || it?.brand_name || null;

            const size =
              it?.size_title || it?.size || it?.size_name || null;

            const condition =
              it?.status_title ||
              it?.status ||
              it?.item_condition ||
              null;

            const itemKey = normalizeKey(urlAbs);
            const vintedId = getVintedItemIdFromUrl(itemKey) || id || null;

            return {
              url: urlAbs,
              title: String(title || "").trim(),
              price: Number.isFinite(price) ? price : null,
              currency: currency ? String(currency).toUpperCase() : null,
              brand: brand ? String(brand).trim() : null,
              size: size ? String(size).trim() : null,
              condition: condition ? String(condition).trim() : null,
              photoUrl: photoUrl ? String(photoUrl) : null,
              itemKey,
              item_key: itemKey,
              vintedId: typeof vintedId === "number" ? vintedId : null,
            };
          })
          .filter(Boolean)
          .filter((it) => {
            try {
              const u = new URL(it.itemKey || it.url);
              const h = (u.hostname || "").toLowerCase();
              return h.includes("vinted.") && u.pathname.startsWith("/items/");
            } catch {
              return false;
            }
          });

        logDebug(
          `Vinted(API pw request): items=${mapped.length}, q="${q}", currency="${fallbackCurrency || ""}"`
        );
        return mapped;
      }

      logDebug(`Vinted(API pw request): 0 items, q="${q}"`);
    } finally {
      await api.dispose().catch(() => null);
    }
  } catch (e) {
    logDebug("Vinted API (pw request) failed -> fallback DOM:", e?.message || e);
  }

  // 2) Fallback: DOM przez Chromium (jak API padnie)
const browser = await chromium.launch(PROXY ? { proxy: PROXY } : {});
    chromiumSandbox: false,
    args: ["--no-sandbox", "--disable-dev-shm-usage"],
  });

  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });

  const page = await context.newPage();

  try {
    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 });
    await page.waitForTimeout(2000);

    // jeśli Vinted zrzuci na /session-refresh, wróć do ref_url
    try {
      const cur = page.url();
      if (cur.includes("/session-refresh")) {
        const u = new URL(cur);
        const ref = u.searchParams.get("ref_url");
        if (ref) {
          const decoded = decodeURIComponent(ref);
          const u2 = new URL(decoded, `${u.protocol}//${u.host}`);
          await page.goto(u2.toString(), {
            waitUntil: "domcontentloaded",
            timeout: 45000,
          });
          await page.waitForTimeout(3000);
        }
      }
    } catch {
      // ignore
    }

    await page
      .waitForSelector(
        '[data-testid="feed-container"] [data-testid="product-card"], main a[href^="/items/"]',
        { timeout: 12000 }
      )
      .catch(() => null);

    await page.waitForTimeout(1500);

    const rawItems = await page
      .$$eval('main a[href^="/items/"]', (anchors) => {
        const seen = new Set();
        const results = [];

        function extractPhotoUrl(rootEl) {
          let el = rootEl;
          for (let depth = 0; depth < 6 && el; depth++) {
            const img = el.querySelector("img");
            if (img) {
              const srcset = img.getAttribute("srcset") || "";
              const primaryFromSrcset = srcset.split(" ")[0] || null;
              return (
                img.src ||
                img.getAttribute("src") ||
                img.getAttribute("data-src") ||
                primaryFromSrcset
              );
            }
            el = el.parentElement;
          }
          return null;
        }

        for (const a of anchors) {
          const href = a.href;
          if (!href || !href.includes("/items/")) continue;
          if (seen.has(href)) continue;
          seen.add(href);

          const titleAttr = a.getAttribute("title") || "";
          const text = a.textContent ? a.textContent.trim() : "";
          const photoUrl = extractPhotoUrl(a);

          results.push({
            url: href,
            titleAttr,
            text,
            rawPrice: "",
            photoUrl,
          });
        }

        return results;
      })
      .catch(() => []);

    logDebug(`Vinted(DOM) HTML: count=${rawItems.length}, q="${q}"`);

    const mappedItems = (rawItems || [])
      .map((it) => {
        const meta = parseVintedMeta(it.titleAttr, it.text);
        const rawPrice = meta.rawPriceFromTitle || it.rawPrice;
        const { price, currency } = parsePrice(rawPrice);
        const itemKey = normalizeKey(it.url);
        const vintedId =
          getVintedItemIdFromUrl(itemKey) || getVintedItemIdFromUrl(it.url);

        return {
          url: it.url,
          title: meta.title || it.text || "",
          price,
          currency: currency || fallbackCurrency,
          brand: meta.brand,
          size: meta.size,
          condition: meta.condition,
          photoUrl: it.photoUrl,
          itemKey,
          item_key: itemKey,
          vintedId,
        };
      })
      .filter((it) => {
        try {
          const u = new URL(it.itemKey || it.url);
          const h = (u.hostname || "").toLowerCase();
          return h.includes("vinted.") && u.pathname.startsWith("/items/");
        } catch {
          return false;
        }
      });

    return mappedItems;
  } finally {
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

// ---------- Główna logika workera ----------

function safeParseFilters(raw) {
  if (!raw) return {};
  if (typeof raw === "object") return raw;
  if (typeof raw === "string") {
    try {
      return JSON.parse(raw);
    } catch {
      return {};
    }
  }
  return {};
}

function sortItemsForNotify(source, items) {
  const src = (source || "").toLowerCase();
  if (src === "vinted") {
    // newest-first po vintedId jeśli mamy
    return [...(items || [])].sort((a, b) => {
      const ai = typeof a.vintedId === "number" ? a.vintedId : -1;
      const bi = typeof b.vintedId === "number" ? b.vintedId : -1;
      return bi - ai;
    });
  }
  return items || [];
}

async function processLink(link) {
  const source = (link.source || detectSource(link.url) || "").toLowerCase();
  if (!source) {
    logDebug(`Worker: unknown source for link ${link.id}, url=${link.url}`);
    return;
  }

  console.log(`Worker: checking ${link.url}`);

  let scraped = [];
  if (source === "olx") scraped = await scrapeOlx(link.url);
  else if (source === "vinted") scraped = await scrapeVinted(link.url);
  else {
    console.log(`Worker: unsupported source=${source} for link ${link.id}`);
    return;
  }

  const lastKey = cleanKey(link.last_key ?? link.lastKey);
  const hasLastKey = lastKey !== null;

  console.log(
    `[link ${link.id}] source=${source} scraped=${scraped.length} lastKey=${
      hasLastKey ? "YES" : "NO"
    } lastKeyVal=${lastKey ?? "(null)"}`
  );

  const { maxPerLoop, minBatchItems } = getSourceConfig(source);

  const filters = safeParseFilters(link.filters);
  const filtered = (scraped || []).filter((it) => matchFilters(it, filters));

  console.log(
    `[link ${link.id}] filtered=${filtered.length} filtersKeys=${
      Object.keys(filters || {}).length
    }`
  );

  if (!filtered.length) {
    logDebug(`Worker: no items after filters for link ${link.id}`);
    return;
  }

  // porządek newest-first
  const orderedAll =
    source === "vinted" ? sortItemsForNotify(source, filtered) : filtered;

  // ======= BASELINE: nowy link -> ustaw last_key i nic nie zapisuj/nie wysyłaj
  if (!lastKey) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey) {
      await updateLastKey(link.id, newestKey);
      console.log(`[baseline] link ${link.id} last_key ustawiony na: ${newestKey}`);
    } else {
      console.log(
        `[baseline] link ${link.id} brak itemKey do ustawienia last_key (pusto po scrapie/filtrach)`
      );
    }
    return;
  }

  // ======= normalnie: bierz tylko "nowsze niż last_key"
  const { fresh: freshByLastKey, found } = takeNewItemsUntilLastKey(
    orderedAll,
    lastKey
  );

  // Jeśli last_key nie znaleziony na liście => RESYNC bez spamu
  if (!found) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) {
      await updateLastKey(link.id, newestKey);
      logDebug(
        `[resync] link ${link.id} last_key nie znaleziony w listingu -> ustawiam na: ${newestKey} (bez insert/notify)`
      );
    }
    return;
  }

  if (!freshByLastKey.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) {
      await updateLastKey(link.id, newestKey);
    }
    logDebug(`Worker: no fresh items before last_key for link ${link.id}`);
    return;
  }

  // ======= seen-check TYLKO dla tych świeżych (szybkie + poprawne)
  const keysToCheck = freshByLastKey.map(getItemKey).filter(Boolean);
  const seenSet = await getSeenItemKeys(link.id, keysToCheck);

  const freshNotSeen = freshByLastKey.filter((it) => {
    const k = getItemKey(it);
    return k && !seenSet.has(k);
  });

  if (!freshNotSeen.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) {
      await updateLastKey(link.id, newestKey);
    }
    logDebug(`Worker: fresh items existed but all already seen for link ${link.id}`);
    return;
  }

  // zapisujemy do DB wszystkie świeże nie-widziane
  await insertLinkItems(link.id, freshNotSeen);

  // wysyłka limitowana
  const toSend = freshNotSeen.slice(0, maxPerLoop);
  const skipped = freshNotSeen.length - toSend.length;

  if (toSend.length) {
    await notifyChatsForLink(link, toSend, skipped, { minBatchItems });
  }

  // przesuwamy last_key na aktualnie najnowszy z listingu
  const newestKey = getItemKey(orderedAll[0]);
  if (newestKey) {
    await updateLastKey(link.id, newestKey);
  }

  // przytnij historię (żeby DB nie rosła do tysięcy)
  if (Number.isFinite(HISTORY_KEEP_PER_LINK) && HISTORY_KEEP_PER_LINK > 0) {
    await pruneLinkItems(link.id, HISTORY_KEEP_PER_LINK);
  }
}

async function loopOnce() {
  await initDb();
  const links = await getLinksForWorker();
  console.log(`Worker: found links: ${links.length}`);

  for (const link of links) {
    try {
      await processLink(link);
    } catch (err) {
      console.error(`Worker: error for link ${link.id}`, err);
    }
  }
}

async function main() {
  console.log("Worker start");

  while (true) {
    try {
      await loopOnce();
    } catch (err) {
      console.error("Worker: loopOnce error", err);
    }
    await sleep(LOOP_DELAY_MS);
  }
}

main().catch((err) => {
  console.error("Worker fatal error", err);
  process.exit(1);
});
