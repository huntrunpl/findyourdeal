import dotenv from "dotenv";
dotenv.config();



import { randomBytes } from "crypto";
import pg from "pg";
const { Pool } = pg;

// __FYD_TG_OUTBOUND_NORM_V4
const __FYD_TG_POOL_V4 = globalThis.__FYD_TG_POOL_V4 || (process.env.DATABASE_URL ? new Pool({ connectionString: process.env.DATABASE_URL }) : new Pool());
globalThis.__FYD_TG_POOL_V4 = __FYD_TG_POOL_V4;

function __fydLangBaseV4(x) {
  const raw = String(x || "").trim().toLowerCase();
  return raw.includes("-") ? raw.split("-")[0] : raw;
}

async function __fydLangForChatV4(chatId) {
  let lang = "en";
  try {
    const cid = Number(chatId);
    if (Number.isFinite(cid) && cid > 0) {
      const r = await __FYD_TG_POOL_V4.query("SELECT language AS lang FROM public.users WHERE telegram_user_id=$1 LIMIT 1", [cid]);
      if (r?.rows?.[0]?.lang) lang = String(r.rows[0].lang);
    }
  } catch {}
  return __fydLangBaseV4(lang) || "en";
}

function __fydT_V4(lang, key) {
  const L = __fydLangBaseV4(lang) || "en";
  const d = {
    en: { disable:"Disable this link", single:"Single", batch:"Batch", active:"Active monitored links:", disable_hint:"Disable: /remove ID", example:"E.g. /remove 18" },
    pl: { disable:"Wy≈ÇƒÖcz ten link", single:"Pojedynczo", batch:"Zbiorczo", active:"Aktywne monitorowane linki:", disable_hint:"Wy≈ÇƒÖczenie: /usun ID", example:"Np. /usun 18" },
    cs: { disable:"Vypnout tento odkaz", single:"Jednotlivƒõ", batch:"Hromadnƒõ", active:"Aktivn√≠ sledovan√© odkazy:", disable_hint:"Vypnout: /remove ID", example:"Nap≈ô. /remove 18" },
  };
  const pack = d[L] || d.en;
  return pack[key] || d.en[key] || String(key);
}

function __fydStripPrefixIconsV4(t) {
  return String(t || "").replace(/^[^\p{L}\p{N}]+/gu, "").trim();
}
function __fydIsDisableV4(t) {
  t = t.toLowerCase();
  return t.includes("wy≈ÇƒÖcz") || t.includes("wylacz") || t.includes("disable") || t.includes("vypnout");
}
function __fydIsSingleV4(t) {
  t = t.toLowerCase();
  return t.includes("pojedyncz") || t.includes("single") || t.includes("jednotliv");
}
function __fydIsBatchV4(t) {
  t = t.toLowerCase();
  return t.includes("zbiorcz") || t.includes("batch") || t.includes("hromad");
}

async function __fydNormalizePayloadV4(payload, endpointPath) {
  try {
    if (!payload || typeof payload !== "object") return payload;

    const lang = await __fydLangForChatV4(payload.chat_id);

    // /lista: popraw nag≈Ç√≥wki na jƒôzyk z DB (≈ºeby nie by≈Ço zawsze EN)
    if (typeof payload.text === "string") {
      payload.text = payload.text
        .replace(/^üìã?\s*Active monitored links:\s*/m, "üìã " + __fydT_V4(lang, "active") + "\n\n")
        .replace(/^Disable:\s*\/remove\s+ID\s*$/m, __fydT_V4(lang, "disable_hint"))
        .replace(/^E\.g\.\s*\/remove\s+18\s*$/m, __fydT_V4(lang, "example"));
    }

    // sendMessage: wymu≈õ web preview ON (≈ºeby mniej ‚Äúbez zdjƒôƒá‚Äù)
    if (String(endpointPath || "").includes("/sendMessage")) {
      payload.disable_web_page_preview = false;
      payload.link_preview_options = { is_disabled: false };
    }

    // inline buttons: zawsze bez ikon + w jƒôzyku z DB
    let rm = payload.reply_markup;
    if (!rm) return payload;

    let obj = rm;
    let wasString = false;
    if (typeof rm === "string") {
      try { obj = JSON.parse(rm); wasString = true; } catch { return payload; }
    }
    if (!obj || !Array.isArray(obj.inline_keyboard)) return payload;

    for (const row of obj.inline_keyboard) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        if (!btn || typeof btn !== "object") continue;
        const base = __fydStripPrefixIconsV4(btn.text);
        if (__fydIsDisableV4(base)) btn.text = __fydT_V4(lang, "disable");
        else if (__fydIsSingleV4(base)) btn.text = __fydT_V4(lang, "single");
        else if (__fydIsBatchV4(base)) btn.text = __fydT_V4(lang, "batch");
      }
    }

    payload.reply_markup = wasString ? JSON.stringify(obj) : obj;
    return payload;
  } catch {
    return payload;
  }
}

// wrap fetch -> normalize ONLY telegram send* endpoints
const __fydOrigFetch_V4 = fetch;
async function __fydFetch(url, opts) {
  try {
    const u = String(url || "");
    if (!u.includes("api.telegram.org")) return __fydOrigFetch_V4(url, opts);

    const ep = u.split("?")[0];
    const m = (opts && opts.method) ? String(opts.method).toUpperCase() : "GET";
    if (m !== "POST") return __fydOrigFetch_V4(url, opts);

    if (!/(\/sendMessage|\/sendPhoto|\/editMessageText|\/editMessageCaption|\/sendMediaGroup)\b/.test(ep)) {
      return __fydOrigFetch_V4(url, opts);
    }

    const body = opts && opts.body;
    if (typeof body !== "string") return __fydOrigFetch_V4(url, opts);

    let payload;
    try { payload = JSON.parse(body); } catch { return __fydOrigFetch_V4(url, opts); }

    payload = await __fydNormalizePayloadV4(payload, ep);

    const nopts = Object.assign({}, (opts || {}));
    nopts.body = JSON.stringify(payload);
    return __fydOrigFetch_V4(url, nopts);
  } catch {
    return __fydOrigFetch_V4(url, opts);
  }
}
// __FYD_FORCE_BTN_I18N_V2
const __FYD_BTN_LANG_POOL_V2 = globalThis.__FYD_BTN_LANG_POOL_V2 || (process.env.DATABASE_URL ? new Pool({ connectionString: process.env.DATABASE_URL }) : new Pool());
globalThis.__FYD_BTN_LANG_POOL_V2 = __FYD_BTN_LANG_POOL_V2;
const __FYD_BTN_LANG_CACHE_V2 = globalThis.__FYD_BTN_LANG_CACHE_V2 || new Map();
globalThis.__FYD_BTN_LANG_CACHE_V2 = __FYD_BTN_LANG_CACHE_V2;

function __fydLangBaseV2(x) {
  const raw = String(x || "").trim().toLowerCase();
  return raw.includes("-") ? raw.split("-")[0] : raw;
}

async function __fydGetLangForChatIdV2(chatId) {
  const key = String(chatId || "");
  const now = Date.now();
  const hit = __FYD_BTN_LANG_CACHE_V2.get(key);
  if (hit && hit.exp > now) return hit.lang;

  let lang = "en";
  try {
    const cid = Number(chatId);
    if (Number.isFinite(cid)) {
      const r = await __FYD_BTN_LANG_POOL_V2.query("SELECT language AS lang FROM public.users WHERE telegram_user_id=$1 LIMIT 1", [cid]);
      if (r && r.rows && r.rows[0] && r.rows[0].lang) lang = String(r.rows[0].lang);
    }
  } catch {}

  lang = __fydLangBaseV2(lang) || "en";
  __FYD_BTN_LANG_CACHE_V2.set(key, { lang, exp: now + 3600_000 });
  return lang;
}

function __fydBtnTextV2(lang, key) {
  const L = __fydLangBaseV2(lang) || "en";
  const dict = {
    en: { disable: "Disable this link", single: "Single", batch: "Batch" },
    pl: { disable: "Wy≈ÇƒÖcz ten link", single: "Pojedynczo", batch: "Zbiorczo" },
    de: { disable: "Diesen Link deaktivieren", single: "Einzeln", batch: "Geb√ºndelt" },
    fr: { disable: "D√©sactiver ce lien", single: "Individuel", batch: "Group√©" },
    es: { disable: "Desactivar este enlace", single: "Individual", batch: "Agrupado" },
    it: { disable: "Disattiva questo link", single: "Singolo", batch: "Raggruppato" },
    nl: { disable: "Deze link uitschakelen", single: "Enkel", batch: "Gebundeld" },
    cs: { disable: "Vypnout tento odkaz", single: "Jednotlivƒõ", batch: "Hromadnƒõ" },
    sk: { disable: "Vypn√∫≈• tento odkaz", single: "Jednotlivo", batch: "Hromadne" },
    hu: { disable: "Link kikapcsol√°sa", single: "Egyenk√©nt", batch: "Csoportosan" },
    ro: { disable: "DezactiveazƒÉ acest link", single: "Individual", batch: "Grupat" },
    hr: { disable: "Iskljuƒçi ovu poveznicu", single: "Pojedinaƒçno", batch: "Skupno" },
    sr: { disable: "Iskljuƒçi ovu vezu", single: "Pojedinaƒçno", batch: "Zbirno" },
    bs: { disable: "Iskljuƒçi ovaj link", single: "Pojedinaƒçno", batch: "Zbirno" },
    uk: { disable: "–í–∏–º–∫–Ω—É—Ç–∏ —Ü–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è", single: "–û–∫—Ä–µ–º–æ", batch: "–ü–∞–∫–µ—Ç–æ–º" },
    ru: { disable: "–û—Ç–∫–ª—é—á–∏—Ç—å —ç—Ç—É —Å—Å—ã–ª–∫—É", single: "–ü–æ –æ–¥–Ω–æ–π", batch: "–ü–∞–∫–µ—Ç–æ–º" },
  };
  const d = dict[L] || dict.en;
  return d[key] || dict.en[key] || String(key);
}

function __fydStripEmojiV2(t) {
  // usu≈Ñ ikonki / emoji z poczƒÖtku
  return String(t || "").replace(/^[^\p{L}\p{N}]+/gu, "").trim();
}

async function __fydForceButtonsI18nV2(url, payload) {
  try {
    if (!String(url || "").includes("sendMessage")) return;
    if (!payload || typeof payload !== "object") return;

    let rm = payload.reply_markup;
    let obj = rm;
    let wasString = false;

    if (typeof rm === "string") {
      try { obj = JSON.parse(rm); wasString = true; } catch { return; }
    }

    if (!obj || !Array.isArray(obj.inline_keyboard)) return;

    const lang = await __fydGetLangForChatIdV2(payload.chat_id);

    for (const row of obj.inline_keyboard) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        if (!btn || typeof btn !== "object") continue;
        const base = __fydStripEmojiV2(btn.text).toLowerCase();

        if (base.includes("wy≈ÇƒÖcz") || base.includes("disable")) {
          btn.text = __fydBtnTextV2(lang, "disable");
        } else if (base.includes("pojedynczo") || base.includes("single")) {
          btn.text = __fydBtnTextV2(lang, "single");
        } else if (base.includes("zbiorczo") || base.includes("batch")) {
          btn.text = __fydBtnTextV2(lang, "batch");
        }
      }
    }

    if (typeof rm === "string") {
      payload.reply_markup = JSON.stringify(obj);
    } else {
      payload.reply_markup = obj;
    }
  } catch {}
}
// __FYD_BTN_LANG_GUARD_V1
const __FYD_LANG_POOL = (process.env.DATABASE_URL ? new Pool({ connectionString: process.env.DATABASE_URL }) : new Pool());
const __FYD_LANG_CACHE = new Map();

function __fydLangBase(x) {
  const raw = String(x || "").trim().toLowerCase();
  return raw.includes("-") ? raw.split("-")[0] : raw;
}

async function __fydGetLangForChatId(chatId) {
  const key = String(chatId || "");
  const now = Date.now();
  const hit = __FYD_LANG_CACHE.get(key);
  if (hit && hit.exp > now) return hit.lang;

  let lang = "en";
  try {
    const cid = Number(chatId);
    if (Number.isFinite(cid)) {
      const r = await __FYD_LANG_POOL.query("SELECT language AS lang FROM public.users WHERE telegram_user_id=$1 LIMIT 1", [cid]);
      if (r && r.rows && r.rows[0] && r.rows[0].lang) lang = String(r.rows[0].lang);
    }
  } catch {}
  lang = __fydLangBase(lang) || "en";
  __FYD_LANG_CACHE.set(key, { lang, exp: now + 3600_000 });
  return lang;
}

function __fydBtnText(lang, key) {
  const L = __fydLangBase(lang) || "en";
  const dict = {
    en: { disable: "Disable this link", single: "Single", batch: "Batch" },
    pl: { disable: "Wy≈ÇƒÖcz ten link", single: "Pojedynczo", batch: "Zbiorczo" },
    de: { disable: "Diesen Link deaktivieren", single: "Einzeln", batch: "Geb√ºndelt" },
    fr: { disable: "D√©sactiver ce lien", single: "Individuel", batch: "Group√©" },
    es: { disable: "Desactivar este enlace", single: "Individual", batch: "Agrupado" },
    it: { disable: "Disattiva questo link", single: "Singolo", batch: "Raggruppato" },
    nl: { disable: "Deze link uitschakelen", single: "Enkel", batch: "Gebundeld" },
    cs: { disable: "Vypnout tento odkaz", single: "Jednotlivƒõ", batch: "Hromadnƒõ" },
    sk: { disable: "Vypn√∫≈• tento odkaz", single: "Jednotlivo", batch: "Hromadne" },
    hu: { disable: "Link kikapcsol√°sa", single: "Egyenk√©nt", batch: "Csoportosan" },
    ro: { disable: "DezactiveazƒÉ acest link", single: "Individual", batch: "Grupat" },
    hr: { disable: "Iskljuƒçi ovu poveznicu", single: "Pojedinaƒçno", batch: "Skupno" },
    sr: { disable: "Iskljuƒçi ovu vezu", single: "Pojedinaƒçno", batch: "Zbirno" },
    bs: { disable: "Iskljuƒçi ovaj link", single: "Pojedinaƒçno", batch: "Zbirno" },
    uk: { disable: "–í–∏–º–∫–Ω—É—Ç–∏ —Ü–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è", single: "–û–∫—Ä–µ–º–æ", batch: "–ü–∞–∫–µ—Ç–æ–º" },
    ru: { disable: "–û—Ç–∫–ª—é—á–∏—Ç—å —ç—Ç—É —Å—Å—ã–ª–∫—É", single: "–ü–æ –æ–¥–Ω–æ–π", batch: "–ü–∞–∫–µ—Ç–æ–º" },
  };
  const d = dict[L] || dict.en;
  return d[key] || dict.en[key] || String(key);
}

async function __fydFixInlineButtonsForSendMessage(url, payload) {
  try {
    if (!String(url || "").includes("sendMessage")) return;
    if (!payload || typeof payload !== "object") return;
    const rm = payload.reply_markup;
    if (!rm || !rm.inline_keyboard || !Array.isArray(rm.inline_keyboard)) return;

    const lang = await __fydGetLangForChatId(payload.chat_id);
    for (const row of rm.inline_keyboard) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        if (!btn || typeof btn !== "object") continue;
        const t = String(btn.text || "");
        // dotykamy TYLKO tych 3 przycisk√≥w (nie ruszamy "URL" itp.)
        const tt = t.toLowerCase();
        if (tt.includes("wy≈ÇƒÖcz") || tt.includes("disable")) {
          btn.text = __fydBtnText(lang, "disable");
        } else if (tt.includes("pojedynczo") || tt.includes("single")) {
          btn.text = __fydBtnText(lang, "single");
        } else if (tt.includes("zbiorczo") || tt.includes("batch")) {
          btn.text = __fydBtnText(lang, "batch");
        }
      }
    }
  } catch {}
}
// __FYD_OUTGOING_TEXT_FIX_V1__
function __fydAppendVintedUrl(text) {
  text = String(text ?? "");
  if (text.includes("vinted.pl/items/")) return text;
  const m = text.match(/\bVinted\s+(\d{6,})\b/);
  if (!m) return text;
  return text + "\nhttps://www.vinted.pl/items/" + m[1];
}

function __fydAppendUrlFromKeyboard(text, payload) {
  try {
    text = String(text ?? "");
    if (text.includes("http://") || text.includes("https://")) return text;

    const kb = payload && payload.reply_markup && payload.reply_markup.inline_keyboard;
    if (!Array.isArray(kb)) return text;

    for (const row of kb) {
      if (!Array.isArray(row)) continue;
      for (const btn of row) {
        const u = btn && typeof btn.url === "string" ? btn.url : "";
        if (u.startsWith("http://") || u.startsWith("https://")) {
          return text + "\n" + u;
        }
      }
    }
    return text;
  } catch {
    return String(text ?? "");
  }
}

function __fydFixOutgoingText(text, payload) {
  text = __fydAppendVintedUrl(text);
  text = __fydAppendUrlFromKeyboard(text, payload);
  return text;
}
import fetch from "node-fetch";

import { t, DEFAULT_LANG, normalizeLang, langLabel, buildLanguageKeyboard } from "./i18n.js";
import {
  initDb,
  ensureUser,
  setUserLanguage,
  getUserWithPlanByTelegramId,
  getUserEntitlementsByTelegramId,
  getUserById,
  getLinksByUserId,
  countActiveLinksForUserId,
  countEnabledLinksForUserId,
  insertLinkForUserId,
  deactivateLinkForUserId,
  setQuietHours,
  disableQuietHours,
  getQuietHours,
  ensureChatNotificationsRow as ensureChatNotificationsRowDb,
  clearLinkNotificationMode,
} from "./db.js";


const TG = process.env.TELEGRAM_BOT_TOKEN || "";
const DATABASE_URL = process.env.DATABASE_URL || "";
const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY || "";
const BOT_USERNAME =
  process.env.TELEGRAM_BOT_USERNAME ||
  process.env.BOT_USERNAME ||
  process.env.FYD_BOT_USERNAME ||
  "";

const PRICE_STARTER = process.env.FYD_PRICE_STARTER || "";
const PRICE_GROWTH = process.env.FYD_PRICE_GROWTH || "";
const PRICE_PLATINUM = process.env.FYD_PRICE_PLATINUM || "";
const PRICE_ADDON10 = process.env.FYD_PRICE_ADDON10 || "";

if (!TG) { console.error("Missing TELEGRAM_BOT_TOKEN"); process.exit(1); }
if (!DATABASE_URL) { console.error("Missing DATABASE_URL"); process.exit(1); }

const pool = new Pool({ connectionString: DATABASE_URL });

async function dbQuery(sql, params = []) { return pool.query(sql, params); }

function escapeHtml(str = "") {
  return String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

// ---------- i18n (language) ----------
const FYD_DEFAULT_LANG = "en";
const FYD_SUPPORTED_LANGS = [
  { code: "pl", name: "Polski", flag: "üáµüá±" },
  { code: "en", name: "English", flag: "üá¨üáß" },
  { code: "de", name: "Deutsch", flag: "üá©üá™" },
  { code: "fr", name: "Fran√ßais", flag: "üá´üá∑" },
  { code: "es", name: "Espa√±ol", flag: "üá™üá∏" },
  { code: "it", name: "Italiano", flag: "üáÆüáπ" },
  { code: "pt", name: "Portugu√™s", flag: "üáµüáπ" },
  { code: "ro", name: "Rom√¢nƒÉ", flag: "üá∑üá¥" },
  { code: "nl", name: "Nederlands", flag: "üá≥üá±" },
  { code: "cs", name: "ƒåe≈°tina", flag: "üá®üáø" },
  { code: "sk", name: "Slovenƒçina", flag: "üá∏üá∞" },
];

function fydLangFromUser(user) {
  const raw = String(user?.language || user?.language_code || "").toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  return FYD_SUPPORTED_LANGS.some((x) => x.code === base) ? base : FYD_DEFAULT_LANG; // fallback EN
}

function fydBuildLangKeyboard() {
  const buttons = FYD_SUPPORTED_LANGS.map((l) => ({
    text: `${l.name} ${l.flag}`,
    callback_data: `lang:${l.code}`,
  }));
  const rows = [];
  for (let i = 0; i < buttons.length; i += 2) rows.push(buttons.slice(i, i + 2));
  return { inline_keyboard: rows };
}
// ---------- i18n (language) END ----------

function addon10CheckoutIntro(lang) {
  const L = normalizeLang(lang);
  const MAP = {
    pl: "‚ûï Addon +10: +10 link√≥w oraz +100 limitu historii.\nOtw√≥rz p≈Çatno≈õƒá poni≈ºej:",
    en: "‚ûï Addon +10: +10 links and +100 history limit.\nOpen checkout link below:",
    de: "‚ûï Addon +10: +10 Links und +100 Verlaufslimit.\n√ñffne den Checkout-Link unten:",
    fr: "‚ûï Addon +10 : +10 liens et +100 de limite d‚Äôhistorique.\nOuvrez le lien de paiement ci-dessous :",
    es: "‚ûï Addon +10: +10 enlaces y +100 de l√≠mite de historial.\nAbre el enlace de pago abajo:",
    it: "‚ûï Addon +10: +10 link e +100 di limite storico.\nApri il link di pagamento qui sotto:",
    pt: "‚ûï Addon +10: +10 links e +100 de limite de hist√≥rico.\nAbra o link de pagamento abaixo:",
    ro: "‚ûï Addon +10: +10 linkuri »ôi +100 la limita istoricului.\nDeschide linkul de platƒÉ de mai jos:",
    nl: "‚ûï Addon +10: +10 links en +100 geschiedenislimiet.\nOpen de betaallink hieronder:",
    cs: "‚ûï Addon +10: +10 odkaz≈Ø a +100 limit historie.\nOtev≈ôete platebn√≠ odkaz n√≠≈æe:",
    sk: "‚ûï Addon +10: +10 odkazov a +100 limit hist√≥rie.\nOtvorte platobn√Ω odkaz ni≈æ≈°ie:",
  };
  return MAP[L] || MAP.en;
}


function getErrorText(e) {
  return e?.message ? String(e.message) : String(e);
}

// __FYD_DEDUPE_PANEL_LINK_V1__
function __fydDedupePanelLinkText(text) {
  try {
    if (typeof text !== "string") return text;
    const re = /https:\/\/panel\.findyourdeal\.app\/api\/auth\/login\?token=[a-f0-9]+/gi;
    const m = text.match(re) || [];
    if (m.length <= 1) return text;

    const url = m[0];
    const lines = text.split("\n");
    const hasPanelLine = lines.some((l) => /panel/i.test(l) && l.includes(url));

    const out = [];
    for (const l of lines) {
      const isUrlLine = (l || "").trim() === url;
      if (isUrlLine) {
        if (hasPanelLine) continue;                 // je≈õli URL jest ju≈º w linii "Panel: ...", usu≈Ñ standalone
        if (out.some((x) => (x || "").trim() === url)) continue; // inaczej zostaw tylko pierwszy
      }
      out.push(l);
    }
    return out.join("\n").replace(/\n{3,}/g, "\n\n");
  } catch {
    return text;
  }
}

async function tgApi(method, payload) {
  // __FYD_DEDUPE_PANEL_LINK_V1__
  try {
    if (String(method || "") === "sendMessage" && payload && typeof payload.text === "string") {
      payload.text = __fydDedupePanelLinkText(payload.text);
    }
  } catch {}


  const url = `https://api.telegram.org/bot${TG}/${method}`;
  // __FYD_FORCE_WEB_PREVIEW_ON_V4
  try {
    if (String(url || "").includes("sendMessage") && payload && typeof payload === "object") {
      payload.disable_web_page_preview = false;
      payload.link_preview_options = { is_disabled: false };
      try { if (payload.linkPreviewOptions) delete payload.linkPreviewOptions; } catch {}
    }
  } catch {}

  // __FYD_FORCE_PREVIEW_AND_RAW_URL_V1
  try {
    // wymu≈õ preview ON
    if (payload && typeof payload === "object") {
      payload.disable_web_page_preview = false;
      payload.link_preview_options = { is_disabled: false };
      try { if (payload.linkPreviewOptions) delete payload.linkPreviewOptions; } catch {}
    }

    // dopnij "go≈Çy" URL na ko≈Ñcu tekstu (Telegram wtedy robi miniaturƒô)
    if (String(url || "").includes("sendMessage") && payload && typeof payload === "object") {
      const text = String(payload.text || "");
      let u = "";

      // 1) z href="..."
      let mm = text.match(/href="(https?:\/\/[^"]+)"/i);
      if (mm && mm[1]) u = mm[1];

      // 2) albo pierwszy URL w tre≈õci
      if (!u) {
        mm = text.match(/https?:\/\/[^\s<>"']+/i);
        if (mm && mm[0]) u = mm[0];
      }

      if (u && !text.includes("\n" + u)) {
        payload.text = text.replace(/\s+$/,"") + "\n" + u;
      }
    }
  } catch {}

  // __FYD_CALL_FIX_BTNS_V1
  
  // __FYD_PANEL_DEDUPE_V3__ (dedupe /panel login URL lines safely)
  try {
    const txt = String(payload?.text || "");
    if (txt.includes("/api/auth/login?token=")) {
      const m = txt.match(/https?:\/\/[^\s]+\/api\/auth\/login\?token=[a-f0-9]+/i);
      if (m && m[0]) {
        const u = m[0];
        const lines = txt.split(/\r?\n/);
        const hasPanelLine = lines.some((ln) => String(ln || "").includes("Panel:") && String(ln || "").includes(u));
        const out = [];
        let rawSeen = 0;

        for (const ln of lines) {
          const t = String(ln || "").trim();
          if (t === u) {
            if (hasPanelLine) continue; // je≈õli jest "Panel: <url>" -> usu≈Ñ surowe linki
            rawSeen += 1;
            if (rawSeen > 1) continue;  // inaczej zostaw tylko 1 surowy link
          }
          out.push(ln);
        }

        let newTxt = out.join("\n").replace(/\n{3,}/g, "\n\n").trim();
        if (!newTxt) newTxt = `Panel: ${u}`; // nie wysy≈Çaj pustego tekstu
        payload.text = newTxt;
      }
    }
  } catch {}
await __fydFixInlineButtonsForSendMessage(url, payload);
  // __FYD_CALL_FORCE_BTN_I18N_V2
  await __fydForceButtonsI18nV2(url, payload);
  // __FYD_PANEL_DEDUPE_V2__ (remove duplicated /panel login URL lines)
  try {
    if (payload && typeof payload.text === "string" && payload.text.includes("/api/auth/login?token=")) {
      const mUrl = payload.text.match(/https?:\/\/[^\s]+\/api\/auth\/login\?token=[a-f0-9]+/i);
      if (mUrl) {
        const u = mUrl[0];
        const lines = payload.text.split(/\r?\n/);
        const hasPanelLine = lines.some((ln) => (ln || "").includes("Panel:") && (ln || "").includes(u));

        const out = [];
        let rawSeen = 0;
        for (const ln of lines) {
          const t = (ln || "").trim();
          if (t === u) {
            rawSeen += 1;
            if (hasPanelLine) continue;   // je≈õli jest "Panel: <url>" usu≈Ñ wszystkie surowe linki
            if (rawSeen > 1) continue;    // inaczej zostaw tylko 1 surowy link
          }
          out.push(ln);
        }
        payload.text = out.join("\n").replace(/\n{3,}/g, "\n\n");
      }
    }
  } catch {}

  const res = await __fydFetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
  return res.json().catch(() => ({}));
}

// __FYD_APPEND_VINTED_URL_V1__
async function tgSend(chatId, text, extra = {}) {
  // __FYD_PANEL_DEDUPE_V4__ (dedupe /panel login URL lines)
  try {
    if (typeof text === "string" && text.includes("/api/auth/login?token=")) {
      const mUrl = text.match(/https?:\/\/[^\s]+\/api\/auth\/login\?token=[a-f0-9]+/i);
      if (mUrl && mUrl[0]) {
        const url = mUrl[0];
        const lines = text.split(/\r?\n/);
        const hasPanelLine = lines.some((ln) => String(ln || "").includes("Panel:") && String(ln || "").includes(url));

        const out = [];
        let rawSeen = 0;
        for (const ln of lines) {
          const t = String(ln || "").trim();
          if (t === url) {
            if (hasPanelLine) continue;
            rawSeen += 1;
            if (rawSeen > 1) continue;
          }
          out.push(ln);
        }

        let newText = out.join("\n").replace(/\n{3,}/g, "\n\n").trim();
        if (!newText) newText = `Panel: ${url}\nToken wa≈ºny 10 minut.`;
        text = newText;
      }
    }
  } catch {}
  // __FYD_TGSEND_REBUILD_V3__ (fix syntax + panel URL dedupe)
  let outText = (text === undefined || text === null) ? "" : String(text);

  // Dedupe: Panel login URL (gdy pojawia siƒô 2-3 razy jako surowy link)
  try {
    if (outText.includes("/api/auth/login?token=")) {
      const mUrl = outText.match(/https?:\/\/[^\s]+\/api\/auth\/login\?token=[a-f0-9]+/i);
      if (mUrl) {
        const url = mUrl[0];
        const lines = outText.split(/\r?\n/);
        const hasPanelLine = lines.some((ln) => ln.includes("Panel:") && ln.includes(url));
        const out = [];
        let seenRaw = 0;

        for (const ln of lines) {
          const t = (ln || "").trim();
          if (t === url) {
            seenRaw += 1;
            if (hasPanelLine) continue;      // je≈õli jest "Panel: <url>" to wywal surowe linki
            if (seenRaw >= 2) continue;       // inaczej zostaw tylko 1 surowy link
          }
          out.push(ln);
        }
        outText = out.join("\n").replace(/\n{3,}/g, "\n\n");
      }
    }
  } catch {}

  const url = `https://api.telegram.org/bot${TG}/sendMessage`;
  const payload = { chat_id: chatId, text: outText, ...extra };

  if (payload.parse_mode === undefined) payload.parse_mode = "HTML";
  if (payload.disable_web_page_preview === undefined) payload.disable_web_page_preview = true;

  // istniejƒÖce poprawki przycisk√≥w
  await __fydFixInlineButtonsForSendMessage(url, payload);
  await __fydForceButtonsI18nV2(url, payload);

  const res = await __fydFetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  return res.json().catch(() => ({}));
}


async function tgAnswerCb(callbackQueryId, text, showAlert = false) {
  try {
    await tgApi("answerCallbackQuery", { callback_query_id: callbackQueryId, text, show_alert: !!showAlert });
  } catch {}
}

async function stripeGet(path, qs = {}) {
  if (!STRIPE_SECRET_KEY) throw new Error("NO_STRIPE_SECRET_KEY");
  const u = new URL(`https://api.stripe.com${path}`);
  for (const [k, v] of Object.entries(qs)) if (v != null) u.searchParams.append(k, String(v));
  const res = await __fydFetch(u.toString(), { method: "GET", headers: { Authorization: `Bearer ${STRIPE_SECRET_KEY}` } });
  const j = await res.json().catch(() => ({}));
  if (!res.ok) throw new Error(j?.error?.message || `STRIPE_GET_${res.status}`);
  return j;
}

async function stripePostForm(path, paramsObj = {}) {
  if (!STRIPE_SECRET_KEY) throw new Error("NO_STRIPE_SECRET_KEY");
  const body = new URLSearchParams();
  for (const [k, v] of Object.entries(paramsObj)) if (v != null) body.append(k, String(v));
  const res = await __fydFetch(`https://api.stripe.com${path}`, {
    method: "POST",
    headers: { Authorization: `Bearer ${STRIPE_SECRET_KEY}`, "Content-Type": "application/x-www-form-urlencoded" },
    body,
  });
  const j = await res.json().catch(() => ({}));
  if (!res.ok) throw new Error(j?.error?.message || `STRIPE_POST_${res.status}`);
  return j;
}

async function stripeCancelSubscriptionNow(subId) {
  if (!subId) return;
  try { await stripePostForm(`/v1/subscriptions/${encodeURIComponent(subId)}`, { cancel_at_period_end: "false" }); }
  catch (e) { console.warn("[stripe] cancel old sub failed:", e?.message || e); }
}

async function getPlanIdByCode(code) {
  const c = String(code || "").toLowerCase();
  const aliases = { starter: "basic", growth: "pro" };
  const norm = aliases[c] || c;
  try {
    const q = await dbQuery(`SELECT id FROM plans WHERE LOWER(code)=LOWER($1) LIMIT 1`, [norm]);
    if (q.rowCount) return Number(q.rows[0].id);
  } catch {}
  return 0;
}

function planLabel(code) {
  const c = String(code || "").toLowerCase();
  if (c === "starter" || c === "basic") return "Starter";
  if (c === "growth" || c === "pro") return "Growth";
  if (c === "platinum") return "Platinum";
  return "Plan";
}

function nowPlusMinutes(min) {
  return new Date(Date.now() + Number(min) * 60 * 1000).toISOString();
}

async function createActivationToken({ planId, kind, checkoutSessionId, tgUserId }) {
  const token = randomBytes(24).toString("hex");
  const provider = "stripe";
  const providerRef = `kind:${kind};cs:${checkoutSessionId};tg:${String(tgUserId)}`;
  const expiresAt = nowPlusMinutes(90);
  await dbQuery(
    `INSERT INTO activation_tokens (token, plan_id, provider, provider_ref, expires_at) VALUES ($1,$2,$3,$4,$5::timestamptz)`,
    [token, Number(planId), provider, providerRef, expiresAt]
  );
  return token;
}

function parseProviderRef(providerRef = "") {
  const s = String(providerRef || "");
  const out = {};
  for (const part of s.split(";")) {
    const [k, ...rest] = part.split(":");
    if (!k || !rest.length) continue;
    out[String(k).trim()] = rest.join(":").trim();
  }
  return out;
}

async function createPlanCheckoutSession({ user, planCode, priceId, chatId }) {
  if (!BOT_USERNAME) throw new Error("NO_BOT_USERNAME");
  if (!priceId) throw new Error("NO_PRICE_ID");
  const planId = await getPlanIdByCode(planCode);
  if (!planId) throw new Error(`NO_PLAN_ID_FOR_${planCode}`);

  let existingCustomer = null;
  let existingSub = null;
  try {
    const r = await dbQuery(
      `SELECT provider_customer_id, provider_subscription_id FROM subscriptions WHERE user_id=$1 AND status='active' ORDER BY updated_at DESC LIMIT 1`,
      [Number(user.id)]
    );
    if (r.rowCount) {
      existingCustomer = r.rows[0].provider_customer_id || null;
      existingSub = r.rows[0].provider_subscription_id || null;
    }
  } catch {}

  const params = {
    mode: "subscription",
    "line_items[0][price]": priceId,
    "line_items[0][quantity]": "1",
    client_reference_id: String(user.telegram_user_id || user.telegram_id || user.id),
    "metadata[plan_code]": String(planCode),
    "metadata[user_id]": String(user.id),
    "metadata[tg_user_id]": String(user.telegram_user_id || ""),
    "metadata[chat_id]": String(chatId || ""),
    ...(existingCustomer ? { customer: existingCustomer } : {}),
    ...(existingSub ? { "subscription_data[metadata][upgrade_from]": existingSub } : {}),
  };

  params.success_url = `https://t.me/${BOT_USERNAME}?start=act_TOKEN_REPLACE`;
  params.cancel_url = `https://t.me/${BOT_USERNAME}`;

  const session = await stripePostForm("/v1/checkout/sessions", params);
  if (!session?.id || !session?.url) throw new Error("STRIPE_SESSION_CREATE_FAILED");

  const token = await createActivationToken({ planId, kind: "plan", checkoutSessionId: session.id, tgUserId: user.telegram_user_id });

  try {
    await stripePostForm(`/v1/checkout/sessions/${encodeURIComponent(session.id)}`, {
      success_url: `https://t.me/${BOT_USERNAME}?start=act_${token}`,
    });
  } catch {}

  return { url: session.url, token, planId };
}

async function createAddon10CheckoutSession({ user, chatId }) {
  if (!BOT_USERNAME) throw new Error("NO_BOT_USERNAME");
  if (!PRICE_ADDON10) throw new Error("NO_PRICE_ADDON10");

  const platinumId = await getPlanIdByCode("platinum");
  if (!platinumId) throw new Error("NO_PLATINUM_PLAN_ID");

  const ent = await getUserEntitlementsByTelegramId(user.telegram_user_id);
  const code = String(ent?.plan_code || "").toLowerCase();
  if (code !== "platinum") throw new Error("ADDON_ONLY_PLATINUM");

  let existingCustomer = null;
  try {
    const r = await dbQuery(
      `SELECT provider_customer_id FROM subscriptions WHERE user_id=$1 AND status='active' ORDER BY updated_at DESC LIMIT 1`,
      [Number(user.id)]
    );
    if (r.rowCount) existingCustomer = r.rows[0].provider_customer_id || null;
  } catch {}

  const params = {
    mode: "subscription",
    "line_items[0][price]": PRICE_ADDON10,
    "line_items[0][quantity]": "1",
    client_reference_id: String(user.telegram_user_id || user.id),
    "metadata[kind]": "addon10",
    "metadata[user_id]": String(user.id),
    "metadata[tg_user_id]": String(user.telegram_user_id || ""),
    "metadata[chat_id]": String(chatId || ""),
    ...(existingCustomer ? { customer: existingCustomer } : {}),
  };

  params.success_url = `https://t.me/${BOT_USERNAME}?start=act_TOKEN_REPLACE`;
  params.cancel_url = `https://t.me/${BOT_USERNAME}`;

  const session = await stripePostForm("/v1/checkout/sessions", params);
  if (!session?.id || !session?.url) throw new Error("STRIPE_SESSION_CREATE_FAILED");

  const token = await createActivationToken({ planId: platinumId, kind: "addon10", checkoutSessionId: session.id, tgUserId: user.telegram_user_id });

  try {
    await stripePostForm(`/v1/checkout/sessions/${encodeURIComponent(session.id)}`, {
      success_url: `https://t.me/${BOT_USERNAME}?start=act_${token}`,
    });
  } catch {}

  return { url: session.url, token };
}


// ---- Panel <-> Telegram language sync (single-user chats) ----
function __normLang(x) {
  const raw = String(x || "").trim().toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  try {
    if (Array.isArray(FYD_SUPPORTED_LANGS) && FYD_SUPPORTED_LANGS.some((l) => l.code === base)) return base;
  } catch {}
  return "";
}

async function getUserLangFromDb(user) {
  try {
    const v1 = __normLang(user?.lang || "");
    if (v1) return v1;

    const uid = user?.id ? Number(user.id) : 0;
    if (!uid) return null;

    const r = await dbQuery("SELECT language AS lang FROM public.users WHERE id=$1 LIMIT 1", [uid]).catch(() => ({ rows: [] }));
    const v2 = __normLang(r?.rows?.[0]?.lang || "");
    return v2 || null;
  } catch {
    return null;
  }
}

async function getLang(chatId, user) {
  // 1) Source of truth: users.lang (shared with Panel)
  const dbLang = await getUserLangFromDb(user);
  if (dbLang) return dbLang;

  // 2) Migrate old chat_notifications.language -> users.lang (one-time)
  try {
    const q = await dbQuery(
      "SELECT language FROM chat_notifications WHERE chat_id=$1 AND user_id=$2 LIMIT 1",
      [String(chatId), Number(user.id)]
    ).catch(() => ({ rows: [] }));

    const legacy = __normLang(q?.rows?.[0]?.language || "");
    if (legacy) {
      await dbQuery(
        "UPDATE users SET lang=$2, updated_at=NOW() WHERE id=$1 AND (lang IS NULL OR lang='')",
        [Number(user.id), legacy]
      ).catch(() => {});
      return legacy;
    }
  } catch {}

  // 3) Fallback: Telegram app language_code (and persist if empty)
  const guess = __normLang(user?.language_code || user?.language || "") || FYD_DEFAULT_LANG;
  if (guess && user?.id) {
    await dbQuery(
      "UPDATE users SET lang=$2, updated_at=NOW() WHERE id=$1 AND (lang IS NULL OR lang='')",
      [Number(user.id), guess]
    ).catch(() => {});
  }
  return guess;
}

async function setLang(chatId, user, langCode) {
  const lang = __normLang(langCode) || FYD_DEFAULT_LANG;

  // users.lang = shared setting (Panel <-> Telegram)
  await dbQuery("UPDATE users SET lang=$2, updated_at=NOW() WHERE id=$1", [Number(user.id), lang]).catch(() => {});

  // backward-compat (if column exists)
  await dbQuery("UPDATE users SET language=$2, updated_at=NOW() WHERE id=$1", [Number(user.id), lang]).catch(() => {});

  // keep per-chat language in sync
  await ensureChatNotificationsRowDb(String(chatId), user.id);
  await dbQuery(
    "UPDATE chat_notifications SET language=$3, updated_at=NOW() WHERE chat_id=$1 AND user_id=$2",
    [String(chatId), Number(user.id), lang]
  ).catch(() => {});

  return lang;
}

// /lang
async function handleLang(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);
  const current = langLabel(lang);
  await tgSend(chatId, `${t(lang, "choose_language")}\n${t(lang, "language_current", { language: escapeHtml(current) })}`, {
    reply_markup: buildLanguageKeyboard(),
  });
}

// /help
async function handleHelp(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);

  // ZAWSZE wysy≈Çaj pe≈Çnego helpa (je≈õli brakuje t≈Çumaczenia, t() zfallbackuje do EN)
  await tgSend(chatId, t(lang, "help_text"));
}



async function handlePlans(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);
  const L = String(lang || "en").replace("_", "-").split("-")[0];

  const ADDON_DESC = {
    pl: "‚ûï Addon +10: +10 link√≥w oraz +100 limitu historii.\nOtw√≥rz p≈Çatno≈õƒá poni≈ºej:",
    en: "‚ûï Addon +10: +10 links and +100 history limit.\nOpen the payment below:",
    de: "‚ûï Add-on +10: +10 Links und +100 Verlaufslimit.\nZahlungslink unten:",
    fr: "‚ûï Add-on +10 : +10 liens et +100 limite d'historique.\nOuvrez le paiement ci-dessous :",
    es: "‚ûï Addon +10: +10 enlaces y +100 de l√≠mite de historial.\nAbre el pago abajo:",
    it: "‚ûï Add-on +10: +10 link e +100 limite cronologia.\nApri il pagamento qui sotto:",
    pt: "‚ûï Add-on +10: +10 links e +100 de limite de hist√≥rico.\nAbra o pagamento abaixo:",
    ro: "‚ûï Add-on +10: +10 linkuri »ôi +100 la limita de istoric.\nDeschide plata mai jos:",
    nl: "‚ûï Add-on +10: +10 links en +100 historielimiet.\nOpen de betaling hieronder:",
    cs: "‚ûï Add-on +10: +10 odkaz≈Ø a +100 limit historie.\nOtev≈ôete platbu n√≠≈æe:",
    sk: "‚ûï Add-on +10: +10 odkazov a +100 limit hist√≥rie.\nOtvorte platbu ni≈æ≈°ie:",
  };

  const ERR = {
    pl: "‚ùå Nie uda≈Ço siƒô wygenerowaƒá linku p≈Çatno≈õci. Spr√≥buj ponownie za chwilƒô.",
    en: "‚ùå Couldn't generate the payment link. Please try again in a moment.",
    de: "‚ùå Zahlungslink konnte nicht erstellt werden. Bitte versuche es gleich noch einmal.",
    fr: "‚ùå Impossible de g√©n√©rer le lien de paiement. R√©essayez dans un instant.",
    es: "‚ùå No pude generar el enlace de pago. Int√©ntalo de nuevo en un momento.",
    it: "‚ùå Impossibile generare il link di pagamento. Riprova tra un attimo.",
    pt: "‚ùå N√£o foi poss√≠vel gerar o link de pagamento. Tente novamente em instantes.",
    ro: "‚ùå Nu am putut genera linkul de platƒÉ. √éncearcƒÉ din nou √Æn c√¢teva momente.",
    nl: "‚ùå Kon de betaallink niet genereren. Probeer het zo nog eens.",
    cs: "‚ùå Nepoda≈ôilo se vygenerovat platebn√≠ odkaz. Zkuste to za chv√≠li znovu.",
    sk: "‚ùå Nepodarilo sa vygenerova≈• platobn√Ω odkaz. Sk√∫ste to o chv√≠ƒæu znova.",
  };

  const PLANS_TXT = {
    pl: "üí≥ Wybierz plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nPo op≈Çaceniu wr√≥cisz do bota i aktywacja zrobi siƒô automatycznie.",
    en: "üí≥ Choose a plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nAfter checkout you'll return to the bot and activation will be automatic.",
    de: "üí≥ W√§hle einen Plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nNach dem Checkout kehrst du zum Bot zur√ºck und die Aktivierung passiert automatisch.",
    fr: "üí≥ Choisissez un abonnement :\n\n‚Ä¢ Starter : /starter\n‚Ä¢ Growth : /growth\n‚Ä¢ Platinum : /platinum\n\nApr√®s le paiement, vous reviendrez au bot et l‚Äôactivation sera automatique.",
    es: "üí≥ Elige un plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nTras el pago volver√°s al bot y la activaci√≥n ser√° autom√°tica.",
    it: "üí≥ Scegli un piano:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nDopo il pagamento tornerai al bot e l‚Äôattivazione sar√† automatica.",
    pt: "üí≥ Escolha um plano:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nAp√≥s o pagamento voc√™ volta ao bot e a ativa√ß√£o ser√° autom√°tica.",
    ro: "üí≥ Alege un plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nDupƒÉ platƒÉ revii √Æn bot »ôi activarea va fi automatƒÉ.",
    nl: "üí≥ Kies een plan:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nNa betaling ga je terug naar de bot en wordt activatie automatisch gedaan.",
    cs: "üí≥ Vyberte pl√°n:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nPo platbƒõ se vr√°t√≠te do bota a aktivace probƒõhne automaticky.",
    sk: "üí≥ Vyberte pl√°n:\n\n‚Ä¢ Starter: /starter\n‚Ä¢ Growth: /growth\n‚Ä¢ Platinum: /platinum\n\nPo platbe sa vr√°tite do bota a aktiv√°cia prebehne automaticky.",
  };

  const planCode = String((user && (user.plan_code || user.plan || "")) || "").toLowerCase();
  const active = (typeof isPlanActive === "function") ? isPlanActive(user) : true;

  if (active && planCode === "platinum") {
    try {
      const resp = await createAddon10CheckoutSession({ user, chatId });
      const url = resp && resp.url ? String(resp.url) : "";
      if (!url) throw new Error("missing url");
      const desc = ADDON_DESC[L] || ADDON_DESC.en;
      await tgSend(chatId, "‚úÖ " + planLabel("platinum") + "\n\n" + desc + "\n\n" + escapeHtml(url));
    } catch (e) {
      await tgSend(chatId, ERR[L] || ERR.en);
    }
    return;
  }

  await tgSend(chatId, PLANS_TXT[L] || PLANS_TXT.en);
}

async function handleBuyPlan(msg, user, code) {
  const chatId = String(msg.chat.id);
  const priceId = code === "starter" ? PRICE_STARTER : code === "growth" ? PRICE_GROWTH : code === "platinum" ? PRICE_PLATINUM : "";
  if (!STRIPE_SECRET_KEY || !priceId || !BOT_USERNAME) {
    await tgSend(chatId, "‚ùå Sales config missing.");
    return;
  }
  const lang = await getLang(chatId, user);
  try {
    const { url } = await createPlanCheckoutSession({ user, planCode: code, priceId, chatId });
    await tgSend(chatId, `${t(lang, "language_current", { language: escapeHtml(langLabel(lang)) })}\n\n${escapeHtml(url)}`);
  } catch (e) {
    await tgSend(chatId, `‚ùå ${escapeHtml(getErrorText(e))}`);
  }
}

async function handleAddon10(msg, user) {
  const chatId = String(msg.chat.id);
  if (!STRIPE_SECRET_KEY || !PRICE_ADDON10 || !BOT_USERNAME) {
    await tgSend(chatId, "‚ùå Addon config missing.");
    return;
  }
  try {
    const { url } = await createAddon10CheckoutSession({ user, chatId });
    await tgSend(chatId, escapeHtml(url));
  } catch (e) {
    const m = String(e?.message || e);
    if (m === "ADDON_ONLY_PLATINUM") {
      await tgSend(chatId, "‚õî Addon +10 is Platinum only.");
      return;
    }
    await tgSend(chatId, `‚ùå ${escapeHtml(m)}`);
  }
}

async function handleLista(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);
  const links = await getLinksByUserId(user.id, true);

  if (!links.length) {
    await tgSend(chatId, lang === "pl"
      ? "Nie masz jeszcze ≈ºadnych w≈ÇƒÖczonych link√≥w."
      : "You don't have any enabled links yet."
    );
    return;
  }

  // label per link (opcjonalne, dla lepszego zarzƒÖdzania)
  let labelMap = new Map();
  try {
    const ids = links.map((r) => Number(r.id)).filter((x) => Number.isFinite(x) && x > 0);
    if (ids.length) {
      const lr = await pool.query(
        "SELECT id, COALESCE(label,'') AS label FROM links WHERE user_id=$1 AND id = ANY($2::int[])",
        [user.id, ids]
      );
      labelMap = new Map((lr.rows || []).map((r) => [Number(r.id), String(r.label || "").trim()]));
    }
  } catch (e) {}

  let text = lang === "pl"
    ? `üìã Aktywne monitorowane linki:

`
    : `üìã Active monitored links:

`;

  for (const row of links) {
    const label = (labelMap.get(Number(row.id)) || "").trim();
    const title = label || row.name || (lang === "pl" ? "(bez nazwy)" : "(no name)");
    text += `ID <b>${row.id}</b> ‚Äî ${escapeHtml(title)}
<code>${escapeHtml(row.url)}</code>

`;
  }

  text += lang === "pl"
    ? `Wy≈ÇƒÖcz: <code>/usun ID</code>
np. <code>/usun 18</code>`
    : `Disable: <code>/remove ID</code>
E.g. <code>/remove 18</code>`;

  /* __FYD_LISTA_CHUNK_V1__ */
  const __MAX = 3500; // bezpiecznie < 4096
  const __lines = String(text || "").split("\n");
  let __buf = "";
  for (const __ln of __lines) {
    const __add = (__buf ? "\n" : "") + __ln;
    if ((__buf.length + __add.length) > __MAX) {
      if (__buf) await tgSend(chatId, __buf);
      __buf = __ln;
      continue;
    }
    __buf += __add;
  }
  if (__buf) await tgSend(chatId, __buf);
  /* __FYD_LISTA_CHUNK_V1__ END */
}

async function handleUsun(msg, user, argText) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);
  const id = parseInt(argText, 10);
  if (!id) { await tgSend(chatId, lang === "pl" ? "Podaj ID linku, np.:\n<code>/usun 18</code>" : "Provide link ID, e.g.:\n<code>/remove 18</code>"); return; }
  const row = await deactivateLinkForUserId(id, user.id);
  if (!row) { await tgSend(chatId, lang === "pl" ? `Nie znalaz≈Çem linku <b>${id}</b> na Twoim koncie. U≈ºyj /lista.` : `I can't find link <b>${id}</b> on your account. Use /list.`); return; }
  await tgSend(chatId, lang === "pl"
    ? `‚úÖ Wy≈ÇƒÖczy≈Çem monitorowanie:\n\nID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}\n<code>${escapeHtml(row.url || "")}</code>`
    : `‚úÖ Disabled monitoring:\n\nID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(no name)")}\n<code>${escapeHtml(row.url || "")}</code>`
  );
}

async function handleDodaj(msg, user, argText) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);

  if (!argText) {
    await tgSend(chatId, lang === "pl"
      ? "U≈ºycie:\n<code>/dodaj &lt;url&gt; [nazwa]</code>\n\nPrzyk≈Çad:\n<code>/dodaj https://www.olx.pl/oferty/?q=iphone14 iPhone 14 OLX</code>"
      : "Usage:\n<code>/add &lt;url&gt; [name]</code>\n\nExample:\n<code>/add https://www.olx.pl/oferty/?q=iphone14 iPhone 14 OLX</code>"
    );
    return;
  }

  const parts = argText.split(/\s+/);
  const url = parts[0];
  const name = parts.slice(1).join(" ") || null;

  if (!url || !/^https?:\/\//i.test(url)) {
    await tgSend(chatId, lang === "pl"
      ? "Pierwszy parametr musi byƒá URL, np. <code>/dodaj https://www.olx.pl/oferty/?q=iphone14</code>"
      : "First parameter must be a URL, e.g. <code>/add https://www.olx.pl/oferty/?q=iphone14</code>"
    );
    return;
  }

  const ent = await getUserEntitlementsByTelegramId(user.telegram_user_id);
  const limit = Number(ent?.links_limit_total ?? 0);
  if (!ent || limit <= 0) {
    await tgSend(chatId, lang === "pl" ? "‚ùå Nie masz aktywnego planu. U≈ºyj /plany ≈ºeby kupiƒá plan." : "‚ùå You don't have an active plan. Use /plans to buy a plan.");
    return;
  }

  const totalLinks = await countActiveLinksForUserId(user.id);
  if (totalLinks >= limit) {
    await tgSend(chatId, lang === "pl" ? `‚ùå OsiƒÖgniƒôto limit link√≥w: <b>${totalLinks}/${limit}</b>` : `‚ùå Link limit reached: <b>${totalLinks}/${limit}</b>`);
    return;
  }

  const row = await insertLinkForUserId(user.id, name, url);
  await tgSend(chatId,
    (lang === "pl"
      ? `‚úÖ Doda≈Çem nowy link:\n\nID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}\n<code>${escapeHtml(row.url)}</code>\n\nLinki (≈ÇƒÖcznie): ${totalLinks + 1}/${limit}\n\nSprawd≈∫: <code>/lista</code>`
      : `‚úÖ Added a new link:\n\nID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(no name)")}\n<code>${escapeHtml(row.url)}</code>\n\nLinks total: ${totalLinks + 1}/${limit}\n\nCheck: <code>/list</code>`
    )
  );
}


// __FYD_Q_HELPER_V2__
async function __fydQ(sql, params = []) {
  if (typeof q === "function") return await q(sql, params);
  if (typeof pool !== "undefined" && pool && typeof pool.query === "function") return await pool.query(sql, params);
  throw new Error("__fydQ: no DB helper found");
}

async function handlePanel(...args) {
  const chatId = args[0];
  let user = args[1] || {};

  // spr√≥buj dope≈Çniƒá usera/trial (je≈õli helper istnieje)
  try {
    if (typeof __fydEnsureTrialForUser === "function") {
      const maybe = await __fydEnsureTrialForUser(user);
      if (maybe) user = maybe;
    }
  } catch {}

  const lang = String(user?.lang || "").toLowerCase();
  const isPl = lang.startsWith("pl");

  let userId = Number(user?.id || 0);
  const tgId = user?.telegram_user_id ? String(user.telegram_user_id) : "";

  if (!userId && tgId) {
    try {
      const r = await __fydQ("SELECT id FROM users WHERE telegram_user_id=$1 LIMIT 1", [tgId]);
      if (r?.rows?.[0]?.id) userId = Number(r.rows[0].id);
    } catch {}
  }

  if (!userId) {
    await tgSend(chatId, isPl ? "B≈ÇƒÖd: nie mogƒô ustaliƒá user_id do panelu." : "Error: cannot resolve user_id for panel.");
    return;
  }

  const tok = randomBytes(24).toString("hex");
  await __fydQ(
    "INSERT INTO panel_login_tokens (token, user_id, created_at, expires_at) VALUES ($1, $2, NOW(), NOW() + INTERVAL '10 minutes')",
    [tok, userId]
  );

  const url = `https://panel.findyourdeal.app/api/auth/login?token=${tok}`;

  // UWAGA: URL musi byƒá w osobnej linii -> wtedy tgSend NIE dopisze go drugi raz
  const msg = "Panel:\n" + url + "\n" + (isPl ? "Token wa≈ºny 10 minut." : "Token valid for 10 minutes.");
  await tgSend(chatId, msg);
}









async function handleStatus(msg, user) {
  const chatId = String(msg.chat.id);
  const langRaw = await getLang(chatId, user).catch(() => "en");
  const lang = String(langRaw || "en").toLowerCase();
  const L = lang.includes("-") ? lang.split("-")[0] : lang;

  const esc = (x) =>
    String(x ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

  const fmtDay = () =>
    new Intl.DateTimeFormat("en-CA", {
      timeZone: "Europe/Warsaw",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    }).format(new Date());

  const fmtDate = (dt) => {
    const d = new Date(dt);
    if (Number.isNaN(d.getTime())) return "";
    const parts = new Intl.DateTimeFormat("en-GB", {
      timeZone: "Europe/Warsaw",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    }).formatToParts(d);
    const get = (t) => (parts.find((p) => p.type === t)?.value || "");
    const dd = get("day"), mm = get("month"), yyyy = get("year"), hh = get("hour"), mi = get("minute");
    if (L === "pl") return `${dd}/${mm}/${yyyy} godz. ${hh}:${mi}`;
    return `${dd}/${mm}/${yyyy}, ${hh}:${mi}`;
  };

  const S = {
    en: {
      title: "‚ÑπÔ∏è Bot status",
      plan: (p, until) => `Plan: ${p}${until ? ` (until ${until})` : ""}`,
      active: (a, lim) => `Active searches (enabled): ${a}/${lim}`,
      total: (t, lim) => `Total searches (in DB): ${t}/${lim}`,
      addons: (n) => `Add-ons (+10): ${n}`,
      history: (n) => `Total history limit: ${n}`,
      daily: (n) => `Daily notifications limit: ${n}`,
      notifOn: "‚úÖ Notifications ENABLED",
      notifOff: "‚õî Notifications DISABLED",
      mode: (m) => `Default mode in this chat: ${m}`,
      today: (c, lim) => `Today's notifications: ${c}/${lim}`,
      change: "Change: /on /off /single /batch",
      quietOff: "Quiet hours: disabled",
      quietOn: (f, t) => `Quiet hours: ENABLED, hours ${f}:00‚Äì${t}:00`,
      linksHdr: "Enabled searches:",
      perLink: "Per-link mode: /single_ID /batch_ID /off_ID /on_ID (e.g. /batch_18)",
      mSingle: "single",
      mBatch: "batch",
    },
    pl: {
      title: "‚ÑπÔ∏è Status bota",
      plan: (p, until) => `Plan: ${p}${until ? ` (do ${until})` : ""}`,
      active: (a, lim) => `Aktywne wyszukiwania (w≈ÇƒÖczone): ${a}/${lim}`,
      total: (t, lim) => `≈ÅƒÖcznie wyszukiwa≈Ñ (w bazie): ${t}/${lim}`,
      addons: (n) => `Dodatki (addon +10): ${n}`,
      history: (n) => `≈ÅƒÖczny limit ofert (historia): ${n}`,
      daily: (n) => `Limit dziennych powiadomie≈Ñ: ${n}`,
      notifOn: "‚úÖ Powiadomienia W≈ÅƒÑCZONE",
      notifOff: "‚õî Powiadomienia WY≈ÅƒÑCZONE",
      mode: (m) => `Tryb domy≈õlny na tym czacie: ${m}`,
      today: (c, lim) => `Dzisiejsze powiadomienia: ${c}/${lim}`,
      change: "Zmiana: /on /off /pojedyncze /zbiorcze",
      quietOff: "Cisza nocna: wy≈ÇƒÖczona",
      quietOn: (f, t) => `Cisza nocna: W≈ÅƒÑCZONA, godziny ${f}:00‚Äì${t}:00`,
      linksHdr: "W≈ÇƒÖczone wyszukiwania:",
      perLink: "Tryb per link: /pojedyncze_ID /zbiorcze_ID /off_ID /on_ID (np. /zbiorcze_18)",
      mSingle: "pojedynczo",
      mBatch: "zbiorczo",
    },
    de: { ...null },
    fr: { ...null },
    es: { ...null },
    it: { ...null },
    pt: { ...null },
    ro: { ...null },
    nl: { ...null },
    cs: { ...null },
    sk: { ...null },
  };

  // pe≈Çne t≈Çumaczenia labeli dla pozosta≈Çych jƒôzyk√≥w (≈ºeby /status nie by≈Ç EN)
  S.de = { ...S.en,
    title:"‚ÑπÔ∏è Bot-Status",
    plan:(p,u)=>`Plan: ${p}${u?` (bis ${u})`:""}`,
    active:(a,lim)=>`Aktive Suchen (aktiv): ${a}/${lim}`,
    total:(t,lim)=>`Suchen insgesamt (in DB): ${t}/${lim}`,
    addons:(n)=>`Add-ons (+10): ${n}`,
    history:(n)=>`Gesamtlimit Verlauf: ${n}`,
    daily:(n)=>`Tageslimit Benachrichtigungen: ${n}`,
    notifOn:"‚úÖ Benachrichtigungen AKTIVIERT",
    notifOff:"‚õî Benachrichtigungen DEAKTIVIERT",
    mode:(m)=>`Standardmodus in diesem Chat: ${m}`,
    today:(c,lim)=>`Benachrichtigungen heute: ${c}/${lim}`,
    change:"√Ñndern: /on /off /single /batch",
    quietOff:"Ruhezeiten: deaktiviert",
    quietOn:(f,t)=>`Ruhezeiten: AKTIV, ${f}:00‚Äì${t}:00`,
    linksHdr:"Aktive Suchen:",
    perLink:"Pro-Link-Modus: /single_ID /batch_ID /off_ID /on_ID (z.B. /batch_18)",
    mSingle:"einzeln", mBatch:"geb√ºndelt"
  };
  S.fr = { ...S.en,
    title:"‚ÑπÔ∏è Statut du bot",
    plan:(p,u)=>`Plan : ${p}${u?` (jusqu‚Äôau ${u})`:""}`,
    active:(a,lim)=>`Recherches actives (activ√©es) : ${a}/${lim}`,
    total:(t,lim)=>`Recherches totales (en base) : ${t}/${lim}`,
    addons:(n)=>`Add-ons (+10) : ${n}`,
    history:(n)=>`Limite d‚Äôhistorique totale : ${n}`,
    daily:(n)=>`Limite quotidienne de notifications : ${n}`,
    notifOn:"‚úÖ Notifications ACTIV√âES",
    notifOff:"‚õî Notifications D√âSACTIV√âES",
    mode:(m)=>`Mode par d√©faut dans ce chat : ${m}`,
    today:(c,lim)=>`Notifications aujourd‚Äôhui : ${c}/${lim}`,
    change:"Changer : /on /off /single /batch",
    quietOff:"Heures silencieuses : d√©sactiv√©es",
    quietOn:(f,t)=>`Heures silencieuses : ACTIV√âES, ${f}:00‚Äì${t}:00`,
    linksHdr:"Recherches activ√©es :",
    perLink:"Mode par lien : /single_ID /batch_ID /off_ID /on_ID (ex. /batch_18)",
    mSingle:"individuel", mBatch:"group√©"
  };
  S.es = { ...S.en,
    title:"‚ÑπÔ∏è Estado del bot",
    plan:(p,u)=>`Plan: ${p}${u?` (hasta ${u})`:""}`,
    active:(a,lim)=>`B√∫squedas activas (habilitadas): ${a}/${lim}`,
    total:(t,lim)=>`B√∫squedas totales (en BD): ${t}/${lim}`,
    addons:(n)=>`Add-ons (+10): ${n}`,
    history:(n)=>`L√≠mite total de historial: ${n}`,
    daily:(n)=>`L√≠mite diario de notificaciones: ${n}`,
    notifOn:"‚úÖ Notificaciones ACTIVADAS",
    notifOff:"‚õî Notificaciones DESACTIVADAS",
    mode:(m)=>`Modo por defecto en este chat: ${m}`,
    today:(c,lim)=>`Notificaciones hoy: ${c}/${lim}`,
    change:"Cambiar: /on /off /single /batch",
    quietOff:"Horas silenciosas: desactivadas",
    quietOn:(f,t)=>`Horas silenciosas: ACTIVADAS, ${f}:00‚Äì${t}:00`,
    linksHdr:"B√∫squedas habilitadas:",
    perLink:"Modo por enlace: /single_ID /batch_ID /off_ID /on_ID (ej. /batch_18)",
    mSingle:"individual", mBatch:"agrupado"
  };
  S.it = { ...S.en,
    title:"‚ÑπÔ∏è Stato del bot",
    plan:(p,u)=>`Piano: ${p}${u?` (fino al ${u})`:""}`,
    active:(a,lim)=>`Ricerche attive (abilitate): ${a}/${lim}`,
    total:(t,lim)=>`Ricerche totali (in DB): ${t}/${lim}`,
    addons:(n)=>`Add-on (+10): ${n}`,
    history:(n)=>`Limite totale storico: ${n}`,
    daily:(n)=>`Limite giornaliero notifiche: ${n}`,
    notifOn:"‚úÖ Notifiche ABILITATE",
    notifOff:"‚õî Notifiche DISABILITATE",
    mode:(m)=>`Modalit√† predefinita in questa chat: ${m}`,
    today:(c,lim)=>`Notifiche oggi: ${c}/${lim}`,
    change:"Cambia: /on /off /single /batch",
    quietOff:"Ore silenziose: disattivate",
    quietOn:(f,t)=>`Ore silenziose: ABILITATE, ${f}:00‚Äì${t}:00`,
    linksHdr:"Ricerche abilitate:",
    perLink:"Modalit√† per link: /single_ID /batch_ID /off_ID /on_ID (es. /batch_18)",
    mSingle:"singolo", mBatch:"raggruppato"
  };
  S.pt = { ...S.en,
    title:"‚ÑπÔ∏è Status do bot",
    plan:(p,u)=>`Plano: ${p}${u?` (at√© ${u})`:""}`,
    active:(a,lim)=>`Monitoramentos ativos (habilitados): ${a}/${lim}`,
    total:(t,lim)=>`Monitoramentos totais (no BD): ${t}/${lim}`,
    addons:(n)=>`Add-ons (+10): ${n}`,
    history:(n)=>`Limite total do hist√≥rico: ${n}`,
    daily:(n)=>`Limite di√°rio de notifica√ß√µes: ${n}`,
    notifOn:"‚úÖ Notifica√ß√µes ATIVADAS",
    notifOff:"‚õî Notifica√ß√µes DESATIVADAS",
    mode:(m)=>`Modo padr√£o neste chat: ${m}`,
    today:(c,lim)=>`Notifica√ß√µes hoje: ${c}/${lim}`,
    change:"Alterar: /on /off /single /batch",
    quietOff:"Horas de sil√™ncio: desativadas",
    quietOn:(f,t)=>`Horas de sil√™ncio: ATIVADAS, ${f}:00‚Äì${t}:00`,
    linksHdr:"Monitoramentos habilitados:",
    perLink:"Modo por link: /single_ID /batch_ID /off_ID /on_ID (ex. /batch_18)",
    mSingle:"individual", mBatch:"agrupado"
  };
  S.ro = { ...S.en,
    title:"‚ÑπÔ∏è Status bot",
    plan:(p,u)=>`Plan: ${p}${u?` (p√¢nƒÉ la ${u})`:""}`,
    active:(a,lim)=>`MonitorizƒÉri active (activate): ${a}/${lim}`,
    total:(t,lim)=>`MonitorizƒÉri totale (√Æn DB): ${t}/${lim}`,
    addons:(n)=>`Add-on (+10): ${n}`,
    history:(n)=>`LimitƒÉ totalƒÉ istoric: ${n}`,
    daily:(n)=>`LimitƒÉ zilnicƒÉ notificƒÉri: ${n}`,
    notifOn:"‚úÖ NotificƒÉri ACTIVATE",
    notifOff:"‚õî NotificƒÉri DEZACTIVATE",
    mode:(m)=>`Mod implicit √Æn acest chat: ${m}`,
    today:(c,lim)=>`NotificƒÉri azi: ${c}/${lim}`,
    change:"SchimbƒÉ: /on /off /single /batch",
    quietOff:"Ore de lini»ôte: dezactivate",
    quietOn:(f,t)=>`Ore de lini»ôte: ACTIVATE, ${f}:00‚Äì${t}:00`,
    linksHdr:"CƒÉutƒÉri activate:",
    perLink:"Mod per link: /single_ID /batch_ID /off_ID /on_ID (ex. /batch_18)",
    mSingle:"individual", mBatch:"grupat"
  };
  S.nl = { ...S.en,
    title:"‚ÑπÔ∏è Botstatus",
    plan:(p,u)=>`Plan: ${p}${u?` (tot ${u})`:""}`,
    active:(a,lim)=>`Actieve zoekopdrachten (aan): ${a}/${lim}`,
    total:(t,lim)=>`Totaal (in DB): ${t}/${lim}`,
    addons:(n)=>`Add-ons (+10): ${n}`,
    history:(n)=>`Totale geschiedenisl limiet: ${n}`,
    daily:(n)=>`Dagelijkse meldingenlimiet: ${n}`,
    notifOn:"‚úÖ Meldingen AAN",
    notifOff:"‚õî Meldingen UIT",
    mode:(m)=>`Standaardmodus in deze chat: ${m}`,
    today:(c,lim)=>`Meldingen vandaag: ${c}/${lim}`,
    change:"Wijzig: /on /off /single /batch",
    quietOff:"Stilte-uren: uit",
    quietOn:(f,t)=>`Stilte-uren: AAN, ${f}:00‚Äì${t}:00`,
    linksHdr:"Ingeschakelde zoekopdrachten:",
    perLink:"Per-link-modus: /single_ID /batch_ID /off_ID /on_ID (bijv. /batch_18)",
    mSingle:"individueel", mBatch:"gebundeld"
  };
  S.cs = { ...S.en,
    title:"‚ÑπÔ∏è Stav bota",
    plan:(p,u)=>`Pl√°n: ${p}${u?` (do ${u})`:""}`,
    active:(a,lim)=>`Aktivn√≠ hled√°n√≠ (zapnuto): ${a}/${lim}`,
    total:(t,lim)=>`Celkem (v DB): ${t}/${lim}`,
    addons:(n)=>`Dopl≈àky (+10): ${n}`,
    history:(n)=>`Celkov√Ω limit historie: ${n}`,
    daily:(n)=>`Denn√≠ limit notifikac√≠: ${n}`,
    notifOn:"‚úÖ Notifikace ZAPNUT√â",
    notifOff:"‚õî Notifikace VYPNUT√â",
    mode:(m)=>`V√Ωchoz√≠ re≈æim v tomto chatu: ${m}`,
    today:(c,lim)=>`Notifikace dnes: ${c}/${lim}`,
    change:"Zmƒõna: /on /off /single /batch",
    quietOff:"Tich√Ω re≈æim: vypnut√Ω",
    quietOn:(f,t)=>`Tich√Ω re≈æim: ZAPNUT√ù, ${f}:00‚Äì${t}:00`,
    linksHdr:"Zapnut√© hled√°n√≠:",
    perLink:"Re≈æim pro odkaz: /single_ID /batch_ID /off_ID /on_ID (nap≈ô. /batch_18)",
    mSingle:"jednotlivƒõ", mBatch:"hromadnƒõ"
  };
  S.sk = { ...S.en,
    title:"‚ÑπÔ∏è Status bota",
    plan:(p,u)=>`Pl√°n: ${p}${u?` (do ${u})`:""}`,
    active:(a,lim)=>`Akt√≠vne hƒæadania (zapnut√©): ${a}/${lim}`,
    total:(t,lim)=>`Celkovo (v DB): ${t}/${lim}`,
    addons:(n)=>`Doplnky (+10): ${n}`,
    history:(n)=>`Celkov√Ω limit hist√≥rie: ${n}`,
    daily:(n)=>`Denn√Ω limit notifik√°ci√≠: ${n}`,
    notifOn:"‚úÖ Notifik√°cie ZAPNUT√â",
    notifOff:"‚õî Notifik√°cie VYPNUT√â",
    mode:(m)=>`Predvolen√Ω re≈æim v tomto chate: ${m}`,
    today:(c,lim)=>`Notifik√°cie dnes: ${c}/${lim}`,
    change:"Zmena: /on /off /single /batch",
    quietOff:"Tich√© hodiny: vypnut√©",
    quietOn:(f,t)=>`Tich√© hodiny: ZAPNUT√â, ${f}:00‚Äì${t}:00`,
    linksHdr:"Zapnut√© hƒæadania:",
    perLink:"Re≈æim pre odkaz: /single_ID /batch_ID /off_ID /on_ID (napr. /batch_18)",
    mSingle:"jednotlivo", mBatch:"hromadne"
  };

  const T = S[L] || S.en;

  // DB helper (dzia≈Ça czy masz dbQuery, czy tylko pool)
  const q = async (sql, params = []) => {
    if (typeof dbQuery === "function") return await dbQuery(sql, params);
    if (typeof pool !== "undefined" && pool && typeof pool.query === "function") return await pool.query(sql, params);
    throw new Error("No dbQuery/pool available");
  };

  // entitlements (je≈õli istnieje)
  const ent = await getUserEntitlementsByTelegramId(user.telegram_user_id).catch(() => null);
  const planCode = String(ent?.plan_code || user?.plan_code || user?.plan_name || user?.plan || "").toLowerCase();
  const planName = esc(planLabel ? planLabel(planCode || user?.plan_name || "") : (planCode || user?.plan_name || "Plan"));

  const until = ent?.expires_at || user?.expires_at || user?.plan_expires_at || null;
  const untilStr = until ? fmtDate(until) : "";

  // limity (preferuj ent)
  let linksLimit = Number(ent?.links_limit_total ?? ent?.links_limit ?? 0);
  if (!Number.isFinite(linksLimit) || linksLimit <= 0) linksLimit = "?";

  // addon_qty
  let addons = 0;
  try {
    const r = await q(
      `SELECT COALESCE(SUM(COALESCE(addon_qty,0)),0)::int AS n
       FROM subscriptions
       WHERE user_id=$1 AND status='active'`,
      [Number(user.id)]
    );
    addons = Number(r.rows?.[0]?.n ?? 0);
    if (!Number.isFinite(addons) || addons < 0) addons = 0;
  } catch {}

  // daily/history (je≈õli ent nie podaje)
  const baseHistory =
    planCode === "platinum" ? 800 :
    planCode === "growth" || planCode === "pro" ? 700 :
    planCode === "starter" || planCode === "basic" ? 600 :
    planCode === "trial" ? 200 : 0;

  const baseDaily =
    planCode === "platinum" ? 500 :
    planCode === "growth" || planCode === "pro" ? 400 :
    planCode === "starter" || planCode === "basic" ? 200 :
    planCode === "trial" ? 50 : 0;

  let historyLimit = Number(ent?.history_total_limit ?? ent?.history_limit_total ?? ent?.history_limit ?? 0);
  if (!Number.isFinite(historyLimit) || historyLimit <= 0) historyLimit = baseHistory + addons * 100;

  let dailyLimit = Number(ent?.daily_notifications_limit ?? ent?.daily_limit ?? ent?.daily_notifications ?? 0);
  if (!Number.isFinite(dailyLimit) || dailyLimit <= 0) dailyLimit = baseDaily;

  // link counts
  let enabled = 0, total = 0;
  try {
    const r1 = await q(`SELECT COUNT(*)::int AS n FROM links WHERE user_id=$1 AND active=TRUE`, [Number(user.id)]);
    enabled = Number(r1.rows?.[0]?.n ?? 0) || 0;
    const r2 = await q(`SELECT COUNT(*)::int AS n FROM links WHERE user_id=$1`, [Number(user.id)]);
    total = Number(r2.rows?.[0]?.n ?? 0) || 0;
  } catch {}

  // chat notifications
  let notifEnabled = true;
  let chatMode = "single";
  let dailyCount = 0;

  try {
    const r = await q(
      `SELECT enabled, mode, daily_count, daily_count_date
       FROM chat_notifications
       WHERE chat_id=$1 AND user_id=$2
       LIMIT 1`,
      [String(chatId), Number(user.id)]
    );
    const row = r.rows?.[0];
    if (row) {
      notifEnabled = row.enabled !== false;
      chatMode = String(row.mode || "single").toLowerCase() === "batch" ? "batch" : "single";
      dailyCount = Number(row.daily_count ?? 0) || 0;

      const today = fmtDay();
      const d0 = row.daily_count_date
        ? (row.daily_count_date.toISOString ? row.daily_count_date.toISOString().slice(0,10) : String(row.daily_count_date).slice(0,10))
        : "";
      if (d0 && d0 !== today) dailyCount = 0;
    }
  } catch {}

  const modeLabel = (m) => (m === "batch" ? T.mBatch : T.mSingle);

  // quiet hours
  let quietLine = T.quietOff;
  try {
    if (typeof getQuietHours === "function") {
      const qh = await getQuietHours(String(chatId));
      if (qh && qh.quiet_enabled) quietLine = T.quietOn(qh.quiet_from, qh.quiet_to);
    }
  } catch {}

  // links list + per-link mode
  let linksText = "";
  try {
    const r = await q(
      `SELECT id, name, source
       FROM links
       WHERE user_id=$1 AND active=TRUE
       ORDER BY id ASC`,
      [Number(user.id)]
    );

    for (const row of (r.rows || [])) {
      let per = null;
      try {
        const m = await q(
          `SELECT mode
           FROM link_notification_modes
           WHERE user_id=$1 AND chat_id=$2 AND link_id=$3
           ORDER BY updated_at DESC
           LIMIT 1`,
          [Number(user.id), String(chatId), Number(row.id)]
        );
        per = m.rows?.[0]?.mode || null;
      } catch {}

      const eff = per ? String(per).toLowerCase() : chatMode;
      const icon = eff === "off" ? "‚õî" : "‚úÖ";
      const src = String(row.source || "").toUpperCase() || "LINK";
      const name = esc(row.name || "(no name)");
      const mLabel = eff === "off" ? "OFF" : modeLabel(eff === "batch" ? "batch" : "single");
      linksText += `‚Ä¢ ${icon} ${row.id} ‚Äì ${name} (${src}) ‚Äì ${L === "pl" ? "tryb" : "mode"}: ${mLabel}\n`;
    }
  } catch {}

  if (!linksText) linksText = "";

  const out =
    `${T.title}\n\n` +
    `${T.plan(planName, untilStr)}\n\n` +
    `${T.active(enabled, linksLimit)}\n` +
    `${T.total(total, linksLimit)}\n\n` +
    `${T.addons(addons)}\n` +
    `${T.history(historyLimit)}\n` +
    `${T.daily(dailyLimit)}\n\n` +
    `${notifEnabled ? T.notifOn : T.notifOff}\n` +
    `${T.mode(modeLabel(chatMode))}\n` +
    `${T.today(dailyCount, dailyLimit)}\n` +
    `${T.change}\n\n` +
    `${quietLine}\n\n` +
    `${T.linksHdr}\n` +
    (linksText || (L === "pl" ? "(brak)\n" : "(none)\n")) +
    `\n${T.perLink}`;

  // __FYD_STATUS_PLANNAME_FIX_V2__
  let __fydStatusText = out;
  try {
    __fydStatusText = String(__fydStatusText || "");
    // --- FYD: normalize plan label (trial) ---
    try {
      const __tmp = (typeof text === "string" ? text : String(__fydStatusText || ""));
      const __fixed = __tmp
        .replace(/^Plan:\s*Plan\b/m, "Plan: Trial")
        .replace(/^Plan:\s*plan\b/m, "Plan: Trial");
      if (typeof text === "string") text = __fixed;
      __fydStatusText = __fixed;
    } catch {}
  } catch (e) {}
  await tgSend(chatId, __fydStatusText.trim());
}


// ---- FYD: ensure trial for user (safe / schema-aware) ----
async function __fydEnsureTrialForUser(user) {
  try {
    const uid = Number(user?.id || 0);
    if (!uid) return;

    // je≈õli ju≈º ma aktywnƒÖ subskrypcjƒô -> nic nie r√≥b
    try {
      const r = await pool.query(
        "SELECT 1 FROM subscriptions WHERE user_id=$1 AND status='active' LIMIT 1",
        [uid]
      );
      if (r?.rowCount) return;
    } catch {}

    // pobierz trial plan_id
    let planId = null;
    try {
      const p = await pool.query("SELECT id FROM plans WHERE code='trial' AND active=TRUE LIMIT 1");
      if (p?.rowCount) planId = Number(p.rows[0].id);
    } catch {}
    if (!planId) return;

    // znajd≈∫ kolumnƒô expiry w subscriptions (je≈õli istnieje)
    let expCol = null;
    try {
      const c = await pool.query(`
        SELECT column_name
        FROM information_schema.columns
        WHERE table_schema='public' AND table_name='subscriptions'
          AND data_type LIKE 'timestamp%'
        ORDER BY
          CASE
            WHEN column_name='expires_at' THEN 1
            WHEN column_name ILIKE '%expire%' THEN 2
            WHEN column_name ILIKE '%valid%' THEN 3
            WHEN column_name ILIKE '%end%' THEN 4
            WHEN column_name ILIKE '%until%' THEN 5
            ELSE 50
          END,
          ordinal_position
        LIMIT 1
      `);
      if (c?.rowCount) expCol = String(c.rows[0].column_name || "");
    } catch {}

    // jakie kolumny istniejƒÖ w subscriptions
    let colset = new Set();
    try {
      const cols = await pool.query(`
        SELECT column_name
        FROM information_schema.columns
        WHERE table_schema='public' AND table_name='subscriptions'
      `);
      for (const r of (cols.rows || [])) colset.add(String(r.column_name));
    } catch {}

    const fields = ["user_id", "plan_id"];
    const vals = ["$1", "$2"];
    const params = [uid, planId];

    if (colset.has("status")) { fields.push("status"); vals.push("'active'"); }
    if (colset.has("provider")) { fields.push("provider"); vals.push("'trial'"); }
    if (colset.has("provider_subscription_id")) { fields.push("provider_subscription_id"); vals.push("NULL"); }
    if (colset.has("created_at")) { fields.push("created_at"); vals.push("NOW()"); }
    if (expCol) { fields.push(expCol); vals.push("NOW() + INTERVAL '7 days'"); }

    const sql = `INSERT INTO subscriptions (${fields.join(",")}) VALUES (${vals.join(",")})`;
    await pool.query(sql, params);
  } catch {}
}
// ---- FYD: ensure trial for user END ----

async function handleNotificationsOn(msg, user) {
  const chatId = String(msg.chat.id);
  // __FYD_AUTO_TRIAL_V1__
  await ensureChatNotificationsRowDb(chatId, user.id);
  try { if (typeof __fydEnsureTrialForUser === 'function') await __fydEnsureTrialForUser(user); } catch {}
  await dbQuery(
    `INSERT INTO chat_notifications (chat_id,user_id,enabled,mode,updated_at) VALUES ($1,$2,TRUE,'single',NOW())
     ON CONFLICT (chat_id,user_id) DO UPDATE SET enabled=TRUE, updated_at=NOW()`,
    [chatId, user.id]
  );
  const lang = await getLang(chatId, user);
  await tgSend(chatId, lang === "pl" ? "‚úÖ Powiadomienia W≈ÅƒÑCZONE na tym czacie." : "‚úÖ Notifications ENABLED in this chat.");
}

async function handleNotificationsOff(msg, user) {
  const chatId = String(msg.chat.id);
  await ensureChatNotificationsRowDb(chatId, user.id);
  await dbQuery(
    `INSERT INTO chat_notifications (chat_id,user_id,enabled,mode,updated_at) VALUES ($1,$2,FALSE,'single',NOW())
     ON CONFLICT (chat_id,user_id) DO UPDATE SET enabled=FALSE, updated_at=NOW()`,
    [chatId, user.id]
  );
  const lang = await getLang(chatId, user);
  await tgSend(chatId, lang === "pl" ? "‚õî Powiadomienia WY≈ÅƒÑCZONE na tym czacie." : "‚õî Notifications DISABLED in this chat.");
}

async function handleModeSingle(msg, user) {
  const chatId = String(msg.chat.id);
  await ensureChatNotificationsRowDb(chatId, user.id);
  await dbQuery(`UPDATE chat_notifications SET mode='single', updated_at=NOW() WHERE chat_id=$1 AND user_id=$2`, [chatId, user.id]);
  const lang = await getLang(chatId, user);
  await tgSend(chatId, lang === "pl" ? "üì® Ustawiono tryb: <b>pojedynczo</b> (domy≈õlny na tym czacie)." : "üì® Mode set: <b>single</b> (default in this chat).");
}

async function handleModeBatch(msg, user) {
  const chatId = String(msg.chat.id);
  await ensureChatNotificationsRowDb(chatId, user.id);
  await dbQuery(`UPDATE chat_notifications SET mode='batch', updated_at=NOW() WHERE chat_id=$1 AND user_id=$2`, [chatId, user.id]);
  const lang = await getLang(chatId, user);
  await tgSend(chatId, lang === "pl" ? "üì¶ Ustawiono tryb: <b>zbiorczo</b> (domy≈õlny na tym czacie)." : "üì¶ Mode set: <b>batch</b> (default in this chat).");
}

async function setPerLinkMode(chatId, userId, linkId, mode) {
  const m = String(mode || "").toLowerCase();
  const finalMode = m === "batch" ? "batch" : m === "off" ? "off" : "single";

  const chk = await dbQuery(`SELECT id FROM links WHERE id=$1 AND user_id=$2 LIMIT 1`, [Number(linkId), Number(userId)]);
  if (!chk.rowCount) return { ok: false, reason: "NOT_OWNED" };

  await dbQuery(
    `INSERT INTO link_notification_modes (user_id,chat_id,link_id,mode,updated_at)
     VALUES ($1,$2,$3,$4,NOW())
     ON CONFLICT (user_id,chat_id,link_id) DO UPDATE SET mode=EXCLUDED.mode, updated_at=NOW()`,
    [Number(userId), String(chatId), Number(linkId), finalMode]
  );

  return { ok: true, mode: finalMode };
}

async function handleQuiet(msg, user) {
  const chatId = String(msg.chat.id);
  const lang = await getLang(chatId, user);
  const arg = (msg.text || "").trim().split(/\s+/).slice(1).join(" ").trim();

  if (!arg) {
    const qh = await getQuietHours(chatId);
    if (qh?.quiet_enabled) {
      await tgSend(chatId, lang === "pl"
        ? `üåô Cisza nocna: <b>W≈ÅƒÑCZONA</b>, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00`
        : `üåô Quiet hours: <b>ENABLED</b>, hours ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00`
      );
    } else {
      await tgSend(chatId, lang === "pl"
        ? "üåô Cisza nocna: <b>wy≈ÇƒÖczona</b>.\nUstaw: <code>/cisza 22-7</code>"
        : "üåô Quiet hours: <b>disabled</b>.\nSet: <code>/quiet 22-7</code>"
      );
    }
    return;
  }

  const m = arg.match(/^(\d{1,2})\s*-\s*(\d{1,2})$/);
  if (!m) {
    await tgSend(chatId, lang === "pl" ? "Podaj zakres jako HH-HH, np. <code>/cisza 22-7</code>" : "Provide range as HH-HH, e.g. <code>/quiet 22-7</code>");
    return;
  }

  const fromHour = Number(m[1]);
  const toHour = Number(m[2]);
  if (!Number.isFinite(fromHour) || !Number.isFinite(toHour) || fromHour < 0 || fromHour > 23 || toHour < 0 || toHour > 23) {
    await tgSend(chatId, lang === "pl" ? "Godziny muszƒÖ byƒá w zakresie 0‚Äì23, np. <code>/cisza 22-7</code>" : "Hours must be 0‚Äì23, e.g. <code>/quiet 22-7</code>");
    return;
  }

  await setQuietHours(chatId, fromHour, toHour);
  await tgSend(chatId, lang === "pl"
    ? `üåô Ustawiono ciszƒô nocnƒÖ: <b>${fromHour}:00‚Äì${toHour}:00</b>`
    : `üåô Quiet hours set: <b>${fromHour}:00‚Äì${toHour}:00</b>`
  );
}

async function handleQuietOff(msg, user) {
  const chatId = String(msg.chat.id);
  await disableQuietHours(chatId);
  const lang = await getLang(chatId, user);
  await tgSend(chatId, lang === "pl" ? "üåô Cisza nocna: <b>WY≈ÅƒÑCZONA</b>" : "üåô Quiet hours: <b>DISABLED</b>");
}

async function handleCallback(update) {
  const cq = update.callback_query;
  if (!cq) return;

  const data = cq.data || "";
  const chatId = cq.message?.chat?.id;
  const fromId = cq.from?.id ? String(cq.from.id) : null;

  if (!chatId || !fromId) {
    await tgAnswerCb(cq.id, "Missing chat/user data.");
    return;
  }

  const u = await getUserWithPlanByTelegramId(fromId);
  if (!u?.id) {
    await tgAnswerCb(cq.id, "Use /start.", true);
    return;
  }

  await ensureChatNotificationsRowDb(String(chatId), u.id);

  const mLang = data.match(/^lang:([a-z]{2})$/i);
  if (mLang) {
    const newLang = __normLang(mLang[1]) || FYD_DEFAULT_LANG;
    await setLang(String(chatId), u, newLang);
    await tgAnswerCb(cq.id, "OK");
    await tgSend(String(chatId), t(newLang, "language_set", { language: escapeHtml(langLabel(newLang)) }));
    return;
  }


const m = data.match(/^lnmode:(\d+):(off|single|batch)$/i);
  if (m) {
    const linkId = Number(m[1]);
    const mode = String(m[2]).toLowerCase();
    const res = await setPerLinkMode(String(chatId), u.id, linkId, mode);
    if (!res.ok) { await tgAnswerCb(cq.id, "Can't set mode.", true); return; }
    const lang = await getLang(String(chatId), u);
    const pretty = res.mode === "batch" ? (lang === "pl" ? "zbiorczo" : "batch") : res.mode === "off" ? "OFF" : (lang === "pl" ? "pojedynczo" : "single");
    await tgAnswerCb(cq.id, lang === "pl" ? `Ustawiono: ${pretty}` : `Set: ${pretty}`);
    return;
  }

  await tgAnswerCb(cq.id, "Unknown action.");
}

let offset = 0;

async function fetchUpdates() {
  const url = new URL(`https://api.telegram.org/bot${TG}/getUpdates`);
  url.searchParams.set("timeout", "30");
  if (offset) url.searchParams.set("offset", String(offset));
  const res = await __fydFetch(url.href);
  if (!res.ok) throw new Error(`getUpdates HTTP ${res.status}`);
  const data = await res.json();
  if (!data.ok) throw new Error(`getUpdates Telegram error: ${data.description}`);
  return data.result;
}

function normalizeCommand(cmdRaw) {
  const c0 = String(cmdRaw || "").trim().toLowerCase().split("@")[0];
  const c = c0.normalize("NFD").replace(/\p{Diacritic}/gu, "");

  const map = new Map([
    ["/help", "/help"], ["/pomoc", "/help"],
    ["/start", "/start"],
    ["/plany", "/plans"], ["/kup", "/plans"], ["/plans", "/plans"],
    ["/lista", "/list"], ["/list", "/list"],
    ["/dodaj", "/add"], ["/add", "/add"],
    ["/usun", "/remove"], ["/remove", "/remove"],
    ["/status", "/status"], ["/config", "/status"],
    ["/cisza", "/quiet"], ["/quiet", "/quiet"],
    ["/cisza_off", "/quiet_off"], ["/quiet_off", "/quiet_off"],
    ["/najnowsze", "/latest"], ["/latest", "/latest"],
    ["/najtansze", "/cheapest"], ["/cheapest", "/cheapest"],
    ["/pojedyncze", "/single"], ["/pojedynczo", "/single"], ["/single", "/single"],
    ["/zbiorcze", "/batch"], ["/batch", "/batch"],
    ["/on", "/on"], ["/off", "/off"],
    ["/panel", "/panel"],
    ["/lang", "/lang"],
    ["/starter", "/starter"], ["/growth", "/growth"], ["/platinum", "/platinum"],
    ["/addon10", "/addon10"],
  ]);

  return map.get(c) || c;
}


async function handleUpdate(update) {
  // __FYD_PANEL_HANDLER_V3__ (always reply exactly once)
  try {
    const __msg = update?.message || update?.edited_message || update?.callback_query?.message;
    const __chatId = __msg?.chat?.id;
    const __fromId = update?.message?.from?.id || update?.edited_message?.from?.id || update?.callback_query?.from?.id;
    const __text0 = String(update?.message?.text || update?.edited_message?.text || "").trim();
    if (__chatId && __fromId && __text0.startsWith("/panel")) {
      const uR = await __fydQ("SELECT id FROM users WHERE telegram_user_id=$1 LIMIT 1", [String(__fromId)]);
      const uid = uR?.rows?.[0]?.id;
      if (!uid) {
        await tgSend(__chatId, "Najpierw u≈ºyj /start.");
        return;
      }
      const { randomBytes } = await import("node:crypto");
      const tok = randomBytes(24).toString("hex");
      await __fydQ(
        "INSERT INTO panel_login_tokens (token, user_id, created_at, expires_at) VALUES ($1,$2,NOW(),NOW() + INTERVAL '10 minutes')",
        [tok, Number(uid)]
      );
      const base = process.env.PANEL_BASE_URL || "https://panel.findyourdeal.app";
      const url = `${base}/api/auth/login?token=${tok}`;
      await tgSend(__chatId, `Panel: ${url}\nToken wa≈ºny 10 minut.`, { disable_web_page_preview: true });
      return;
    }
  } catch (e) {
    try { console.log("panel handler v3 error", e); } catch {}
  }


  if (update.callback_query) { await handleCallback(update); return; }

  const msg = update.message;
  if (!msg || !msg.text) return;

  const chatType = msg.chat?.type || "";
  if (chatType && chatType !== "private") {
    await tgSend(String(msg.chat.id), "‚ùå Private chat only.");
    return;
  }

  const chatId = String(msg.chat.id);
  const from = msg.from || {};
  const tgId = from.id ? String(from.id) : null;
  if (!tgId) return;

  // wspieramy: /on 18, /single 18, /batch 18 oraz PL odpowiedniki
  let text = (msg.text ?? "").trim();
  const mSpace = text.match(/^\/(on|off|single|batch|pojedyncze|pojedynczo|zbiorcze)\s+(\d+)\b/i);
  if (mSpace) {
    const cmd = mSpace[1].toLowerCase() === "pojedynczo" ? "pojedyncze" : mSpace[1].toLowerCase();
    text = `/${cmd}_${mSpace[2]}`;
  }

  await initDb();

  await ensureUser(from.id, from.username || null, from.first_name || null, from.last_name || null, from.language_code || null);

  let user = null;
  if (Number(tgId) === 1) user = await getUserById(1);
  else user = await getUserWithPlanByTelegramId(tgId);

  if (!user) {
    await tgSend(chatId, "Use /start.");
    return;
  }

  await ensureChatNotificationsRowDb(chatId, user.id);

  const [commandRaw, ...rest] = text.split(/\s+/);
  const command = normalizeCommand(commandRaw);
  const argText = rest.join(" ").trim();

  // per-link: /single_18 /batch_18 /off_18 /on_18 oraz PL: /pojedyncze_18 /zbiorcze_18
  const perLink = command.match(/^\/(pojedyncze|zbiorcze|single|batch|off|on)_(\d+)$/i);
  if (perLink) {
    const kind = perLink[1].toLowerCase();
    const linkId = Number(perLink[2]);
    const lang = await getLang(chatId, user);

    if (kind === "on") {
      const chk = await dbQuery(`SELECT id FROM links WHERE id=$1 AND user_id=$2 LIMIT 1`, [linkId, user.id]);
      if (!chk.rowCount) { await tgSend(chatId, lang === "pl" ? `‚ùå Link <b>${linkId}</b> nie nale≈ºy do Twojego konta.` : `‚ùå Link <b>${linkId}</b> is not on your account.`); return; }
      await clearLinkNotificationMode(user.id, chatId, linkId);

      const cn = await dbQuery(`SELECT mode FROM chat_notifications WHERE chat_id=$1 AND user_id=$2 LIMIT 1`, [chatId, user.id]);
      const chatMode = (String(cn.rows?.[0]?.mode || "single").toLowerCase() === "batch")
        ? (lang === "pl" ? "zbiorczo" : "batch")
        : (lang === "pl" ? "pojedynczo" : "single");

      await tgSend(chatId, lang === "pl"
        ? `‚úÖ Link <b>${linkId}</b> W≈ÅƒÑCZONY (dziedziczy tryb czatu: <b>${chatMode}</b>).`
        : `‚úÖ Link <b>${linkId}</b> ENABLED (inherits chat mode: <b>${chatMode}</b>).`
      );
      return;
    }

    const mode = (kind === "zbiorcze" || kind === "batch") ? "batch" : kind === "off" ? "off" : "single";
    const res = await setPerLinkMode(chatId, user.id, linkId, mode);
    if (!res.ok) {
      await tgSend(chatId, lang === "pl" ? "‚ùå Link nie nale≈ºy do Twojego konta." : "‚ùå Link is not on your account.");
      return;
    }
    const pretty = res.mode === "batch" ? (lang === "pl" ? "zbiorczo" : "batch") : res.mode === "off" ? "OFF" : (lang === "pl" ? "pojedynczo" : "single");
    await tgSend(chatId, lang === "pl" ? `‚úÖ Link <b>${linkId}</b> ustawiony: <b>${pretty}</b>` : `‚úÖ Link <b>${linkId}</b> set to: <b>${pretty}</b>`);
    return;
  }

  if (command === "/start") { await handleHelp(msg, user); return; }
  if (command === "/help") { await handleHelp(msg, user); return; }
  if (command === "/lang") { await handleLang(msg, user); return; }
  if (command === "/status") return await handleStatus(msg, user);

  if (command === "/plans") return await handlePlans(msg, user);
  if (command === "/starter") return await handleBuyPlan(msg, user, "starter");
  if (command === "/growth") return await handleBuyPlan(msg, user, "growth");
  if (command === "/platinum") return await handleBuyPlan(msg, user, "platinum");
  if (command === "/addon10") return await handleAddon10(msg, user);

  if (command === "/najnowsze" || command === "/latest") return await handleNewest(msg, user);

  if (command === "/najtansze" || command === "/cheapest") return await handleCheapest(msg, user);

  if (command === "/panel") return await handlePanel(msg, user);
  if (command === "/list") return await handleLista(msg, user);
  if (command === "/remove") return await handleUsun(msg, user, argText);
  if (command === "/add") return await handleDodaj(msg, user, argText);

  if (command === "/on") return await handleNotificationsOn(msg, user);
  if (command === "/off") return await handleNotificationsOff(msg, user);
  if (command === "/single") return await handleModeSingle(msg, user);
  if (command === "/batch") return await handleModeBatch(msg, user);

  if (command === "/quiet_off") return await handleQuietOff(msg, user);
  if (command === "/quiet") return await handleQuiet(msg, user);

  const lang = await getLang(chatId, user);

  // ---------- /usun_uzytkownika (SUPERADMIN) ----------
  if ((text || "").trim().startsWith("/usun_uzytkownika")) {
    const fromId = msg?.from?.id || 0;
    const superAdmins = String(process.env.FYD_SUPERADMIN_TG_IDS || "")
      .split(/[, ]+/)
      .map((x) => Number(String(x || "").trim()))
      .filter((x) => Number.isFinite(x) && x > 0);

    if (!superAdmins.includes(fromId)) {
      await tgSend(chatId, "‚õî Brak uprawnie≈Ñ (tylko SUPERADMIN).");
      return;
    }

    const parts = String(text || "").trim().split(/\s+/);
    const tgId = Number(parts[1] || 0);

    if (!Number.isFinite(tgId) || tgId <= 0) {
      await tgSend(chatId, "U≈ºycie: /usun_uzytkownika <telegram_user_id>");
      return;
    }

    const safe = async (sql, params) => {
      try { await pool.query(sql, params); } catch (e) {}
    };

    try {
      const u = await pool.query("SELECT id FROM users WHERE telegram_user_id=$1 LIMIT 1", [tgId]);
      if (!u.rows.length) {
        await tgSend(chatId, `‚ÑπÔ∏è Nie znaleziono u≈ºytkownika o telegram_user_id=${tgId}`);
        return;
      }
      const userId = u.rows[0].id;
  // __FYD_PANEL_TO_TG_LANG_SYNC_V3__ - force update.from.language_code from DB (panel -> telegram)
  try {
    const rLang = await __fydQ("SELECT lang FROM users WHERE id=$1", [Number(user.id)]);
    const dbLang = __normLang(rLang?.rows?.[0]?.lang || "");
    if (dbLang) {
      user.lang = dbLang;

      const __from =
        update?.message?.from ||
        update?.callback_query?.from ||
        update?.edited_message?.from ||
        update?.inline_query?.from ||
        update?.chosen_inline_result?.from;

      if (__from) __from.language_code = dbLang;
    }
  } catch {}




      await pool.query("BEGIN");

      await safe("DELETE FROM panel_sessions WHERE user_id=$1", [userId]);
      await safe("DELETE FROM panel_login_tokens WHERE user_id=$1", [userId]);
      await safe("DELETE FROM subscriptions WHERE user_id=$1", [userId]);

      await safe("DELETE FROM link_notification_modes WHERE user_id=$1", [userId]);
      await safe("DELETE FROM chat_notifications WHERE user_id=$1", [userId]);

      await safe("DELETE FROM link_items WHERE link_id IN (SELECT id FROM links WHERE user_id=$1)", [userId]);
      await safe("DELETE FROM link_notification_modes WHERE link_id IN (SELECT id FROM links WHERE user_id=$1)", [userId]);
      await safe("DELETE FROM links WHERE user_id=$1", [userId]);

      await pool.query("DELETE FROM users WHERE id=$1", [userId]);

      await pool.query("COMMIT");
      await tgSend(chatId, `‚úÖ Usuniƒôto u≈ºytkownika telegram_user_id=${tgId} (user_id=${userId}) i wyczyszczono jego dane.`);
      return;
    } catch (e) {
      try { await pool.query("ROLLBACK"); } catch {}
      await tgSend(chatId, `‚ùå B≈ÇƒÖd usuwania u≈ºytkownika: ${String(e?.message || e)}`);
      return;
    }
  }

  // ---------- /daj_admina (SUPERADMIN) ----------
  if ((text || "").trim().startsWith("/daj_admina")) {
    const fromId = msg?.from?.id || 0;
    const superAdmins = String(process.env.FYD_SUPERADMIN_TG_IDS || "")
      .split(/[, ]+/)
      .map((x) => Number(String(x || "").trim()))
      .filter((x) => Number.isFinite(x) && x > 0);

    if (!superAdmins.includes(fromId)) {
      await tgSend(chatId, "‚õî Brak uprawnie≈Ñ (tylko SUPERADMIN).");
      return;
    }

    const parts = String(text || "").trim().split(/\s+/);
    const tgId = Number(parts[1] || 0);

    if (!Number.isFinite(tgId) || tgId <= 0) {
      await tgSend(chatId, "U≈ºycie: /daj_admina <telegram_user_id>");
      return;
    }

    try {
      await pool.query(
        "UPDATE users SET is_admin=TRUE WHERE telegram_user_id=$1",
        [tgId]
      );

      const check = await pool.query("SELECT id FROM users WHERE telegram_user_id=$1 LIMIT 1", [tgId]);
      if (!check.rows.length) {
        await tgSend(chatId, `‚ÑπÔ∏è Nie znaleziono u≈ºytkownika o telegram_user_id=${tgId} (najpierw musi zrobiƒá /start).`);
        return;
      }

      await tgSend(chatId, `‚úÖ Nadano ADMIN dla telegram_user_id=${tgId}`);
      return;
    } catch (e) {
      await tgSend(chatId, `‚ùå B≈ÇƒÖd nadawania admina: ${String(e?.message || e)}`);
      return;
    }
  }


  // ---------- /nazwa (USER) ----------
  if ((text || "").trim().startsWith("/nazwa")) {
    const parts = String(text || "").trim().split(/\s+/);
    const linkId = Number(parts[1] || 0);
    const rawName = String(text || "").trim().split(/\s+/).slice(2).join(" ").trim();

    if (!Number.isFinite(linkId) || linkId <= 0 || !rawName) {
      await tgSend(chatId, lang === "pl"
        ? "U≈ºycie: /nazwa <ID> <Twoja nazwa>\nPrzyk≈Çad: /nazwa 116 Oferty iPhone 16\nWyczyszczenie: /nazwa 116 -"
        : "Usage: /nazwa <ID> <Your name>\nExample: /nazwa 116 iPhone 16 offers\nClear: /nazwa 116 -"
      );
      return;
    }

    // '-' = wyczy≈õƒá
    const name = (rawName === "-" ? "" : rawName).slice(0, 60);

    const tgUserId = msg?.from?.id || 0;
    try {
      const u = await pool.query("SELECT id FROM users WHERE telegram_user_id=$1 LIMIT 1", [tgUserId]);
      if (!u.rows.length) {
        await tgSend(chatId, lang === "pl"
          ? "‚ÑπÔ∏è Najpierw u≈ºyj /start."
          : "‚ÑπÔ∏è Please use /start first."
        );
        return;
      }
      const userId = u.rows[0].id;

      const r = await pool.query(
        "UPDATE links SET name=$1, label=$1 WHERE id=$2 AND user_id=$3 RETURNING id",
        [name || null, linkId, userId]
      );
      if (!r.rowCount) {
        await tgSend(chatId, lang === "pl"
          ? `‚ÑπÔ∏è Nie znaleziono linku o ID ${linkId} na Twoim koncie.`
          : `‚ÑπÔ∏è Link ID ${linkId} not found in your account.`
        );
        return;
      }

      await tgSend(chatId, lang === "pl"
        ? (name ? `‚úÖ Ustawiono nazwƒô dla ID ${linkId}: ${name}` : `‚úÖ Wyczyszczono nazwƒô dla ID ${linkId}.`)
        : (name ? `‚úÖ Name set for ID ${linkId}: ${name}` : `‚úÖ Name cleared for ID ${linkId}.`)
      );
      return;
    } catch (e) {
      await tgSend(chatId, `‚ùå Error: ${String(e?.message || e)}`);
      return;
    }
  }

  await tgSend(chatId, t(lang, "unknown_command") || (lang === "pl" ? "‚ùì Nieznana komenda. U≈ºyj /help." : "‚ùì Unknown command. Use /help."));
}

async function main() {
  console.log("telegram-bot.js start");
  await initDb();

  while (true) {
    try {
      const updates = await fetchUpdates();
      for (const u of updates) {
        offset = u.update_id + 1;
        try { await handleUpdate(u); }
        catch (e) { console.error("handleUpdate error:", e); }
      }
    } catch (e) {
      console.error("polling error:", e);
      await new Promise((r) => setTimeout(r, 1500));
    }
  }
}

main().catch((err) => {
  console.error("telegram-bot fatal error", err);
  process.exit(1);
});

// ---------- /najnowsze + /najtansze (USER) ----------
async function __fydLinkItemsMeta() {
  const q = async (sql, params = []) => {
    if (typeof dbQuery === "function") return await dbQuery(sql, params);
    if (typeof pool !== "undefined" && pool && typeof pool.query === "function") return await pool.query(sql, params);
    if (globalThis.__FYD_TG_POOL_V4 && typeof globalThis.__FYD_TG_POOL_V4.query === "function") return await globalThis.__FYD_TG_POOL_V4.query(sql, params);
    throw new Error("No dbQuery/pool available");
  };

  const colsR = await q(
    `SELECT column_name
     FROM information_schema.columns
     WHERE table_schema='public' AND table_name='link_items'
     ORDER BY ordinal_position`
  );
  const cols = new Set((colsR.rows || []).map(r => String(r.column_name)));

  const pick = (cands) => {
    for (const c of cands) if (cols.has(c)) return c;
    return null;
  };

  const ts = pick(["first_seen_at","created_at","seen_at","inserted_at","updated_at"]);
  const url = pick(["url","item_url","href","link"]);
  const title = pick(["title","name","item_title"]);
  const price = pick(["price","price_value","amount"]);
  const currency = pick(["currency","cur"]);

  return { q, ts, url, title, price, currency };
}

function __fydQi(id) { return `"${String(id).replace(/"/g, '""')}"`; }

async function handleNewest(msg, user) {
  const chatId = String(msg?.chat?.id || "");
  const userId = Number(user?.id);
  const lang = await getLang(chatId, user).catch(() => "en");

  const parts = String(msg?.text || "").trim().split(/\s+/);
  const linkId = Number(parts[1] || 0);
  const useLink = Number.isFinite(linkId) && linkId > 0;

  const head = (lang === "pl") ? "üÜï Najnowsze oferty (z historii):" : "üÜï Latest offers (from history):";
  const none = (lang === "pl") ? "Brak zapisanych ofert w historii." : "No saved offers in history.";
  const bad  = (lang === "pl") ? "Nieprawid≈Çowe ID linku." : "Invalid link ID.";

  if (!chatId || !Number.isFinite(userId)) return;
  if (parts.length > 1 && !useLink) { await tgSend(chatId, bad); return; }

  const m = await __fydLinkItemsMeta();
  if (!m.ts || !m.url) { await tgSend(chatId, none); return; }

  const ts = __fydQi(m.ts);
  const url = __fydQi(m.url);
  const title = m.title ? __fydQi(m.title) : null;
  const price = m.price ? __fydQi(m.price) : null;
  const currency = m.currency ? __fydQi(m.currency) : null;

  const where = useLink ? "AND li.link_id=$2" : "";
  const params = useLink ? [userId, linkId] : [userId];

  const sql = `
    SELECT
      li.link_id,
      COALESCE(l.label, l.name, '') AS link_name,
      ${title ? `COALESCE(li.${title}::text,'')` : `''`} AS title,
      ${price ? `li.${price}` : `NULL`} AS price,
      ${currency ? `COALESCE(li.${currency}::text,'')` : `''`} AS currency,
      li.${url}::text AS url,
      li.${ts} AS ts
    FROM link_items li
    JOIN links l ON l.id=li.link_id
    WHERE l.user_id=$1
      ${where}
    ORDER BY li.${ts} DESC
    LIMIT 10
  `;
  const r = await m.q(sql, params);
  if (!r.rows || !r.rows.length) { await tgSend(chatId, none); return; }

  let out = head + "\n\n";
  let i = 1;
  for (const row of r.rows) {
    const t = String(row.title || "").trim();
    const u = String(row.url || "").trim();
    const p = (row.price != null && row.price !== "") ? String(row.price) : "";
    const cur = String(row.currency || "").trim();
    const tag = row.link_name ? ` [${row.link_id} ‚Äì ${row.link_name}]` : ` [${row.link_id}]`;

    out += `${i}. ${t ? t : "(bez tytu≈Çu)"}${tag}\n`;
    if (p) out += `üí∞ ${p}${cur ? " " + cur : ""}\n`;
    out += `${u}\n\n`;
    i++;
  }

  await tgSend(chatId, escapeHtml(out.trim()));
}

async function handleCheapest(msg, user) {
  const chatId = String(msg?.chat?.id || "");
  const userId = Number(user?.id);
  const lang = await getLang(chatId, user).catch(() => "en");

  const parts = String(msg?.text || "").trim().split(/\s+/);
  const linkId = Number(parts[1] || 0);
  const useLink = Number.isFinite(linkId) && linkId > 0;

  const head = (lang === "pl") ? "üí∏ Najta≈Ñsze oferty (z historii):" : "üí∏ Cheapest offers (from history):";
  const none = (lang === "pl") ? "Brak zapisanych ofert w historii." : "No saved offers in history.";
  const bad  = (lang === "pl") ? "Nieprawid≈Çowe ID linku." : "Invalid link ID.";

  if (!chatId || !Number.isFinite(userId)) return;
  if (parts.length > 1 && !useLink) { await tgSend(chatId, bad); return; }

  const m = await __fydLinkItemsMeta();
  if (!m.ts || !m.url || !m.price) { await tgSend(chatId, none); return; }

  const ts = __fydQi(m.ts);
  const url = __fydQi(m.url);
  const title = m.title ? __fydQi(m.title) : null;
  const price = __fydQi(m.price);
  const currency = m.currency ? __fydQi(m.currency) : null;

  const where = useLink ? "AND li.link_id=$2" : "";
  const params = useLink ? [userId, linkId] : [userId];

  const sql = `
    SELECT
      li.link_id,
      COALESCE(l.label, l.name, '') AS link_name,
      ${title ? `COALESCE(li.${title}::text,'')` : `''`} AS title,
      li.${price} AS price,
      ${currency ? `COALESCE(li.${currency}::text,'')` : `''`} AS currency,
      li.${url}::text AS url,
      li.${ts} AS ts
    FROM link_items li
    JOIN links l ON l.id=li.link_id
    WHERE l.user_id=$1
      ${where}
      AND li.${price} IS NOT NULL
    ORDER BY li.${price} ASC, li.${ts} DESC
    LIMIT 10
  `;
  const r = await m.q(sql, params);
  if (!r.rows || !r.rows.length) { await tgSend(chatId, none); return; }

  let out = head + "\n\n";
  let i = 1;
  for (const row of r.rows) {
    const t = String(row.title || "").trim();
    const u = String(row.url || "").trim();
    const p = (row.price != null && row.price !== "") ? String(row.price) : "";
    const cur = String(row.currency || "").trim();
    const tag = row.link_name ? ` [${row.link_id} ‚Äì ${row.link_name}]` : ` [${row.link_id}]`;

    out += `${i}. ${t ? t : "(bez tytu≈Çu)"}${tag}\n`;
    out += `üí∞ ${p}${cur ? " " + cur : ""}\n`;
    out += `${u}\n\n`;
    i++;
  }

  await tgSend(chatId, escapeHtml(out.trim()));
}

