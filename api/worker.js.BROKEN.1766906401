import dotenv from "dotenv";
dotenv.config();

import { chromium, request } from "playwright";
import {
  initDb,
  getLinksForWorker,
  getSeenItemKeys,
  insertLinkItems,
  updateLastKey,
  pruneLinkItems,
} from "./db.js";

import fetch from "node-fetch";
import pg from "pg";

const { Pool } = pg;

// Osobny pool tylko do chat_notifications / link_notification_modes / limity dzienne
const notifyPool = process.env.DATABASE_URL
  ? new Pool({ connectionString: process.env.DATABASE_URL })
  : new Pool();

// =================== KONFIG TELEGRAM / WORKER ===================

const TG = process.env.TELEGRAM_BOT_TOKEN || "";
const API_BASE = process.env.API_BASE || "http://api:3000";

// debug logi
const DEBUG =
  process.env.DEBUG_WORKER === "true" || process.env.DEBUG === "true";

function logDebug(...args) {
  if (DEBUG) console.log(...args);
}

// FYD: limit dzienny = 200 + addon_qty*100
async function getDailyLimitForUserId(pool, userId) {
  try {
    const r = await pool.query(
      `SELECT COALESCE(addon_qty,0) AS addon_qty
       FROM subscriptions
       WHERE user_id=$1 AND status='active'
         AND (current_period_end IS NULL OR current_period_end > NOW())
       ORDER BY current_period_end DESC NULLS LAST, updated_at DESC
       LIMIT 1`,
      [Number(userId)]
    );
    const addon = Number(r.rows?.[0]?.addon_qty || 0) || 0;
    return 200 + addon * 100;
  } catch {
    return 200;
  }
}

const userLimitsCache = new Map(); // tgUserId -> limits (z /me lub fallback)
async function getUserLimits(telegramUserId) {
  const key = String(telegramUserId || "");
  if (!key) return null;
  if (userLimitsCache.has(key)) return userLimitsCache.get(key);

  // 1) Preferuj /me
  try {
    const r = await fetch(API_BASE + "/me", {
      headers: { "X-Telegram-User-Id": key },
    });
    if (r.ok) {
      const j = await r.json();
      const f = j?.features || {};
      const lim = j?.limits || {};
      const out = {
        sources_allowed: Array.isArray(f.sources_allowed) ? f.sources_allowed : null,
        history_keep_per_link: Number(f.history_keep_per_link || 0) || null,
        max_items_per_link_per_loop: Number(f.max_items_per_link_per_loop || 0) || null,
        links_limit_total: Number(lim?.max_total_links ?? lim?.max_active_links ?? 0) || 0,
        links_limit: Number(f.links_limit || 0) || null,
        fast_slots: Number(f.fast_slots || 0) || null,
        refresh_fast_s: Number(f.refresh_fast_s || 0) || null,
        refresh_normal_s: Number(f.refresh_normal_s || 0) || null,
      };
      userLimitsCache.set(key, out);
      return out;
    }
  } catch {}

  // 2) Fallback: widok user_entitlements_v (je≈õli jest)
  try {
    const q = await notifyPool.query(
      `SELECT links_limit_total FROM public.user_entitlements_v WHERE telegram_user_id=$1 LIMIT 1`,
      [Number(key)]
    );
    const out = { links_limit_total: Number(q.rows?.[0]?.links_limit_total || 0) || 0 };
    userLimitsCache.set(key, out);
    return out;
  } catch {}

  return null;
}

// =================== PROXY (ENV) ===================
const PROXY_SERVER = process.env.PROXY_SERVER || "";
const PROXY_USERNAME = process.env.PROXY_USERNAME || "";
const PROXY_PASSWORD = process.env.PROXY_PASSWORD || "";

const PROXY =
  PROXY_SERVER && PROXY_USERNAME && PROXY_PASSWORD
    ? { server: PROXY_SERVER, username: PROXY_USERNAME, password: PROXY_PASSWORD }
    : null;

if (DEBUG) {
  console.log(
    `[proxy] enabled=${!!PROXY} server=${PROXY_SERVER || "-"} user=${PROXY_USERNAME ? "YES" : "NO"} pass=${PROXY_PASSWORD ? "YES" : "NO"}`
  );
}

function cleanKey(v) {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (!s) return null;
  const low = s.toLowerCase();
  if (low === "null" || low === "undefined") return null;
  return s;
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Konfiguracja workera
const LOOP_DELAY_MS = Number(process.env.LOOP_DELAY_MS || 300000);
const SLEEP_BETWEEN_ITEMS_MS = Number(process.env.SLEEP_BETWEEN_ITEMS_MS || 1200);

const MAX_ITEMS_PER_LINK_PER_LOOP = Number(process.env.MAX_ITEMS_PER_LINK_PER_LOOP || 10);
const MIN_BATCH_ITEMS = 1;

const HISTORY_KEEP_PER_LINK = Number(process.env.HISTORY_KEEP_PER_LINK || 500);

const SOURCE_CONFIG = {
  olx: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
  vinted: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
  default: { maxPerLoop: MAX_ITEMS_PER_LINK_PER_LOOP, minBatchItems: MIN_BATCH_ITEMS },
};

function getSourceConfig(source) {
  const key = (source || "").toLowerCase();
  return SOURCE_CONFIG[key] || SOURCE_CONFIG.default;
}

// Bufory dla trybu /zbiorcze ‚Äì klucz: "userId:chatId:linkId"
const batchBuffers = new Map();

function normalizeOlxUrl(u = "") {
  try {
    let out = String(u ?? "").trim();
    if (!out) return "";
    if (/^ID[0-9A-Za-z]+$/.test(out)) return out;
    if (!/^https?:\/\//i.test(out)) return out;

    const url = new URL(out);
    url.hash = "";
    url.search = "";
    url.hostname = "www.olx.pl";
    url.pathname = url.pathname.replace(/^\/d\//, "/");
    url.pathname = url.pathname.replace(/\/+$/, "");
    return url.toString().replace(/\/+$/, "");
  } catch {
    return String(u ?? "").trim();
  }
}

function getItemKey(it) {
  return it?.itemKey || it?.item_key || it?.itemKeyNormalized || null;
}

function takeNewItemsUntilLastKey(items, lastKey) {
  if (!lastKey) return { fresh: [], found: false };

  const out = [];
  let found = false;

  for (const it of items || []) {
    const k = getItemKey(it);
    if (!k) continue;
    if (k === lastKey) {
      found = true;
      break;
    }
    out.push(it);
  }

  return { fresh: out, found };
}

function isHourInQuietRange(hour, from, to) {
  if (typeof hour !== "number") return false;
  if (typeof from !== "number" || typeof to !== "number") return false;

  hour = ((hour % 24) + 24) % 24;
  from = ((from % 24) + 24) % 24;
  to = ((to % 24) + 24) % 24;

  if (from === to) return false;

  if (from < to) return hour >= from && hour < to;
  return hour >= from || hour < to;
}

function detectSource(url) {
  try {
    const u = new URL(url);
    const h = (u.hostname || "").toLowerCase();
    if (h.includes("olx.")) return "olx";
    if (h.includes("vinted.")) return "vinted";
    return null;
  } catch {
    return null;
  }
}

function normalizeKey(url) {
  try {
    const u = new URL(url);
    const host = (u.hostname || "").toLowerCase();

    if (host.includes("olx.")) {
      u.hostname = "www.olx.pl";
      const m = u.pathname.match(/\/(d\/)?oferta\/([^/?#]+)(\/.*)?$/);
      if (m) {
        const slug = m[2];
        u.pathname = `/oferta/${slug}`;
      }
      u.search = "";
      u.hash = "";
      return u.toString();
    }

    if (host.includes("vinted.")) {
      if (u.pathname === "/session-refresh") {
        const ref = u.searchParams.get("ref_url");
        if (ref) {
          try {
            const decoded = decodeURIComponent(ref);
            const u2 = new URL(decoded, `${u.protocol}//${u.host}`);
            if (u2.pathname.startsWith("/items/")) {
              const m2 = u2.pathname.match(/^\/items\/(\d+)/i);
              if (m2) u2.pathname = `/items/${m2[1]}`;
              u2.search = "";
              u2.hash = "";
              return u2.toString();
            }
          } catch {}
        }
      }

      if (u.pathname.startsWith("/items/")) {
        const m = u.pathname.match(/^\/items\/(\d+)/i);
        if (m) u.pathname = `/items/${m[1]}`;
        u.search = "";
        u.hash = "";
        return u.toString();
      }
    }

    u.search = "";
    u.hash = "";
    return u.toString();
  } catch {
    return url;
  }
}

// Minimalne escape HTML dla Telegrama
function escapeHtml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

// Parsowanie ceny
function parsePrice(text) {
  if (!text) return { price: null, currency: null };

  const m = String(text).match(/([\d\s.,]+)\s*([A-Za-z‚Ç¨$≈Ç≈Å]+)?/i);
  if (!m) return { price: null, currency: null };

  const numStr = m[1].replace(/\s/g, "").replace(",", ".");
  const price = Number.parseFloat(numStr);
  const rawCurr = (m[2] || "").toUpperCase();

  let currency = null;
  if (/PLN|Z≈Å|ZL/.test(rawCurr)) currency = "PLN";
  else if (/EUR|‚Ç¨/.test(rawCurr)) currency = "EUR";
  else if (/USD|\$/.test(rawCurr)) currency = "USD";
  else if (rawCurr) currency = rawCurr;

  return { price: Number.isFinite(price) ? price : null, currency };
}

// Telegram send (retry 429)
return out;
}


// __FYD_META_I18N_V3_BEGIN__
const __FYD_META_CACHE_V3 = new Map();

const __FYD_I18N_V3 = {
  en: { new_listings: "New listings", full_history: "Full history:", btn_disable: "Disable this link", btn_single: "Single", btn_batch: "Batch" },
  pl: { new_listings: "Nowe og≈Çoszenia", full_history: "Pe≈ÇnƒÖ historiƒô zobaczysz w", btn_disable: "Wy≈ÇƒÖcz ten link", btn_single: "Pojedynczo", btn_batch: "Zbiorczo" }
};

function __fydNormLangV3(x) {
  const raw = String(x || "").trim().toLowerCase();
  const base = raw.includes("-") ? raw.split("-")[0] : raw;
  return (__FYD_I18N_V3[base] ? base : "en");
}

function __fydEscV3(s) {
  return String(s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

function __fydTV3(lang, key) {
  const l = __fydNormLangV3(lang);
  return (__FYD_I18N_V3[l] && __FYD_I18N_V3[l][key]) || (__FYD_I18N_V3.en && __FYD_I18N_V3.en[key]) || key;
}

async function __fydGetMetaByLinkIdV3(linkId) {
  const now = Date.now();
  const cached = __FYD_META_CACHE_V3.get(linkId);
  if (cached && (now - cached.ts) < 30*1000) return cached;

  try {
    const db =
      (typeof notifyPool !== "undefined" && notifyPool) ? notifyPool :
      (typeof pool !== "undefined" && pool) ? pool :
      null;

    if (!db || typeof db.query !== "function") {
      const meta = { id: linkId, label: "", lang: "en", ts: now };
      __FYD_META_CACHE_V3.set(linkId, meta);
      return meta;
    }

    const r = await db.query(
      "SELECT COALESCE(l.label,'') AS label, COALESCE(u.lang,'en') AS lang FROM links l JOIN users u ON u.id=l.user_id WHERE l.id=$1",
      [linkId]
    );
    const row = (r.rows && r.rows[0]) || {};
    const meta = { id: linkId, label: String(row.label||"").trim(), lang: String(row.lang||"en"), ts: now };
    __FYD_META_CACHE_V3.set(linkId, meta);
    return meta;
  } catch (e) {
    const meta = { id: linkId, label: "", lang: "en", ts: now };
    __FYD_META_CACHE_V3.set(linkId, meta);
    return meta;
  }
}

function __fydRewriteTextAndButtonsV3(text, meta, payload) {
  const lang = __fydNormLangV3(meta.lang);
  let out = String(text || "");

  out = out.replace(/\[fyd-worker:sendTelegram\]\s*/g, "");

  // nag≈Ç√≥wek: üÜï ... lub "New listings"
  out = out.replace(/^üÜï\s+.*$/m, "üÜï " + __fydTV3(lang, "new_listings"));
  out = out.replace(/^New listings\s*$/m, "üÜï " + __fydTV3(lang, "new_listings"));

  // üîç/üîé ... ID N  -> je≈õli label istnieje, podmie≈Ñ nazwƒô
  if (meta.label) {
    const re = new RegExp("^(\\s*(?:üîç|üîé)\\s*).*?\\bID\\b[^0-9]*" + meta.id + ".*$", "m");
    out = out.replace(re, function(_, pref){ return pref + __fydEscV3(meta.label) + " ¬∑ ID " + meta.id; });
  }

  // linia z /najnowsze N
  const reHist = new RegExp("^.*\\/najnowsze\\s+" + meta.id + ".*$", "m");
  out = out.replace(reHist, __fydTV3(lang, "full_history") + " /najnowsze " + meta.id);

  // przyciski: uwzglƒôdnij emoji na poczƒÖtku
  try {
    const rm = payload && payload.reply_markup;
    if (rm && Array.isArray(rm.inline_keyboard)) {
      for (const row of rm.inline_keyboard) {
        if (!Array.isArray(row)) continue;
        for (const btn of row) {
          if (!btn || typeof btn.text !== "string") continue;
          const raw = btn.text;
          const norm = raw.replace(/^[^\p{L}\p{N}]+/gu, "").trim().toLowerCase();

          if (norm === "disable this link" || norm === "wy≈ÇƒÖcz ten link") btn.text = "‚úèÔ∏è " + __fydTV3(lang, "btn_disable");
          if (norm === "single" || norm === "pojedynczo") btn.text = "üì© " + __fydTV3(lang, "btn_single");
          if (norm === "batch" || norm === "zbiorczo") btn.text = "üì¶ " + __fydTV3(lang, "btn_batch");
        }
      }
    }
  } catch (e) {}

  return out;
}
// __FYD_META_I18N_V3_END__


async function sendTelegram(method, payload) {
  // __FYD_SENDTELEGRAM_META_I18N_V3_BEGIN__
  try {
    const mm = String(method || "");
    const key = (payload && typeof payload.text === "string") ? "text" : (payload && typeof payload.caption === "string" ? "caption" : "");
    if (payload && key && (mm === "sendMessage" || mm === "sendPhoto")) {
      const body = String(payload[key] || "");
      const idMatch = body.match(/\bID\b[^0-9]*([0-9]{1,9})/i);
      if (idMatch) {
        const linkId = Number(idMatch[1]);
        if (Number.isFinite(linkId) && linkId > 0) {
          const meta = await __fydGetMetaByLinkIdV3(linkId);
          payload[key] = __fydRewriteTextAndButtonsV3(body, meta, payload);
        }
      }
    }
  } catch (e) {}
  // __FYD_SENDTELEGRAM_META_I18N_V3_END__

if (!TG) {
    console.error("sendTelegram: brak TELEGRAM_BOT_TOKEN ‚Äì nie wysy≈Çam");
    return;
  }

  const url = `https://api.telegram.org/bot${TG}/${method}`;

  while (true) {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const text = await res.text().catch(() => "");

      if (res.status === 429) {
        let retry = 30;
        try {
          const data = JSON.parse(text);
          if (data?.parameters?.retry_after) retry = Number(data.parameters.retry_after) || retry;
        } catch {}
        console.warn(`sendTelegram: 429 retry_after=${retry}s`);
        await sleep(retry * 1000);
        continue;
      }

      if (!res.ok) {
        console.error("sendTelegram: HTTP error", res.status, res.statusText, text);
      }

      break;
    } catch (err) {
      console.error("sendTelegram: exception", err);
      await sleep(2000);
      break;
    }
  }
}

function formatLinkHeader(link) {
  const src = (link.source || detectSource(link.url) || "").toUpperCase();
  let label = link.name || "";
  if (!label) {
    if (src === "OLX") label = "OLX wyszukiwanie";
    else if (src === "VINTED") label = "Vinted wyszukiwanie";
    else label = link.url || "Monitoring";
  }
  const idPart = link.id ? ` ¬∑ <i>ID ${link.id}</i>` : "";
  return `üîç <b>${escapeHtml(label)}</b>${idPart}`;
}

function hiddenLink(url) {
  return `<a href="${escapeHtml(url)}">\u200B</a>`;
}

async function tgSendItem(chatId, link, item) {
  const src = (link.source || detectSource(link.url) || "").toLowerCase();

  const header = formatLinkHeader(link);
  let caption = `${header}\n\n<b>${escapeHtml(item.title || "")}</b>\n`;

  if (item.price != null) {
    const priceStr = `${item.price} ${item.currency || ""}`.trim();
    caption += `\nüí∞ ${escapeHtml(priceStr)}`;
  }
  if (item.brand) caption += `\nüè∑Ô∏è ${escapeHtml(item.brand)}`;
  if (item.size) caption += `\nüìè ${escapeHtml(item.size)}`;
  if (item.condition) caption += `\n‚ú® ${escapeHtml(item.condition)}`;

  caption += `\n\n${hiddenLink(item.url)}`;

  const keyboard = [
    [{ text: "URL", url: item.url }],
    [{ text: "üîï Wy≈ÇƒÖcz ten link", callback_data: `lnmode:${link.id}:off` }],
    [
      { text: "üì® Pojedynczo", callback_data: `lnmode:${link.id}:single` },
      { text: "üì¶ Zbiorczo", callback_data: `lnmode:${link.id}:batch` },
    ],
  ];

  const replyMarkup = { inline_keyboard: keyboard };

  const canSendPhoto =
    src === "vinted" &&
    item.photoUrl &&
    typeof item.photoUrl === "string" &&
    /^https?:\/\//i.test(item.photoUrl);

  if (canSendPhoto) {
    await sendTelegram("sendPhoto", {
      chat_id: chatId,
      photo: item.photoUrl,
      caption,
      parse_mode: "HTML",
      reply_markup: replyMarkup,
    });
  } else {
    await sendTelegram("sendMessage", {
      chat_id: chatId,
      text: caption,
      parse_mode: "HTML",
      disable_web_page_preview: false,
      reply_markup: replyMarkup,
    });
  }

  await sleep(SLEEP_BETWEEN_ITEMS_MS);
}

function buildBatchMessage(link, items, skippedExtra = 0) {
  const header = formatLinkHeader(link);
  let text = `üÜï Nowe og≈Çoszenia\n${header}\n\n`;

  items.forEach((item, idx) => {
    const title = escapeHtml(item.title || "");
    const priceStr =
      item.price != null ? `${item.price} ${item.currency || ""}`.trim() : "";

    text += `${idx + 1}. ${title}\n`;
    if (priceStr) text += `üí∞ ${escapeHtml(priceStr)}\n`;
    text += `${escapeHtml(item.url)}\n\n`;
  });

  if (skippedExtra > 0) text += `+ ${skippedExtra} dodatkowych ofert.\n\n`;
  text += `Pe≈ÇnƒÖ historiƒô zobaczysz w /najnowsze ${link.id}`;

  return text.trim();
}

function makeBatchKey(chatId, userId, linkId) {
  return `${userId}:${chatId}:${linkId}`;
}

async function notifyChatsForLink(link, items, skippedExtra, opts = {}) {
  if (!items || !items.length) return;

  const minBatchItems = opts.minBatchItems || MIN_BATCH_ITEMS;
  const now = new Date();
  const todayStr = now.toISOString().slice(0, 10);
  const nowHour = now.getHours();

  try {
    const res = await notifyPool.query(
      `
      SELECT
        cn.chat_id,
        cn.user_id,
        cn.enabled,
        cn.mode AS chat_mode,
        cn.daily_count,
        cn.daily_count_date,
        LOWER(COALESCE(lnm.mode, cn.mode)) AS effective_mode,
        lnm.mode AS link_mode,
        qh.quiet_enabled,
        qh.quiet_from,
        qh.quiet_to
      FROM links l
      JOIN chat_notifications cn
        ON cn.user_id = l.user_id
       AND (l.chat_id IS NULL OR cn.chat_id = l.chat_id)
      LEFT JOIN LATERAL (
        SELECT mode
        FROM link_notification_modes
        WHERE user_id = cn.user_id
          AND chat_id = cn.chat_id
          AND link_id = l.id
        ORDER BY updated_at DESC NULLS LAST
        LIMIT 1
      ) lnm ON TRUE
      LEFT JOIN chat_quiet_hours qh
        ON qh.chat_id = cn.chat_id
      WHERE l.id = $1
      `,
      [link.id]
    );

    if (!res.rowCount) {
      logDebug(`notifyChatsForLink: link ${link.id} ‚Äì brak chat_notifications`);
      return;
    }

    let chatRows = res.rows.map((row) => ({
      ...row,
      mode: (row.effective_mode || "single").toLowerCase(),
    }));

    // 1) wy≈ÇƒÖczone + OFF
    chatRows = chatRows.filter((row) => row.enabled && row.mode !== "off");
    if (!chatRows.length) return;

    for (const row of chatRows) {
      const chatId = row.chat_id;
      const userId = row.user_id;

      // 2) cisza nocna
      const quietEnabled = !!row.quiet_enabled;
      const quietFrom = typeof row.quiet_from === "number" ? row.quiet_from : 22;
      const quietTo = typeof row.quiet_to === "number" ? row.quiet_to : 7;

      if (quietEnabled && isHourInQuietRange(nowHour, quietFrom, quietTo)) continue;

      // 3) liczniki dzienne
      let dailyCount = row.daily_count || 0;

      let dailyDateStr = null;
      if (row.daily_count_date) {
        dailyDateStr = row.daily_count_date.toISOString
          ? row.daily_count_date.toISOString().slice(0, 10)
          : String(row.daily_count_date).slice(0, 10);
      }
      if (dailyDateStr !== todayStr) {
        dailyCount = 0;
        dailyDateStr = todayStr;
      }

      const maxDaily = await getDailyLimitForUserId(notifyPool, userId);
      if (dailyCount >= maxDaily) {
        await notifyPool.query(
          `
          UPDATE chat_notifications
          SET daily_count = $1,
              daily_count_date = $2
          WHERE chat_id = $3 AND user_id = $4
          `,
          [dailyCount, dailyDateStr, chatId, userId]
        );
        continue;
      }

      const mode = row.mode === "batch" ? "batch" : "single";
      let sentSomething = false;

      if (mode === "single") {
        for (const item of items) {
          await tgSendItem(chatId, link, item);
          sentSomething = true;
        }
      } else {
        const key = makeBatchKey(chatId, userId, link.id);
        const existing = batchBuffers.get(key) || { items: [], skippedExtra: 0 };

        existing.items.push(...items);
        if (typeof skippedExtra === "number" && skippedExtra > 0) {
          existing.skippedExtra += skippedExtra;
        }

        if (existing.items.length < minBatchItems && existing.skippedExtra === 0) {
          batchBuffers.set(key, existing);
        } else {
          const text = buildBatchMessage(link, existing.items, existing.skippedExtra);
          await sendTelegram("sendMessage", {
            chat_id: chatId,
            text,
            parse_mode: "HTML",
            disable_web_page_preview: false,
            reply_markup: {
              inline_keyboard: [
                [{ text: "üîï Wy≈ÇƒÖcz ten link", callback_data: `lnmode:${link.id}:off` }],
                [
                  { text: "üì® Pojedynczo", callback_data: `lnmode:${link.id}:single` },
                  { text: "üì¶ Zbiorczo", callback_data: `lnmode:${link.id}:batch` },
                ],
              ],
            },
          });
          batchBuffers.delete(key);
          sentSomething = true;
        }
      }

      if (sentSomething) {
        const increment = mode === "single" ? items.length : 1;
        dailyCount += increment;

        await notifyPool.query(
          `
          UPDATE chat_notifications
          SET last_notified_at = NOW(),
              daily_count = $1,
              daily_count_date = $2
          WHERE chat_id = $3 AND user_id = $4
          `,
          [dailyCount, dailyDateStr, chatId, userId]
        );
      }
    }
  } catch (err) {
    console.error("B≈ÇƒÖd notifyChatsForLink:", err);
  }
}

// ---------- Scraping OLX ----------
async function scrapeOlx(url) {
  const launchOpts = { args: ["--no-sandbox", "--disable-dev-shm-usage"] };
  if (PROXY) launchOpts.proxy = PROXY;

  const browser = await chromium.launch(launchOpts);
  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });

  let page = await context.newPage();

  const setupPage = async (p) => {
    await p.route(/.*/i, (route) => {
      const t = route.request().resourceType();
      if (t === "image" || t === "media" || t === "font") return route.abort();
      return route.continue();
    });
    p.setDefaultNavigationTimeout(60000);
    p.setDefaultTimeout(60000);
  };

  function deriveOlxTitleFromUrl(u) {
    try {
      const uu = new URL(u);
      const parts = uu.pathname.split("/").filter(Boolean);
      if (!parts.length) return null;
      let last = parts[parts.length - 1];
      last = last.replace(/\.[a-z0-9]+$/i, "");
      let slugParts = last.split("-");
      slugParts = slugParts.filter((p) => {
        const up = p.toUpperCase();
        if (up.startsWith("CID")) return false;
        if (up.startsWith("ID") && up.length > 2) return false;
        return true;
      });
      if (!slugParts.length) return null;
      const pretty = slugParts
        .join(" ")
        .split(" ")
        .filter(Boolean)
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
      return pretty || null;
    } catch {
      return null;
    }
  }

  try {
    await setupPage(page);

    let lastErr = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        await page.goto(url, { waitUntil: "domcontentloaded", timeout: 60000 });
        await page.waitForSelector('div[data-cy="l-card"]', { timeout: 25000 });
        await page.waitForTimeout(800);
        lastErr = null;
        break;
      } catch (e) {
        lastErr = e;
        if (page.isClosed()) {
          page = await context.newPage();
          await setupPage(page);
        }
        await new Promise((r) => setTimeout(r, 1500 * attempt));
      }
    }
    if (lastErr) throw lastErr;

    const rawItems = await page.$$eval('div[data-cy="l-card"]', (cards) => {
      const results = [];
      for (const card of cards) {
        const linkEl = card.querySelector('a[href*="/oferta/"], a[href*="/d/oferta/"]');
        if (!linkEl) continue;

        const url = (() => {
          try {
            const u = new URL(linkEl.href);
            u.hash = "";
            u.search = "";
            u.pathname = u.pathname.replace(/^\/d\/oferta\//, "/oferta/");
            return u.toString();
          } catch {
            return (linkEl.href || "").split("#")[0].split("?")[0].replace("/d/oferta/", "/oferta/");
          }
        })();

        let title = "";
        const titleEl =
          card.querySelector('[data-cy="ad-card-title"]') ||
          card.querySelector('[data-testid="ad-title"]') ||
          linkEl.querySelector("h6") ||
          linkEl.querySelector("h3") ||
          card.querySelector("h6") ||
          card.querySelector("h3");
        if (titleEl) title = (titleEl.innerText || titleEl.textContent || "").trim();
        if (!title && linkEl.getAttribute("title")) title = linkEl.getAttribute("title").trim();
        if (!title) title = (linkEl.innerText || linkEl.textContent || "").trim();

        let priceText = "";
        const priceEl =
          card.querySelector('[data-testid="ad-price"]') ||
          card.querySelector('[data-cy="ad-card-price"]');
        if (priceEl) priceText = (priceEl.innerText || priceEl.textContent || "").trim();

        const img = card.querySelector("img");
        let photoUrl = null;
        if (img) {
          photoUrl =
            img.src ||
            img.getAttribute("src") ||
            img.getAttribute("data-src") ||
            (img.getAttribute("srcset") || "").split(" ")[0] ||
            null;
        }

        const text = card.innerText || card.textContent || "";
        const hasOlxDelivery = /Przesy≈Çka OLX/i.test(text);

        results.push({ url, title, rawPrice: priceText, photoUrl, hasOlxDelivery });
      }
      return results;
    });

    const items = rawItems.map((it) => {
      let finalTitle = it.title || "";
      if (!finalTitle || /^wyr√≥≈ºnione$/i.test(finalTitle)) {
        const fromUrl = deriveOlxTitleFromUrl(it.url);
        if (fromUrl) finalTitle = fromUrl;
      }

      const { price, currency } = parsePrice(it.rawPrice);
      const u = normalizeOlxUrl(it.url);
      const itemKey = normalizeKey(u);

      return {
        url: u,
        title: finalTitle,
        price,
        currency,
        brand: null,
        size: null,
        condition: null,
        photoUrl: it.photoUrl,
        hasOlxDelivery: it.hasOlxDelivery,
        buyUrl: it.hasOlxDelivery ? it.url : null,
        itemKey,
        item_key: itemKey,
      };
    });

    return items;
  } finally {
    await page.close().catch(() => null);
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

// ---------- Scraping Vinted ----------
function pickArrayFromApi(data) {
  if (!data || typeof data !== "object") return [];
  if (Array.isArray(data.items)) return data.items;
  if (Array.isArray(data.catalog_items)) return data.catalog_items;
  if (Array.isArray(data?.data?.items)) return data.data.items;
  if (Array.isArray(data?.data?.catalog_items)) return data.data.catalog_items;
  return [];
}

function getVintedFallbackCurrency(linkUrl) {
  try {
    const u = new URL(linkUrl);
    const cur = u.searchParams.get("currency");
    if (cur) return cur.toUpperCase();
    const h = (u.hostname || "").toLowerCase();
    if (h.endsWith(".pl")) return "PLN";
    return "EUR";
  } catch {}
  return null;
}

function buildVintedApiUrl(catalogUrl) {
  const u = new URL(catalogUrl);
  const api = new URL("/api/v2/catalog/items", u.origin);

  const inP = u.searchParams;
  const outP = api.searchParams;

  outP.set("page", inP.get("page") || "1");
  outP.set("per_page", "96");

  const scalarKeys = ["search_text", "currency", "price_from", "price_to", "order", "search_by_image_uuid"];
  for (const k of scalarKeys) {
    const v = inP.get(k);
    if (v != null && v !== "") outP.set(k, v);
  }
  if (!outP.get("order")) outP.set("order", "newest_first");

  for (const [k, v] of inP.entries()) {
    if (k === "time") continue;
    if (k === "catalog[]") outP.append("catalog_ids[]", v);
    else if (k === "catalog_ids[]") outP.append("catalog_ids[]", v);
    else if (k === "size_ids[]") outP.append("size_ids[]", v);
    else if (k === "brand_ids[]") outP.append("brand_ids[]", v);
    else if (k === "status_ids[]") outP.append("status_ids[]", v);
    else if (k === "color_ids[]") outP.append("color_ids[]", v);
    else if (k === "material_ids[]") outP.append("material_ids[]", v);
  }

  return api.toString();
}

function getVintedItemIdFromUrl(urlOrKey) {
  try {
    const u = new URL(urlOrKey);
    const m = u.pathname.match(/^\/items\/(\d+)(?:-|\/|$)/i);
    if (!m) return null;
    const n = Number(m[1]);
    return Number.isFinite(n) ? n : null;
  } catch {
    const s = String(urlOrKey || "").trim();
    if (/^\d+$/.test(s)) return Number(s);
    return null;
  }
}

function parseVintedMeta(titleAttr, fallbackTitle) {
  if (!titleAttr) {
    return { title: fallbackTitle || "", brand: null, size: null, condition: null, rawPriceFromTitle: null };
  }

  const segments = titleAttr.split(/\s*,\s*/);
  let title = segments[0] || fallbackTitle || "";

  let brand = null;
  let size = null;
  let condition = null;
  let rawPriceFromTitle = null;

  for (let i = 1; i < segments.length; i++) {
    const seg = segments[i] || "";
    const lower = seg.toLowerCase();
    let m;

    m = seg.match(/^marka:\s*(.+)$/i);
    if (m) { brand = m[1].trim(); continue; }

    m = seg.match(/^(stan|condition):\s*(.+)$/i);
    if (m) { condition = m[2].trim(); continue; }

    m = seg.match(/^rozmiar:\s*(.+)$/i);
    if (m) { size = m[1].trim(); continue; }

    if (/\d/.test(seg) && !/zawiera/i.test(lower)) rawPriceFromTitle = seg.trim();
  }

  return { title, brand, size, condition, rawPriceFromTitle };
}

async function scrapeVinted(url) {
  let origin = "";
  try { origin = new URL(url).origin; } catch {}

  const fallbackCurrency = getVintedFallbackCurrency(url);

  // 1) API (pw request)
  try {
    const apiUrl = buildVintedApiUrl(url);

    const api = await request.newContext({
      proxy: PROXY || undefined,
      baseURL: origin || undefined,
      extraHTTPHeaders: {
        "user-agent":
          "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "accept-language": "pl-PL,pl;q=0.9,en;q=0.8",
      },
    });

    try {
      if (origin) {
        await api.get("/", {
          headers: { accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" },
        });
      }

      const res = await api.get(apiUrl, {
        headers: {
          accept: "application/json, text/plain, */*",
          "x-requested-with": "XMLHttpRequest",
          referer: url,
        },
      });

      const txt = await res.text().catch(() => "");
      if (!res.ok()) throw new Error(`HTTP_${res.status()}`);

      let apiData = null;
      try { apiData = JSON.parse(txt); } catch { throw new Error("JSON_PARSE"); }
      if (process.env.VINTED_API_ENABLED !== "true") throw new Error("VINTED_API_DISABLED");

      const arr = pickArrayFromApi(apiData);
      if (arr && arr.length) {
        const mapped = arr
          .map((it) => {
            const id =
              typeof it?.id === "number"
                ? it.id
                : Number.isFinite(Number(it?.id))
                ? Number(it.id)
                : null;

            const urlAbs =
              it?.url && typeof it.url === "string"
                ? it.url.startsWith("http")
                  ? it.url
                  : origin
                  ? new URL(it.url, origin).toString()
                  : it.url
                : id && origin
                ? `${origin}/items/${id}`
                : null;

            if (!urlAbs) return null;

            const title = it?.title || it?.name || it?.description || it?.brand_title || "";

            const priceAmount =
              it?.price?.amount ?? it?.price?.value ?? it?.price ?? it?.total_item_price?.amount ?? null;

            const price =
              priceAmount != null && String(priceAmount).trim() !== ""
                ? Number(String(priceAmount).replace(",", "."))
                : null;

            const currency =
              it?.price?.currency_code || it?.currency || fallbackCurrency || null;

            const photoUrl =
              it?.photo?.url ||
              it?.photo?.full_size_url ||
              it?.photo?.high_resolution?.url ||
              (Array.isArray(it?.photos) && it.photos[0]?.url) ||
              null;

            const brand = it?.brand_title || it?.brand || it?.brand_name || null;
            const size = it?.size_title || it?.size || it?.size_name || null;
            const condition = it?.status_title || it?.status || it?.item_condition || null;

            const itemKey = normalizeKey(urlAbs);
            const vintedId = getVintedItemIdFromUrl(itemKey) || id || null;

            return {
              url: urlAbs,
              title: String(title || "").trim(),
              price: Number.isFinite(price) ? price : null,
              currency: currency ? String(currency).toUpperCase() : null,
              brand: brand ? String(brand).trim() : null,
              size: size ? String(size).trim() : null,
              condition: condition ? String(condition).trim() : null,
              photoUrl: photoUrl ? String(photoUrl) : null,
              itemKey,
              item_key: itemKey,
              vintedId: typeof vintedId === "number" ? vintedId : null,
            };
          })
          .filter(Boolean);

        return mapped;
      }
    } finally {
      await api.dispose().catch(() => null);
    }
  } catch (e) {
    logDebug("Vinted API failed -> fallback DOM:", e?.message || e);
  }

  // 2) DOM fallback
  const launchOpts = { args: ["--no-sandbox", "--disable-dev-shm-usage"] };
  if (PROXY) launchOpts.proxy = PROXY;

  const browser = await chromium.launch(launchOpts);
  const context = await browser.newContext({
    locale: "pl-PL",
    timezoneId: "Europe/Warsaw",
    userAgent:
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  });

  const page = await context.newPage();

  try {
    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 });
    await page.waitForTimeout(2000);

    await page
      .waitForSelector('main a[href^="/items/"]', { timeout: 12000 })
      .catch(() => null);

    const rawItems = await page
      .$$eval('main a[href^="/items/"]', (anchors) => {
        const seen = new Set();
        const results = [];

        function extractPhotoUrl(rootEl) {
          let el = rootEl;
          for (let depth = 0; depth < 6 && el; depth++) {
            const img = el.querySelector("img");
            if (img) {
              const srcset = img.getAttribute("srcset") || "";
              const primaryFromSrcset = srcset.split(" ")[0] || null;
              return (
                img.src ||
                img.getAttribute("src") ||
                img.getAttribute("data-src") ||
                primaryFromSrcset
              );
            }
            el = el.parentElement;
          }
          return null;
        }

        for (const a of anchors) {
          const href = a.href;
          if (!href || !href.includes("/items/")) continue;
          if (seen.has(href)) continue;
          seen.add(href);

          const titleAttr = a.getAttribute("title") || "";
          const text = a.textContent ? a.textContent.trim() : "";
          const photoUrl = extractPhotoUrl(a);

          results.push({ url: href, titleAttr, text, rawPrice: "", photoUrl });
        }

        return results;
      })
      .catch(() => []);

    const mappedItems = (rawItems || [])
      .map((it) => {
        const meta = parseVintedMeta(it.titleAttr, it.text);
        const rawPrice = meta.rawPriceFromTitle || it.rawPrice;
        const { price, currency } = parsePrice(rawPrice);
        const itemKey = normalizeKey(it.url);
        const vintedId = getVintedItemIdFromUrl(itemKey);

        return {
          url: it.url,
          title: meta.title || it.text || "",
          price,
          currency: currency || fallbackCurrency,
          brand: meta.brand,
          size: meta.size,
          condition: meta.condition,
          photoUrl: it.photoUrl,
          itemKey,
          item_key: itemKey,
          vintedId,
        };
      })
      .filter(Boolean);

    return mappedItems;
  } finally {
    await context.close().catch(() => null);
    await browser.close().catch(() => null);
  }
}

// ---------- Filtrowanie ----------
function matchFilters(item, filters = {}) {
  if (!filters || Object.keys(filters).length === 0) return true;

  const price = typeof item.price === "number" ? item.price : null;

  if (filters.minPrice != null && price != null && price < filters.minPrice) return false;
  if (filters.maxPrice != null && price != null && price > filters.maxPrice) return false;

  if (Array.isArray(filters.brand) && filters.brand.length) {
    const brandLower = (item.brand || "").toLowerCase();
    const ok = filters.brand.some((b) => brandLower.includes(String(b).toLowerCase()));
    if (!ok) return false;
  }

  if (Array.isArray(filters.sizes) && filters.sizes.length) {
    const sizeLower = (item.size || "").toLowerCase();
    const ok = filters.sizes.some((s) => sizeLower === String(s).toLowerCase());
    if (!ok) return false;
  }

  if (Array.isArray(filters.conditions) && filters.conditions.length) {
    const condLower = (item.condition || "").toLowerCase();
    const ok = filters.conditions.some((c) => condLower.includes(String(c).toLowerCase()));
    if (!ok) return false;
  }

  return true;
}

function safeParseFilters(raw) {
  if (!raw) return {};
  if (typeof raw === "object") return raw;
  if (typeof raw === "string") {
    try { return JSON.parse(raw); } catch { return {}; }
  }
  return {};
}

function sortItemsForNotify(source, items) {
  const src = (source || "").toLowerCase();
  if (src === "vinted") {
    return [...(items || [])].sort((a, b) => {
      const ai = typeof a.vintedId === "number" ? a.vintedId : -1;
      const bi = typeof b.vintedId === "number" ? b.vintedId : -1;
      return bi - ai;
    });
  }
  return items || [];
}

async function processLink(link) {
  const source = (link.source || detectSource(link.url) || "").toLowerCase();
  if (!source) return;

  const tgUserId = link.telegram_user_id || null;
  const limits = tgUserId ? await getUserLimits(tgUserId) : null;

  if (limits?.sources_allowed && Array.isArray(limits.sources_allowed) && !limits.sources_allowed.includes(source)) {
    console.log(`[link ${link.id}] SOURCE_NOT_ALLOWED_BY_PLAN source=${source}`);
    return;
  }

  console.log(`Worker: checking ${link.url}`);

  let scraped = [];
  if (source === "olx") scraped = await scrapeOlx(link.url);
  else if (source === "vinted") scraped = await scrapeVinted(link.url);
  else return;

  const lastKey = cleanKey(
    source === "olx"
      ? normalizeOlxUrl(String(link.last_key ?? ""))
      : String(link.last_key ?? "")
  );

  const cfg = getSourceConfig(source);
  const maxPerLoop = Number(limits?.max_items_per_link_per_loop || cfg.maxPerLoop);
  const minBatchItems = cfg.minBatchItems;

  const filters = safeParseFilters(link.filters);
  const filtered = (scraped || []).filter((it) => matchFilters(it, filters));
  if (!filtered.length) return;

  const orderedAll = source === "vinted" ? sortItemsForNotify(source, filtered) : filtered;

  // baseline: nowy link -> ustaw last_key i nie wysy≈Çaj
  if (!lastKey) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey) await updateLastKey(link.id, newestKey);
    return;
  }

  const { fresh: freshByLastKey, found } = takeNewItemsUntilLastKey(orderedAll, lastKey);

  if (!found) {
    const newestKey = getItemKey(orderedAll[0]);

    const keysToCheck = orderedAll.map(getItemKey).filter(Boolean);
    const seenSet = await getSeenItemKeys(link.id, keysToCheck);

    const freshNotSeen = orderedAll.filter((it) => {
      const k = getItemKey(it);
      return k && !seenSet.has(k);
    });

    if (!freshNotSeen.length) {
      if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
      return;
    }

    await insertLinkItems(link.id, freshNotSeen);

    const toSend = freshNotSeen.slice(0, maxPerLoop);
    const skipped = freshNotSeen.length - toSend.length;

    await notifyChatsForLink(link, toSend, skipped, { minBatchItems });

    if (newestKey) await updateLastKey(link.id, newestKey);

    const keep = Number(limits?.history_keep_per_link || HISTORY_KEEP_PER_LINK);
    if (Number.isFinite(keep) && keep > 0) await pruneLinkItems(link.id, keep);
    return;
  }

  if (!freshByLastKey.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
    return;
  }

  const keysToCheck = freshByLastKey.map(getItemKey).filter(Boolean);
  const seenSet = await getSeenItemKeys(link.id, keysToCheck);

  const freshNotSeen = freshByLastKey.filter((it) => {
    const k = getItemKey(it);
    return k && !seenSet.has(k);
  });

  if (!freshNotSeen.length) {
    const newestKey = getItemKey(orderedAll[0]);
    if (newestKey && newestKey !== lastKey) await updateLastKey(link.id, newestKey);
    return;
  }

  await insertLinkItems(link.id, freshNotSeen);

  const toSend = freshNotSeen.slice(0, maxPerLoop);
  const skipped = freshNotSeen.length - toSend.length;

  if (toSend.length) await notifyChatsForLink(link, toSend, skipped, { minBatchItems });

  const newestKey = getItemKey(orderedAll[0]);
  if (newestKey) await updateLastKey(link.id, newestKey);

  const keep = Number(limits?.history_keep_per_link || HISTORY_KEEP_PER_LINK);
  if (Number.isFinite(keep) && keep > 0) await pruneLinkItems(link.id, keep);
}

async function loopOnce() {
  await initDb();
  const links = await getLinksForWorker();
  console.log(`Worker: found links: ${links.length}`);

  // grupujemy per telegram_user_id (≈ºeby cap by≈Ç per user)
  const byUser = new Map(); // tgId(str) -> links[]
  for (const link of links) {
    const tgId = link.telegram_user_id ? String(link.telegram_user_id) : "__no_tg__";
    if (!byUser.has(tgId)) byUser.set(tgId, []);
    byUser.get(tgId).push(link);
  }

  for (const [tgId, userLinks] of byUser.entries()) {
    const sorted = [...userLinks].sort((a, b) => Number(a.id) - Number(b.id));

    let toProcess = sorted;

    if (tgId !== "__no_tg__") {
      const lim = await getUserLimits(tgId);
      const cap = Number(lim?.links_limit_total ?? lim?.links_limit ?? 0);
      if (cap > 0) toProcess = sorted.slice(0, cap);
      if (cap > 0 && sorted.length > cap) {
        console.log(`[user ${tgId}] cap=${cap} active_links=${sorted.length} -> processing=${toProcess.length}`);
      }
    }

    for (const link of toProcess) {
      try {
        await processLink(link);
      } catch (err) {
        console.error(`Worker: error for link ${link.id}`, err);
      }
    }
  }
}

async function main() {
  console.log("Worker start");
  console.log(`[config] LOOP_DELAY_MS=${LOOP_DELAY_MS}ms SLEEP_BETWEEN_ITEMS_MS=${SLEEP_BETWEEN_ITEMS_MS}ms MAX_ITEMS_PER_LINK_PER_LOOP=${MAX_ITEMS_PER_LINK_PER_LOOP}`);

  while (true) {
    try {
      await loopOnce();
    } catch (err) {
      console.error("Worker: loopOnce error", err);
    }
    await sleep(LOOP_DELAY_MS);
  }
}

main().catch((err) => {
  console.error("Worker fatal error", err);
  process.exit(1);
});
