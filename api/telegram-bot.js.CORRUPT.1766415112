import dotenv from "dotenv";
import fetch from "node-fetch";
import pg from "pg";
import { randomBytes } from "node:crypto";
import crypto from "crypto";

import {
  initDb,
  ensureUser,
  getUserWithPlanByTelegramId,
  getUserEntitlementsByTelegramId,
  getUserById,
  getLinksByUserId,
  countActiveLinksForUserId,
  countEnabledLinksForUserId,
  insertLinkForUserId,
  deactivateLinkForUserId,
  setQuietHours,
  disableQuietHours,
  getQuietHours,
  clearLinkNotificationMode,
} from "./db.js";

dotenv.config();





function formatWarsawDateTime(value) {
  try {
    if (!value) return null;
    const d = (value instanceof Date) ? value : new Date(value);
    if (Number.isNaN(d.getTime())) return null;

    const parts = new Intl.DateTimeFormat("pl-PL", {
      timeZone: "Europe/Warsaw",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    }).formatToParts(d);

    const m = {};
    for (const p of parts) if (p.type !== "literal") m[p.type] = p.value;

    return `${m.day}/${m.month}/${m.year} godz. ${m.hour};${m.minute}`;
  } catch {
    return null;
  }
}

function formatEntitlementsStatus(ent) {
  if (!ent) return "Plan: unknown";

  const code = String(ent.plan_code || "free").toLowerCase();
  const labels = {
    free: "Free",
    trial: "Trial",
    starter: "Starter",
    growth: "Growth",
    platinum: "Platinum",
    basic: "Starter",
    pro: "Growth",
  };
  const label = labels[code] || (code ? code.charAt(0).toUpperCase() + code.slice(1) : "Unknown");

  const expiresAt = ent.expires_at ? new Date(ent.expires_at) : null;
  if (!expiresAt || Number.isNaN(expiresAt.getTime())) return `Plan: ${label}`;

  const parts = new Intl.DateTimeFormat("pl-PL", {
    timeZone: "Europe/Warsaw",
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).formatToParts(expiresAt);

  const get = (t) => (parts.find((p) => p.type === t) || {}).value || "";
  const dd = get("day");
  const mm = get("month");
  const yyyy = get("year");
  const hh = get("hour");
  const mi = get("minute");

  return `Plan: ${label} (do ${dd}/${mm}/${yyyy} godz. ${hh};${mi})`;
}


function formatWarsawDateTimePL(dt) {
  if (!dt) return null;
  const d = (dt instanceof Date) ? dt : new Date(dt);
  if (Number.isNaN(d.getTime())) return null;

  const parts = new Intl.DateTimeFormat("pl-PL", {
    timeZone: "Europe/Warsaw",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).formatToParts(d);

  const get = (t) => (parts.find((x) => x.type === t) || {}).value || "";
  const DD = get("day");
  const MM = get("month");
  const YYYY = get("year");
  const HH = get("hour");
  const MIN = get("minute");

  return `${DD}/${MM}/${YYYY} godz. ${HH};${MIN}`;
}
function formatPolishDateTime(iso) {
  if (!iso) return null;
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return null;

  const parts = new Intl.DateTimeFormat("pl-PL", {
    timeZone: "Europe/Warsaw",
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).formatToParts(d);

  const get = (t) => parts.find((p) => p.type === t)?.value;
  const dd = get("day");
  const mm = get("month");
  const yyyy = get("year");
  const hh = get("hour");
  const mi = get("minute");
  if (!dd || !mm || !yyyy || !hh || !mi) return null;

  return `${dd}/${mm}/${yyyy} godz. ${hh};${mi}`;
}



const { Pool } = pg;


const TG = process.env.TELEGRAM_BOT_TOKEN || "";
const DATABASE_URL = process.env.DATABASE_URL || "";

if (!TG) {
  console.error("Brak TELEGRAM_BOT_TOKEN w env, wychodzƒô.");
  process.exit(1);
}

if (!DATABASE_URL) {
  console.error("Brak DATABASE_URL w env ‚Äì bot mo≈ºe mieƒá problem z DB.");
}

const pool = new Pool({
  connectionString: DATABASE_URL,
});

// limit dzienny powiadomie≈Ñ na jeden chat ‚Äì informacyjnie do /status
const MAX_DAILY_NOTIFICATIONS = 200; // base
// ---------- helpery og√≥lne ----------

async function dbQuery(sql, params = []) {
  const client = await pool.connect();
  try {
    return await client.query(sql, params);
  } finally {
    client.release();
  }
}

// FYD_DAILY_LIMIT_ADDON_V1
async function getDailyLimitForUserId(userId) {
  try {
    const r = await dbQuery(
      `SELECT COALESCE(addon_qty,0) AS addon_qty
       FROM subscriptions
       WHERE user_id=$1 AND status='active'
         AND (current_period_end IS NULL OR current_period_end > NOW())
       ORDER BY current_period_end DESC NULLS LAST, updated_at DESC
       LIMIT 1`,
      [Number(userId)]
    );
    const addon = Number(r.rows?.[0]?.addon_qty || 0) || 0;
    return 200 + addon * 100;
  } catch {
    return 200;
  }
}

// Minimalne escape HTML dla Telegrama (parse_mode=HTML)
function escapeHtml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

async function tgApi(method, payload) {
  const url = `https://api.telegram.org/bot${TG}/${method}`;
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  return res.json().catch(() => ({}));
}

async function tgSend(chatId, text, extra = {}) {
  const MAX_LEN = 3500; // bezpieczny margines dla Telegrama (limit ~4096)
  const full = String(text ?? "");

  const parts = [];
  if (full.length <= MAX_LEN) {
    parts.push(full);
  } else {
    let rest = full;
    while (rest.length > 0) {
      let cut = rest.lastIndexOf("\n", MAX_LEN);
      if (cut < 1000) cut = MAX_LEN; // jak nie ma sensownego \n, tnij twardo
      parts.push(rest.slice(0, cut));
      rest = rest.slice(cut);
    }
  }

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const extraForThis = i === 0 ? extra : {}; // nie duplikuj klawiatur/markup√≥w
    try {
      const res = await tgApi("sendMessage", {
        chat_id: chatId,
        text: part,
        parse_mode: "HTML",
        disable_web_page_preview: true,
        ...extraForThis,
      });

      if (!res || res.ok !== true) {
        console.error("Telegram send failed:", res?.description || res);
        console.error("chatId=", chatId, "textLen=", String(part).length);
      } else {
        console.log("Telegram sent:", res.result?.message_id, "chatId=", chatId, "len=", String(part).length);
      }
    } catch (err) {
      console.error("Telegram send error:", err.message || err);
    }
  }
}

async function tgAnswerCb(callbackQueryId, text, showAlert = false) {
  try {
    await tgApi("answerCallbackQuery", {
      callback_query_id: callbackQueryId,
      text,
      show_alert: !!showAlert,
    });
  } catch (e) {
    // ignore
  }
}

// ---------- mapowanie Telegram ID -> user_id (aliasy) ----------

async function resolveUserIdFromTg(tgId) {
  const tid = String(tgId);

  // standard: pobieramy user po telegram_id
  const user = await getUserWithPlanByTelegramId(tid);
  return user?.id || null;
}

// je≈õli nie ma chat_notifications ‚Äì tworzymy domy≈õlnie W≈ÅƒÑCZONE + single
async function ensureChatNotificationsRow(chatId, userId) {
  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, daily_count, daily_count_date, created_at, updated_at)
    VALUES ($1, $2, TRUE, 'single', 0, CURRENT_DATE, NOW(), NOW())
    ON CONFLICT (chat_id, user_id) DO NOTHING
    `,
    [String(chatId), Number(userId)]
  );
}

// ---------- long polling z getUpdates ----------

let offset = 0;

async function fetchUpdates() {
  const url = new URL(`https://api.telegram.org/bot${TG}/getUpdates`);
  url.searchParams.set("timeout", "30");
  if (offset) url.searchParams.set("offset", String(offset));

  const res = await fetch(url.href);
  if (!res.ok) throw new Error(`getUpdates HTTP ${res.status}`);

  const data = await res.json();
  if (!data.ok) throw new Error(`getUpdates Telegram error: ${data.description}`);

  return data.result;
}

// ---------- pomocnik do budowy STATUS ----------


// FYD_STATUS_REWRITE_V1
async function buildStatusMessage(chatId, userIdOrTelegramId) {
  let text = "‚ÑπÔ∏è Status bota

";
  const todayStr = new Date().toISOString().slice(0, 10);

  const esc = (v) => (typeof escapeHtml === "function" ? escapeHtml(v) : String(v ?? ""));
  const toInt = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? Math.trunc(n) : 0;
  };

  // resolve user (najpierw telegram_user_id, potem users.id)
  let userId = 0;
  let tgUserId = toInt(userIdOrTelegramId);

  try {
    if (typeof getUserByTelegramId === "function") {
      const u = await getUserByTelegramId(tgUserId);
      if (u?.id) {
        userId = toInt(u.id);
        tgUserId = toInt(u.telegram_user_id ?? u.telegramUserId ?? tgUserId);
      }
    }
  } catch (e) {
    console.error("buildStatusMessage getUserByTelegramId error", e);
  }

  if (!userId) {
    try {
      const r1 = await dbQuery(
        "SELECT id, telegram_user_id FROM users WHERE telegram_user_id=$1 LIMIT 1",
        [tgUserId]
      );
      if (r1.rowCount) {
        userId = toInt(r1.rows[0].id);
        tgUserId = toInt(r1.rows[0].telegram_user_id);
      } else {
        const maybeUserId = toInt(userIdOrTelegramId);
        if (maybeUserId) {
          const r2 = await dbQuery(
            "SELECT id, telegram_user_id FROM users WHERE id=$1 LIMIT 1",
            [maybeUserId]
          );
          if (r2.rowCount) {
            userId = toInt(r2.rows[0].id);
            tgUserId = toInt(r2.rows[0].telegram_user_id);
          }
        }
      }
    } catch (e) {
      console.error("buildStatusMessage resolve user via db error", e);
    }
  }

  if (!userId) {
    text += "Plan: unknown

";
    text += "Aktywne wyszukiwania (w≈ÇƒÖczone): 0/0
";
    text += "≈ÅƒÖcznie wyszukiwa≈Ñ (w bazie): 0/0

";
    text += "W≈ÇƒÖczone wyszukiwania:
‚Ä¢ (brak)

";
    text += "Tryb per link zmienisz: /pojedyncze_ID /zbiorcze_ID /off_ID (np. /zbiorcze_18)";
    return text;
  }

  // subscription + addon_qty
  let planId = 0;
  let planCode = "";
  let planName = "unknown";
  let expiresAt = null;
  let addonQty = 0;

  try {
    const rSub = await dbQuery(
      `SELECT s.plan_id, p.code, p.name, s.current_period_end, COALESCE(s.addon_qty,0) AS addon_qty
       FROM subscriptions s
       JOIN plans p ON p.id=s.plan_id
       WHERE s.user_id=$1 AND s.status='active'
       ORDER BY s.updated_at DESC
       LIMIT 1`,
      [userId]
    );
    if (rSub.rowCount) {
      planId = toInt(rSub.rows[0].plan_id);
      planCode = String(rSub.rows[0].code || "");
      planName = String(rSub.rows[0].name || rSub.rows[0].code || "unknown");
      expiresAt = rSub.rows[0].current_period_end || null;
      addonQty = toInt(rSub.rows[0].addon_qty);
    }
  } catch (e) {
    console.error("buildStatusMessage subscription error", e);
  }

  let until = "";
  try {
    if (expiresAt) {
      if (typeof formatPolishDateTime === "function") until = formatPolishDateTime(expiresAt);
      else until = new Date(expiresAt).toISOString();
    }
  } catch (_) {}

  text += until ? `Plan: ${planName} (do ${until})

` : `Plan: ${planName}

`;

  // plan_features -> base links/offers
  let baseLinks = 0;
  let baseOffers = 0;

  try {
    if (planId) {
      const rL = await dbQuery(
        "SELECT feature_value FROM plan_features WHERE plan_id=$1 AND feature_key='links_limit' LIMIT 1",
        [planId]
      );
      baseLinks = toInt(rL.rows?.[0]?.feature_value);

      const rO = await dbQuery(
        "SELECT feature_value FROM plan_features WHERE plan_id=$1 AND feature_key='history_keep_per_link' LIMIT 1",
        [planId]
      );
      baseOffers = toInt(rO.rows?.[0]?.feature_value);
    } else {
      // fallback awaryjny po kodzie (gdyby brak plan_features)
      const c = String(planCode || planName || "").toLowerCase();
      baseLinks = c.includes("platinum") ? 40 : c.includes("growth") ? 25 : c.includes("starter") ? 10 : c.includes("trial") ? 5 : 0;
      baseOffers = c.includes("platinum") ? 800 : c.includes("growth") ? 400 : c.includes("starter") ? 200 : c.includes("trial") ? 100 : 0;
    }
  } catch (e) {
    console.error("buildStatusMessage plan_features error", e);
  }

  const limitTotal = Math.max(0, baseLinks + addonQty * 10);
  const totalOffers = Math.max(0, baseOffers + addonQty * 100);
  const dailyLimit = Math.max(0, 200 + addonQty * 100);

  // link counters
  let enabledLinks = 0;
  let totalLinks = 0;
  try {
    const rE = await dbQuery("SELECT COUNT(*)::int AS n FROM links WHERE user_id=$1 AND active=true", [userId]);
    enabledLinks = toInt(rE.rows?.[0]?.n);

    const rT = await dbQuery("SELECT COUNT(*)::int AS n FROM links WHERE user_id=$1", [userId]);
    totalLinks = toInt(rT.rows?.[0]?.n);
  } catch (e) {
    console.error("buildStatusMessage link counters error", e);
  }

  text += `Aktywne wyszukiwania (w≈ÇƒÖczone): ${enabledLinks}/${limitTotal}
`;
  text += `≈ÅƒÖcznie wyszukiwa≈Ñ (w bazie): ${totalLinks}/${limitTotal}

`;

  // chat_notifications
  let chatDefaultMode = "pojedynczo";
  try {
    const res = await dbQuery(
      "SELECT enabled, mode, daily_count, daily_count_date FROM chat_notifications WHERE chat_id=$1 AND user_id=$2",
      [String(chatId), userId]
    );

    if (!res.rowCount) {
      text += "Ten czat: brak konfiguracji.
";
      text += `Domy≈õlnie: powiadomienia W≈ÅƒÑCZONE, tryb: pojedynczo, 0/${dailyLimit} dzisiaj.
`;
      text += "Skonfigurujesz to komendami /on /off /pojedyncze /zbiorcze.

";
    } else {
      const row = res.rows[0];
      const enabled = row.enabled !== false;
      const mode = (String(row.mode || "single").toLowerCase() === "batch") ? "zbiorczo" : "pojedynczo";
      chatDefaultMode = mode;

      let daily = toInt(row.daily_count);
      let dateStr = null;
      if (row.daily_count_date) {
        dateStr = row.daily_count_date.toISOString
          ? row.daily_count_date.toISOString().slice(0, 10)
          : String(row.daily_count_date).slice(0, 10);
      }
      if (dateStr !== todayStr) daily = 0;

      text += `${enabled ? "‚úÖ Powiadomienia W≈ÅƒÑCZONE" : "‚õî Powiadomienia WY≈ÅƒÑCZONE"}
`;
      text += `Tryb domy≈õlny na tym czacie: ${mode}
`;
      text += `Dzisiejsze powiadomienia: ${daily}/${dailyLimit}
`;
      text += `≈ÅƒÖczny limit ofert w planie: ${totalOffers}
`;
      text += "Zmiana: /on /off /pojedyncze /zbiorcze

";
    }
  } catch (e) {
    console.error("buildStatusMessage chat_notifications error", e);
    text += "Ustawienia powiadomie≈Ñ: (b≈ÇƒÖd odczytu)

";
  }

  // cisza nocna
  try {
    if (typeof getQuietHours === "function") {
      const qh = await getQuietHours(String(chatId));
      if (qh && qh.quiet_enabled) text += `Cisza nocna: W≈ÅƒÑCZONA, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00

`;
      else text += "Cisza nocna: wy≈ÇƒÖczona

";
    } else {
      text += "Cisza nocna: wy≈ÇƒÖczona

";
    }
  } catch (e) {
    console.error("buildStatusMessage quiet_hours error", e);
    text += "Cisza nocna: (b≈ÇƒÖd odczytu)

";
  }

  // lista link√≥w
  try {
    const resLinks = await dbQuery(
      `
      SELECT l.id, l.name, l.source, l.active, lnm.mode AS link_mode
      FROM links l
      LEFT JOIN link_notification_modes lnm
        ON lnm.user_id=l.user_id AND lnm.chat_id=$2 AND lnm.link_id=l.id
      WHERE l.user_id=$1 AND l.active=true
      ORDER BY l.id ASC
      `,
      [userId, String(chatId)]
    );

    text += "W≈ÇƒÖczone wyszukiwania:
";
    if (!resLinks.rowCount) {
      text += "‚Ä¢ (brak)

";
    } else {
      for (const r of resLinks.rows) {
        const m = String(r.link_mode || "");
        const mode = (m.toLowerCase() === "batch") ? "zbiorczo"
                  : (m.toLowerCase() === "single") ? "pojedynczo"
                  : chatDefaultMode;
        const src = String(r.source || "").toUpperCase();
        text += `‚Ä¢ ‚úÖ ${r.id} ‚Äì ${esc(r.name || "Monitorowanie")} (${src}) ‚Äì tryb na tym czacie: ${mode}
`;
      }
      text += "
";
    }

    text += "Tryb per link zmienisz: /pojedyncze_ID /zbiorcze_ID /off_ID (np. /zbiorcze_18)";
  } catch (e) {
    console.error("buildStatusMessage links list error", e);
    text += "W≈ÇƒÖczone wyszukiwania: (b≈ÇƒÖd odczytu)
";
  }

  return text;
}




async function buildStatusMessageLegacy(chatId, user) {
  const userId = user.id;

  // FYD_LIMITS_V3
  let addonQty = 0;
  try {
    const r = await dbQuery(
      `SELECT COALESCE(addon_qty,0) AS addon_qty
       FROM subscriptions
       WHERE user_id=$1 AND status='active'
         AND (current_period_end IS NULL OR current_period_end > NOW())
       ORDER BY current_period_end DESC NULLS LAST, updated_at DESC
       LIMIT 1`,
      [Number(userId)]
    );
    addonQty = Number(r.rows?.[0]?.addon_qty || 0) || 0;
  } catch (e) { addonQty = 0; }
  const dailyLimit = 200 + addonQty * 100;
  // FYD_PLAN_FEATURE_LIMITS_V4 (base z plan_features + addony)
  let baseLinks = 0;
  let baseOffers = 0;
  try {
    const rBase = await dbQuery(
      `
      SELECT
        MAX(CASE WHEN f.feature_key='links_limit' THEN f.feature_value END) AS links_limit,
        MAX(CASE WHEN f.feature_key='history_keep_per_link' THEN f.feature_value END) AS history_keep_per_link
      FROM subscriptions s
      JOIN plans p ON p.id = s.plan_id
      LEFT JOIN plan_features f ON f.plan_id = p.id
      WHERE s.user_id = $1
        AND s.status = 'active'
        AND (s.current_period_end IS NULL OR s.current_period_end > NOW())
      GROUP BY p.id
      LIMIT 1
      `,
      [Number(userId)]
    );
    if (rBase.rowCount) {
      baseLinks = Number(rBase.rows[0].links_limit || 0) || 0;
      baseOffers = Number(rBase.rows[0].history_keep_per_link || 0) || 0;
    // Fallback: je≈õli z jakiego≈õ powodu query wy≈ºej nie zwr√≥ci≈Ço warto≈õci (0/0),
    // bierzemy bazƒô z aktywnej subskrypcji -> plan_features.
    if (!baseLinks && !baseOffers) {
      try {
        const r2 = await dbQuery(
          `
          SELECT
            MAX(CASE WHEN f.feature_key='links_limit' THEN f.feature_value::int END) AS links_limit,
            MAX(CASE WHEN f.feature_key='history_keep_per_link' THEN f.feature_value::int END) AS history_keep_per_link
          FROM subscriptions s
          JOIN plans p ON p.id=s.plan_id
          LEFT JOIN plan_features f ON f.plan_id=p.id
          WHERE s.user_id=$1 AND s.status='active'
            AND (s.current_period_end IS NULL OR s.current_period_end > NOW())
          `,
          [Number(userId)]
        );
        baseLinks = Number(r2.rows?.[0]?.links_limit || 0) || 0;
        baseOffers = Number(r2.rows?.[0]?.history_keep_per_link || 0) || 0;
      } catch (e) {}
    }

    }
  } catch (e) {
    baseLinks = 0;
    baseOffers = 0;
  }

  const totalLinksLimit = baseLinks + addonQty * 10;
  const totalOffersLimit = baseOffers + addonQty * 100;

  const tgId = String(user?.telegram_user_id || "");

  // Plan + limity z user_entitlements_v
  let ent = tgId ? await getUserEntitlementsByTelegramId(tgId) : null;

  // fallback zgodno≈õci wstecz (gdyby view chwilowo nie zwr√≥ci≈Ç)
  if (!ent && tgId) {
    const up = await getUserWithPlanByTelegramId(tgId);
    if (up) ent = { plan_code: up.plan_code || up.plan, expires_at: up.expires_at || up.plan_expires_at };
  }

  const lines = [];

  let text = "‚ÑπÔ∏è Status bota\n\n";

  let chatDefaultMode = "pojedynczo"; // fallback


  // 1) Plan (linia pod nag≈Ç√≥wkiem)
  const planPart = formatEntitlementsStatus(ent);
  if (planPart) text += planPart + "\n\n";
  // 1b) Liczniki link√≥w (limit = ≈ÇƒÖcznie, osobno: w≈ÇƒÖczone)
  try {
    const totalLinks = await countActiveLinksForUserId(userId); // ≈ÇƒÖcznie (limit)
    const enabledLinks = await countEnabledLinksForUserId(userId); // active=TRUE
    const limitTotal = Number(ent?.links_limit_total ?? 0);

    text +=
      `Aktywne wyszukiwania (w≈ÇƒÖczone): ${enabledLinks}/${totalLinksLimit}
` +
      `≈ÅƒÖcznie wyszukiwa≈Ñ (w bazie): ${totalLinks}/${totalLinksLimit}

`;
  } catch (e) {
    console.error("buildStatusMessage: link counters error", e);
  }



  // 2) Ustawienia powiadomie≈Ñ dla TEGO czatu
  const todayStr = new Date().toISOString().slice(0, 10);
try {
    const res = await dbQuery(
      `
      SELECT enabled, mode, daily_count, daily_count_date
      FROM chat_notifications
      WHERE chat_id = $1 AND user_id = $2
      `,
      [String(chatId), userId]
    );

    if (!res.rowCount) {
      text +=
        "Ten czat: brak konfiguracji.\n" +
        "Domy≈õlnie: powiadomienia W≈ÅƒÑCZONE, tryb: pojedynczo, 0/${dailyLimit} dzisiaj.\n" +
        "Skonfigurujesz to komendami /on /off /pojedyncze /zbiorcze.\n\n";
    } else {
      const row = res.rows[0];
      const enabled = row.enabled !== false;
const mode =
  (row.mode || "single").toLowerCase() === "batch" ? "zbiorczo" : "pojedynczo";
chatDefaultMode = mode;

      let daily = row.daily_count || 0;
      let dateStr = null;
      if (row.daily_count_date) {
        dateStr = row.daily_count_date.toISOString
          ? row.daily_count_date.toISOString().slice(0, 10)
          : String(row.daily_count_date).slice(0, 10);
      }
      if (dateStr !== todayStr) daily = 0;

            const totalOffers = (() => {
        const raw =
          (typeof ent !== "undefined" && ent && (ent.plan_code || ent.planCode || ent.plan_name))
            ? (ent.plan_code || ent.planCode || ent.plan_name)
            : (typeof planName !== "undefined" ? planName : "");
        let code = String(raw || "").toLowerCase();
        if (code === "basic") code = "starter";
        if (code === "pro") code = "growth";

        // Platinum bazowo 800 ofert/mies.
        const baseOffers =
          code.includes("platinum") ? 800 :
          code.includes("growth") ? 400 :
          code.includes("starter") ? 200 :
          code.includes("trial") ? 100 : 0;

        return baseOffers + addonQty * 100;
      })();

      text +=
        `${enabled ? "‚úÖ Powiadomienia W≈ÅƒÑCZONE" : "‚õî Powiadomienia WY≈ÅƒÑCZONE"}\n` +
        `Tryb domy≈õlny na tym czacie: ${mode}\n` +
        `Dzisiejsze powiadomienia: ${daily}/${dailyLimit}
` +
        `≈ÅƒÖczny limit ofert w planie: ${offersLimitTotalStatus}
` +
        "Zmiana: /on /off /pojedyncze /zbiorcze\n\n";
    }
  } catch (e) {
    console.error("buildStatusMessage: chat_notifications error", e);
    text += "Ustawienia powiadomie≈Ñ: (b≈ÇƒÖd odczytu)\n\n";
  }

  // 2b) Cisza nocna
  try {
    const qh = await getQuietHours(String(chatId));
    if (qh && qh.quiet_enabled) {
      text += `Cisza nocna: W≈ÅƒÑCZONA, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00\n\n`;
    } else {
      text += "Cisza nocna: wy≈ÇƒÖczona\n\n";
    }
  } catch (e) {
    console.error("buildStatusMessage: quiet_hours error", e);
    text += "Cisza nocna: (b≈ÇƒÖd odczytu)\n\n";
  }
  // 3) Lista link√≥w ≈ÇƒÖcznie usera + tryb per-link w tym czacie
  try {
    const resLinks = await dbQuery(
      `
      SELECT
        l.id,
        l.name,
        l.url,
        l.source,
        l.active,
        lnm.mode AS link_mode
      FROM links l
      LEFT JOIN LATERAL (
        SELECT mode
        FROM link_notification_modes
        WHERE user_id = l.user_id
          AND chat_id = $1
          AND link_id = l.id
        ORDER BY updated_at DESC
        LIMIT 1
      ) lnm ON TRUE
      WHERE l.user_id = $2
      ORDER BY l.active DESC, l.id ASC
      `,
      [String(chatId), userId]
    );

    const rows = resLinks.rows || [];
    const enabledOnly = rows.filter((r) => r.active);

    text += "W≈ÇƒÖczone wyszukiwania:\n";

    if (!enabledOnly.length) {
      text += "(brak)\n\n";
    } else {
      for (const r of enabledOnly) {
        const src = String(r.source || "").toUpperCase();
        const linkModeRaw = String(r.link_mode || "").toLowerCase();

        // domy≈õlny tryb czatu jest ju≈º w chatDefaultMode: "pojedynczo" / "zbiorczo"
        let effectiveMode = chatDefaultMode;

        if (linkModeRaw === "off") effectiveMode = "off";
        else if (linkModeRaw === "batch") effectiveMode = "zbiorczo";
        else if (linkModeRaw === "single") effectiveMode = "pojedynczo";

        const nm = escapeHtml(r.name || "Monitorowanie");
        text += `‚Ä¢ ‚úÖ ${r.id} ‚Äì ${nm} (${src || "-"}) ‚Äì tryb na tym czacie: ${effectiveMode}\n`;
      }
      text += "\n";
    }

    text +=
      "Tryb per link zmienisz: /pojedyncze_ID /zbiorcze_ID /off_ID (np. /zbiorcze_18)\n";
  } catch (e) {
    console.error("buildStatusMessage: links error", e);
    text += "W≈ÇƒÖczone wyszukiwania: (b≈ÇƒÖd odczytu)\n\n";
  }

  return text.trim();
}

// ---------- /help /start ----------
async function handleStartActivation(ctx, maybeUserOrToken, maybeToken) {
  const tgUserId = ctx?.from?.id;
  if (!tgUserId) {
    await ctx.reply("‚ùå Brak danych u≈ºytkownika Telegram.");
    return;
  }

  const actToken = String((maybeToken ?? maybeUserOrToken) || "").trim();
  if (!actToken) {
    await ctx.reply("‚ùå Brak tokena aktywacyjnego.");
    return;
  }

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    const tokRes = await client.query(
      `SELECT token, plan_id, provider, provider_ref, expires_at, used_at, used_by_telegram_user_id
       FROM activation_tokens
       WHERE token=$1
       FOR UPDATE`,
      [actToken]
    );

    if (tokRes.rowCount === 0) {
      await client.query("ROLLBACK");
      await ctx.reply("‚ùå Nieprawid≈Çowy kod aktywacyjny.");
      return;
    }

    const t = tokRes.rows[0];



// UPSERT subskrypcji planu
    // FYD_ACTIVATION_ADDON10_SAFE_V2
    // Token addon10 ma zwiƒôkszyƒá addon_qty, a NIE aktywowaƒá planu (ani zerowaƒá addon_qty).
    const providerRefActAddon = String(t.provider_ref || "");
    const isAddon10ActAddon =
      providerRefActAddon.includes("kind:addon10") || providerRefActAddon.startsWith("addon10:");
    if (isAddon10ActAddon) {
      const subQ = await client.query(
        "SELECT id, COALESCE(addon_qty,0) AS addon_qty FROM subscriptions WHERE user_id=$1 AND status='active' ORDER BY updated_at DESC LIMIT 1",
        [userId]
      );
      if (!subQ.rowCount) {
        await client.query("ROLLBACK");
        await ctx.reply("‚ùå Nie masz aktywnej subskrypcji ‚Äî najpierw aktywuj plan Platinum.");
        return;
      }

      const current = Number(subQ.rows[0].addon_qty || 0) || 0;
      const newQty = current + 1;

      await client.query(
        "UPDATE subscriptions SET addon_qty=$2, updated_at=NOW() WHERE id=$1",
        [subQ.rows[0].id, newQty]
      );

      if (!t.used_at) {
        await client.query(
          "UPDATE activation_tokens SET used_at=NOW(), used_by_telegram_user_id=$2 WHERE token=$1",
          [actToken, tgUserId]
        );
      }

      await client.query("COMMIT");
      await ctx.reply(`‚úÖ Aktywowano dodatek +10 link√≥w (≈ÇƒÖcznie dodatk√≥w: ${newQty}). U≈ºyj /status, ≈ºeby zobaczyƒá aktualny limit.`);
      return;
    }

    await client.query(
      `INSERT INTO subscriptions
         (user_id, plan_id, provider, provider_customer_id, provider_subscription_id, status, current_period_end, created_at, updated_at, addon_qty)
       VALUES
         ($1, $2, $3, $4, $5, 'active', NOW() + INTERVAL '1 month', NOW(), NOW(), 0)
       ON CONFLICT (provider, provider_subscription_id)
       DO UPDATE SET
         user_id=EXCLUDED.user_id,
         plan_id=EXCLUDED.plan_id,
         provider_customer_id=EXCLUDED.provider_customer_id,
         status='active',
         current_period_end=EXCLUDED.current_period_end,
         updated_at=NOW()`,
      [userId, plan.id, provider, stripeCustomerId, providerSubId]
    );

    await client.query(
      `UPDATE users
       SET plan=$2,
           plan_name=$3,
           plan_expires_at=NOW() + INTERVAL '1 month',
           plan_until=NOW() + INTERVAL '1 month'
       WHERE id=$1`,
      [userId, plan.code, plan.name]
    );

    if (!t.used_at) {
      await client.query(
        `UPDATE activation_tokens
         SET used_at=NOW(), used_by_telegram_user_id=$2
         WHERE token=$1`,
        [actToken, tgUserId]
      );
    }

    await client.query("COMMIT");
    await ctx.reply(`‚úÖ Aktywowano plan ${plan.name}. U≈ºyj /status, ≈ºeby zobaczyƒá aktualny limit.`);
  } catch (err) {
    try { await client.query("ROLLBACK"); } catch (_) {}
    console.error("handleStartActivation error:", err);
    await ctx.reply("‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas aktywacji. Spr√≥buj ponownie za chwilƒô.");
  } finally {
    client.release();
  }
}

async function handleAddon10(msg, user) {
  const chatId = msg.chat.id;

  try {
    const ent = await getUserEntitlementsByTelegramId(Number(msg.from.id));
    
  // FYD_STATUS_LIMITS_V4
  let addonQtyStatus = 0;
  try {
    const rSub = await dbQuery(
      `SELECT COALESCE(addon_qty,0) AS addon_qty
       FROM subscriptions
       WHERE user_id=$1 AND status='active'
         AND (current_period_end IS NULL OR current_period_end > NOW())
       ORDER BY current_period_end DESC NULLS LAST, updated_at DESC
       LIMIT 1`,
      [Number(userId)]
    );
    addonQtyStatus = Number(rSub.rows?.[0]?.addon_qty || 0) || 0;
  } catch (e) {}

  let planCodeStatus = String(ent?.plan_code || ent?.plan || ent?.code || "").toLowerCase();
  if (planCodeStatus === "basic") planCodeStatus = "starter";
  if (planCodeStatus === "pro") planCodeStatus = "growth";
  if (!planCodeStatus && typeof planName !== "undefined") planCodeStatus = String(planName || "").toLowerCase();
  if (planCodeStatus.includes("platinum")) planCodeStatus = "platinum";
  if (planCodeStatus.includes("growth")) planCodeStatus = "growth";
  if (planCodeStatus.includes("starter")) planCodeStatus = "starter";
  if (planCodeStatus.includes("trial")) planCodeStatus = "trial";

  let baseLinksStatus = 0;
  let baseOffersStatus = 0;
  try {
    const rBase = await dbQuery(
      `SELECT
         MAX(CASE WHEN f.feature_key='links_limit' THEN f.feature_value::int END) AS links_limit,
         MAX(CASE WHEN f.feature_key='history_keep_per_link' THEN f.feature_value::int END) AS history_keep_per_link
       FROM plans p
       LEFT JOIN plan_features f ON f.plan_id=p.id
       WHERE p.code=$1`,
      [planCodeStatus]
    );
    baseLinksStatus = Number(rBase.rows?.[0]?.links_limit || 0) || 0;
    baseOffersStatus = Number(rBase.rows?.[0]?.history_keep_per_link || 0) || 0;
  } catch (e) {}

  // fallback (Platinum)
  if (!baseLinksStatus && planCodeStatus === "platinum") baseLinksStatus = 40;
  if (!baseOffersStatus && planCodeStatus === "platinum") baseOffersStatus = 800;

  const linksLimitTotalStatus = baseLinksStatus + addonQtyStatus * 10;
  const offersLimitTotalStatus = baseOffersStatus + addonQtyStatus * 100;
  const dailyLimitStatus = 200 + addonQtyStatus * 100;

const code = String(ent?.plan_code || "").toLowerCase();

    if (code !== "platinum") {
      await tgSend(chatId, "‚ùå ADDON +10 link√≥w jest dostƒôpny tylko dla planu Platinum.");
      return;
    }

    const addonPrice = process.env.FYD_PRICE_ADDON10 || "";
    const sk = process.env.STRIPE_SECRET_KEY || "";
    if (!addonPrice || !sk) {
      await tgSend(chatId, "‚ùå B≈ÇƒÖd konfiguracji (brak FYD_PRICE_ADDON10 lub STRIPE_SECRET_KEY).");
      return;
    }

    // znajd≈∫ subskrypcjƒô Stripe usera
    const u = await getUserByTelegramId(Number(msg.from.id));
    if (!u?.id) {
      await tgSend(chatId, "‚ùå Nie widzƒô Ciƒô w bazie. U≈ºyj /start.");
      return;
    }

    const subRes = await dbQuery(
      "SELECT provider_subscription_id FROM subscriptions WHERE user_id=$1 ORDER BY created_at DESC LIMIT 1",
      [Number(u.id)]
    );
    const subId = subRes.rows[0]?.provider_subscription_id || "";
    if (!subId) {
      await tgSend(chatId, "‚ùå Nie znalaz≈Çem Twojej subskrypcji Stripe. Skontaktuj siƒô z obs≈ÇugƒÖ.");
      return;
    }

    // pobierz subskrypcjƒô i sprawd≈∫ itemy
    const subRaw = await fetch(`https://api.stripe.com/v1/subscriptions/${subId}?expand[]=items`, {
      headers: { "Authorization": `Bearer ${sk}` },
    });
    const sub = await subRaw.json();
    const items = sub?.items?.data || [];

    let addonItem = items.find(it => String(it?.price?.id || "") === addonPrice);

    if (!addonItem) {
      // dodaj nowy item addon (qty=1)
      const body = new URLSearchParams();
      body.set("items[0][price]", addonPrice);
      body.set("items[0][quantity]", "1");

      const r = await fetch(`https://api.stripe.com/v1/subscriptions/${subId}`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${sk}`, "Content-Type": "application/x-www-form-urlencoded" },
        body,
      });
      const j = await r.json();
      if (!j?.id) throw new Error(j?.error?.message || "stripe_update_failed");
    } else {
      // inkrementuj qty +1
      const oldQ = Number(addonItem.quantity || 0);
      const body = new URLSearchParams();
      body.set("quantity", String(oldQ + 1));
      const r = await fetch(`https://api.stripe.com/v1/subscription_items/${addonItem.id}`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${sk}`, "Content-Type": "application/x-www-form-urlencoded" },
        body,
      });
      const j = await r.json();
      if (!j?.id) throw new Error(j?.error?.message || "stripe_item_update_failed");
    }

    // nadaj od razu uprawnienie w systemie (+1 paczka)
    await dbQuery(
      "UPDATE users SET extra_link_packs = COALESCE(extra_link_packs,0) + 1, updated_at=NOW() WHERE id=$1",
      [Number(u.id)]
    );

    await tgSend(chatId, "‚úÖ Dokupiono ADDON +10 link√≥w (+20 PLN/mies). U≈ºyj /status, ≈ºeby zobaczyƒá nowy limit.");
    const fresh = await getUserWithPlanByTelegramId(Number(msg.from.id));
    await handleStatus(msg, fresh || user);
  } catch (e) {
    console.log("[addon10] error", e?.message || e);
    await tgSend(chatId, "‚ùå Nie uda≈Ço siƒô dokupiƒá dodatku. Spr√≥buj ponownie za chwilƒô.");
  }
}



async function handleStart(msg, user, argText) {
  const chatId = msg.chat.id;

  // Telegram deep-link: /start act_<token>
  const payload = String(argText || "").trim();
  // /start addon10  -> dokup +10 link√≥w (Platinum-only)
  if (payload === "addon10") {
    await handleAddon10(msg, user);
    return;
  }

  const m = payload.match(/act_([0-9a-f]{32,80})/i);

  // zwyk≈Çy /start -> help
  if (!m) {
    await handleHelp(msg);
    return;
  }

  const token = m[1];

  // token z DB
  const tokRes = await dbQuery(
    `SELECT token, plan_id, provider, provider_ref, expires_at, used_at, used_by_telegram_user_id
     FROM activation_tokens
     WHERE token = $1
     LIMIT 1`,
    [token]
  );

  if (!tokRes.rowCount) {
    await tgSend(chatId, "‚ùå Nieprawid≈Çowy lub nieznany kod aktywacyjny.");
    return;
  }

  const t = tokRes.rows[0];
  // Stripe safeguard: token musi byƒá potwierdzony webhookiem (provider_ref zawiera 'sub:')
  if (String(t.provider || "") === "stripe") {
    const pref = String(t.provider_ref || "");
    if (!pref.includes("sub:")) {
      try { await client.query("ROLLBACK"); } catch {}
      await ctx.reply("‚è≥ P≈Çatno≈õƒá jeszcze niepotwierdzona. Op≈Çaƒá checkout i spr√≥buj ponownie za chwilƒô.");
      return;
    }
  }


  if (t.used_at) {
        const usedBy = t.used_by_telegram_user_id;
        const me = (msg && msg.from && msg.from.id) ? Number(msg.from.id) : 0;
        if (usedBy && me && Number(usedBy) === me) {
          
// [activate] ensure-subscription-from-token
  try {
    // nawet je≈õli token by≈Ç ju≈º u≈ºyty przez tego samego usera, dopnij subskrypcjƒô do DB,
    // bo /status bierze plan z subscriptions/entitlements
    const pref2 = String(t?.provider_ref || "");
    const subId2 = (pref2.match(/sub:([A-Za-z0-9_]+)/) || [])[1] || null;
    const planId2 = Number(t?.plan_id) || 0;

    if (subId2 && planId2 && user?.id) {
      await dbQuery(
        `INSERT INTO subscriptions (user_id, plan_id, provider_subscription_id, created_at)
         VALUES ($1, $2, $3, NOW())
         ON CONFLICT (provider_subscription_id) DO UPDATE
           SET user_id = EXCLUDED.user_id,
               plan_id = EXCLUDED.plan_id`,
        [Number(user.id), planId2, subId2]
      );
    }
  } catch (e) {
    console.log("[activate] ensure subscription error", e?.message || e);
  }


    // [AUTO] ensure subscriptions row for /status (FYD_UPGRADE_SUBSCRIPTIONS_UPSERT_V1)
    try {
      const pref = String(t?.provider_ref || "");
      const provider = String(t?.provider || "stripe") || "stripe";
      const subId = (pref.match(/sub:([A-Za-z0-9_]+)/) || [])[1] || null;
      const planId = Number(t?.plan_id) || 0;
      const customerId = (pref.match(/customer:([A-Za-z0-9_]+)/) || [])[1] || null;

      // tylko dla token√≥w plan√≥w (nie addon10)
      if (subId && planId && user?.id && !pref.startsWith("addon10:") && !pref.startsWith("addon10_applied:")) {
        // cancel poprzednie aktywne (upgrade/downgrade)
        await dbQuery(
          `UPDATE subscriptions
           SET status='canceled', updated_at=NOW()
           WHERE user_id=$1 AND status='active'`,
          [Number(user.id)]
        );

        // upsert nowej aktywnej
        await dbQuery(
          `INSERT INTO subscriptions
             (user_id, plan_id, provider, provider_customer_id, provider_subscription_id, status, current_period_end, created_at, updated_at, addon_qty)
           VALUES
             ($1,$2,$3,$4,$5,'active', NOW() + INTERVAL '1 month', NOW(), NOW(), 0)
           ON CONFLICT (provider, provider_subscription_id) DO UPDATE
             SET user_id=EXCLUDED.user_id,
                 plan_id=EXCLUDED.plan_id,
                 provider_customer_id=EXCLUDED.provider_customer_id,
                 status='active',
                 current_period_end=EXCLUDED.current_period_end,
                 updated_at=NOW()`,
          [Number(user.id), planId, provider, customerId, subId]
        );
      }
    } catch (e) {
      console.log("[activate] ensure subscriptions error", e?.message || e);
    }


  // FYD_ADDON10_PATCH_BEFORE_ALREADY_ASSIGNED_V1
  try {
    const __pref = String(t?.provider_ref || "");
    if (__pref.startsWith("addon10_applied:")) {
      await tgSend(chatId, "‚úÖ Ten addon jest ju≈º naliczony na Twoim koncie.");
      return;
    }
    if (__pref.startsWith("addon10:")) {
      if (!user?.id) {
        await tgSend(chatId, "‚ùå Brak u≈ºytkownika w bazie (user.id).");
        return;
      }

      // tylko dla Platinum
      const __ent = await dbQuery(
        "SELECT plan_code FROM public.user_entitlements_v WHERE user_id=$1 LIMIT 1",
        [Number(user.id)]
      );
      const __plan = String(__ent.rows?.[0]?.plan_code || "free");
      if (__plan !== "platinum") {
        await tgSend(chatId, "‚õî Addon +10 jest dostƒôpny tylko dla u≈ºytkownik√≥w Platinum.");
        return;
      }

      // nalicz addon do aktywnej subskrypcji
      const __up = await dbQuery(
        `UPDATE subscriptions
         SET addon_qty = COALESCE(addon_qty,0) + 1,
             updated_at = NOW()
         WHERE user_id = $1
           AND status = 'active'
           AND (current_period_end IS NULL OR current_period_end > NOW())
         RETURNING addon_qty`,
        [Number(user.id)]
      );
      if (!__up.rowCount) {
        await tgSend(chatId, "‚ùå Brak aktywnej subskrypcji do dopiƒôcia addona.");
        return;
      }

      const __rest = __pref.slice("addon10:".length);
      await dbQuery(
        "UPDATE activation_tokens SET provider_ref=$2 WHERE token=$1",
        [t.token, "addon10_applied:" + __rest]
      );

      // token mo≈ºe ju≈º mieƒá used_at ‚Äî nie szkodzi, ale dociƒÖgamy u≈ºycie je≈õli brak
      if (!t.used_at) {
        await dbQuery(
          "UPDATE activation_tokens SET used_at=NOW(), used_by_telegram_user_id=$2 WHERE token=$1",
          [t.token, tgUserId]
        );
      }

      await tgSend(chatId, "‚úÖ Dodano addon +10 (linki) i +100 (oferty). Sprawd≈∫ /status.");
      return;
    }
  } catch (e) {
    console.log("[addon10-before-already] error", e?.message || e);
  }

await tgSend(chatId, "‚úÖ Ten kod jest ju≈º przypisany do Twojego konta.");
          return;
        }
        await tgSend(chatId, "‚ö†Ô∏è Ten kod zosta≈Ç ju≈º u≈ºyty.");
        return;
      }

  const exp = t.expires_at ? new Date(t.expires_at) : null;
  if (exp && !Number.isNaN(exp.getTime()) && exp.getTime() < Date.now()) {
    await tgSend(chatId, "‚ùå Ten kod wygas≈Ç. Skontaktuj siƒô z obs≈ÇugƒÖ.");
    return;
  }

  const planId = Number(t.plan_id) || 0;
  if (!planId) {
    await tgSend(chatId, "‚ùå Kod nie ma przypisanego planu (b≈ÇƒÖd konfiguracji).");
    return;
  }

  // plan code/name z tabeli plans
  const pRes = await dbQuery(`SELECT code, name FROM plans WHERE id = $1 LIMIT 1`, [planId]);
  const planCode = String(pRes.rows[0]?.code || "free");
  const planName = String(pRes.rows[0]?.name || planCode);

  // addon_packs + stripe customer/sub z provider_ref (je≈õli sƒÖ)
  const pref = String(t.provider_ref || "");
  const addonPacks = parseInt((pref.match(/addon_packs=(\d+)/) || [])[1] || "0", 10) || 0;
  const stripeCustomerId = (pref.match(/customer:([A-Za-z0-9_]+)/) || [])[1] || null;

  // aktualizuj u≈ºytkownika: plan + przed≈Çu≈ºenie o 30 dni od MAX(now, obecna data)
  await dbQuery(
    `UPDATE users
     SET
       plan = $1,
       plan_name = $2,
       plan_started_at = COALESCE(plan_started_at, NOW()),
       plan_expires_at = (GREATEST(COALESCE(plan_expires_at, NOW()), NOW()) + INTERVAL '30 days'),
       extra_link_packs = COALESCE(extra_link_packs, 0) + $3,
       stripe_customer_id = COALESCE(stripe_customer_id, $4),
       updated_at = NOW()
     WHERE telegram_user_id = $5`,
    [planCode, planName, addonPacks, stripeCustomerId, Number(msg.from.id)]
  );

  // oznacz token jako u≈ºyty
  await dbQuery(
    `UPDATE activation_tokens
     SET used_at = NOW(), used_by_telegram_user_id = $2
     WHERE token = $1 AND used_at IS NULL`,
    [token, Number(msg.from.id)]
  );

  await tgSend(
    chatId,
    `‚úÖ Aktywowano plan <b>${escapeHtml(planName)}</b>.\n` +
      (addonPacks ? `‚ûï Dodatki: <b>${addonPacks}√ó</b> paczka +10 link√≥w.\n` : "") +
      `U≈ºyj /status, ≈ºeby zobaczyƒá aktualny limit.`
  );

  // poka≈º status po aktywacji (od≈õwie≈º user)
  const fresh = await getUserWithPlanByTelegramId(Number(msg.from.id));
  await handleStatus(msg, fresh || user);
}



async function handleHelp(msg) {
  // [activate] start deep-link hook
  try {
    const text = String(msg?.text || "");
    const m = text.match(/^\/start\s+(act_[A-Za-z0-9]+)\s*/);
    if (m) {
      const u = await ensureUser(msg.from);
      await handleStartActivation(msg, u, m[1]);
      await handleStatus(msg, u);
      return;
    }
  } catch (e) {
    console.log("[activate] hook error", e?.message || e);
  }

  const chatId = msg.chat.id;

  if (Number(chatId) < 0) {
    console.warn("Group chat blocked:", chatId);
    return;
  }
  const text =
    "üëã Cze≈õƒá! To bot FindYourDeal.\n\n" +

    "Podstawowe komendy:\n" +
    "/lista ‚Äì poka≈º Twoje aktywne monitorowane linki\n" +
    "/usun &lt;ID&gt; ‚Äì wy≈ÇƒÖcz monitorowanie linku o ID\n" +
    "/dodaj &lt;url&gt; [nazwa] ‚Äì dodaj nowy link do monitorowania\n" +
    "/status ‚Äì status bota, planu i powiadomie≈Ñ\n\n" +
    "Powiadomienia PUSH na tym czacie:\n" +
    "/on ‚Äì w≈ÇƒÖcz\n" +
    "/off ‚Äì wy≈ÇƒÖcz\n" +
    "/pojedyncze ‚Äì pojedyncze karty\n" +
    "/zbiorcze ‚Äì zbiorcza lista\n\n" +
    "Tryb per-link (TYLKO na tym czacie):\n" +
    "/pojedyncze_ID, /zbiorcze_ID, /off_ID (np. /zbiorcze_18)\n\n" +
    "Cisza nocna:\n" +
    "/cisza ‚Äì poka≈º\n" +
    "/cisza HH-HH ‚Äì ustaw (np. /cisza 22-7)\n" +
    "/cisza_off ‚Äì wy≈ÇƒÖcz\n\n" +
    "Historia:\n" +
    "/najnowsze &lt;ID&gt; ‚Äì najnowsze oferty z historii linku\n\n" +
    "Przyk≈Çady:\n" +
    "<code>/lista</code>\n" +
    "<code>/usun 18</code>\n" +
    "<code>/dodaj https://www.olx.pl/oferty/?q=iphone14 iPhone 14 OLX</code>\n" +
    "<code>/najnowsze 18</code>";

  await tgSend(chatId, text);
}

// ---------- /lista ----------

async function handleLista(msg, user) {
  const chatId = msg.chat.id;

  try {
    const links = await getLinksByUserId(user.id, true);

    if (!links.length) {
      await tgSend(chatId, "Nie masz jeszcze ≈ºadnych link√≥w ≈ÇƒÖcznie.");
      return;
    }

    let text = "üìã Aktywne monitorowane linki:\n\n";
    for (const row of links) {
      text += `ID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}\n`;
      text += `<code>${escapeHtml(row.url)}</code>\n\n`;
    }
    text += "Wy≈ÇƒÖcz: <code>/usun ID</code>\nnp. <code>/usun 18</code>";

    await tgSend(chatId, text);
  } catch (err) {
    console.error("handleLista error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy pobieraniu listy link√≥w.");
  }
}

// ---------- /usun ----------

async function handleUsun(msg, user, argText) {
  const chatId = msg.chat.id;
  const id = parseInt(argText, 10);

  if (!id) {
    await tgSend(chatId, "Podaj ID linku, np.:\n<code>/usun 18</code>");
    return;
  }

  try {
    const row = await deactivateLinkForUserId(id, user.id);

    if (!row) {
      await tgSend(
        chatId,
        `Nie znalaz≈Çem linku o ID <b>${id}</b> na Twoim koncie. U≈ºyj /lista.`
      );
      return;
    }

    let text = "‚úÖ Wy≈ÇƒÖczy≈Çem monitorowanie linku:\n\n";
    text += `ID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}\n`;
    text += `<code>${escapeHtml(row.url)}</code>\n\n`;
    text += "Mo≈ºesz go w≈ÇƒÖczyƒá ponownie w panelu albo dodaƒá ponownie jako nowe monitorowanie.";

    await tgSend(chatId, text);
  } catch (err) {
    console.error("handleUsun error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy wy≈ÇƒÖczaniu linku.");
  }
}

// ---------- /dodaj ----------

async function handleDodaj(msg, user, argText) {
  const chatId = msg.chat.id;

  if (!argText) {
    await tgSend(
      chatId,
      "U≈ºycie:\n<code>/dodaj &lt;url&gt; [nazwa]</code>\n\n" +
        "Przyk≈Çad:\n" +
        "<code>/dodaj https://www.olx.pl/oferty/?q=iphone14 iPhone 14 OLX</code>"
    );
    return;
  }

  const parts = argText.split(/\s+/);
  const url = parts[0];
  const name = parts.slice(1).join(" ") || null;

  if (!url || !/^https?:\/\//i.test(url)) {
    await tgSend(
      chatId,
      "Pierwszy parametr musi byƒá poprawnym URL, np.:\n" +
        "<code>/dodaj https://www.olx.pl/oferty/?q=iphone14 iPhone 14 OLX</code>"
    );
    return;
  }

  // ENTITLEMENTS = ≈∫r√≥d≈Ço prawdy o planie i limitach
  const tgId = user?.telegram_user_id;
  const ent = await getUserEntitlementsByTelegramId(tgId);

  const planCode = String(ent?.plan_code || "free").toLowerCase();
  const limit = Number(ent?.links_limit_total ?? 0);

  if (!ent || limit <= 0) {
    // Trial wygas≈Ç / Free / brak planu
    if (planCode === "trial" && user?.trial_used) {
      await tgSend(
        chatId,
        [
          "‚è∞ Tw√≥j plan Trial wygas≈Ç.",
          "Monitoring w Trial jest ju≈º niedostƒôpny.",
          "",
          "Aby dalej korzystaƒá z bota, wybierz plan p≈Çatny (Starter / Growth / Platinum).",
        ].join("\n")
      );
      return;
    }

    await tgSend(
      chatId,
      [
        "Nie masz aktywnego planu z monitoringiem link√≥w.",
        user?.trial_used
          ? "Trial zosta≈Ç ju≈º wykorzystany. Wykup plan Starter / Growth / Platinum."
          : "Mo≈ºesz uruchomiƒá jednorazowo Trial (3 dni / 5 link√≥w) albo wybraƒá plan Starter / Growth / Platinum.",
      ].join("\n")
    );
    return;
  }

  // limit link√≥w (liczymy TOTAL z DB ‚Äì tak jak w API)
  const totalLinks = await countActiveLinksForUserId(user.id);

  if (totalLinks >= limit) {
    await tgSend(
      chatId,
      escapeHtml(`OsiƒÖgniƒôto limit link√≥w: ${totalLinks}/${limit}`)
    );
    return;
  }

  try {
    const row = await insertLinkForUserId(user.id, name, url);

    await tgSend(
      chatId,
      [
        "‚úÖ Doda≈Çem nowy link do monitorowania:",
        "",
        `ID <b>${row.id}</b> ‚Äî ${escapeHtml(row.name || "(bez nazwy)")}`,
        `<code>${escapeHtml(row.url)}</code>`,
        "",
        `Linki (≈ÇƒÖcznie): ${totalLinks + 1}/${limit}`,
        "",
        "Linki sprawdzisz komendƒÖ: <code>/lista</code>",
      ].join("\n")
    );
  } catch (err) {
    console.error("handleDodaj error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy dodawaniu linku.");
  }
}

// ---------- /panel ----------
async function handlePanel(msg, user) {
  const chatId = String(msg.chat.id);

  try {
    const token = randomBytes(24).toString("hex");

    await dbQuery(
      `
      INSERT INTO panel_login_tokens (token, user_id, created_at, expires_at)
      VALUES ($1, $2, NOW(), NOW() + INTERVAL '10 minutes')
      `,
      [token, user.id]
    );

    const url =
      "https://panel.findyourdeal.app/api/auth/login?token=" +
      encodeURIComponent(token);

    await tgSend(chatId, `Panel: ${url}\nToken wa≈ºny 10 minut.`);
  } catch (err) {
    console.error("handlePanel error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy generowaniu linku do panelu.");
  }
}



// ---------- /status ----------

async function handleStatus(msg, user) {
  const chatId = String(msg.chat.id);

  try {
    await ensureChatNotificationsRow(chatId, user.id);
    const statusText = await buildStatusMessage(chatId, user);
    await tgSend(chatId, statusText);
  } catch (err) {
    console.error("handleStatus error:", err);
    await tgSend(chatId, "‚ùå B≈ÇƒÖd przy pobieraniu statusu.");
  }

// (handlePanel moved to top-level)

// expose handlePanel across scopes (hotfix)

}

// ---------- /on /off ----------

async function handleNotificationsOn(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, updated_at)
    VALUES ($1, $2, TRUE, 'single', NOW())
    ON CONFLICT (chat_id, user_id) DO UPDATE SET
      enabled = TRUE,
      updated_at = NOW()
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "‚úÖ Powiadomienia W≈ÅƒÑCZONE na tym czacie.");
}

async function handleNotificationsOff(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    INSERT INTO chat_notifications (chat_id, user_id, enabled, mode, updated_at)
    VALUES ($1, $2, FALSE, 'single', NOW())
    ON CONFLICT (chat_id, user_id) DO UPDATE SET
      enabled = FALSE,
      updated_at = NOW()
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "‚õî Powiadomienia WY≈ÅƒÑCZONE na tym czacie.");
}

// ---------- /pojedyncze /zbiorcze (domy≈õlny tryb czatu) ----------

async function handleModeSingle(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    UPDATE chat_notifications
    SET mode = 'single', updated_at = NOW()
    WHERE chat_id = $1 AND user_id = $2
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "üì® Ustawiono tryb: <b>pojedynczo</b> (domy≈õlny na tym czacie).");
}

async function handleModeBatch(msg, user) {
  const chatId = String(msg.chat.id);

  await ensureChatNotificationsRow(chatId, user.id);

  await dbQuery(
    `
    UPDATE chat_notifications
    SET mode = 'batch', updated_at = NOW()
    WHERE chat_id = $1 AND user_id = $2
    `,
    [chatId, user.id]
  );

  await tgSend(chatId, "üì¶ Ustawiono tryb: <b>zbiorczo</b> (domy≈õlny na tym czacie).");
}

// ---------- tryb per-link na tym czacie ----------

async function setPerLinkMode(chatId, userId, linkId, mode) {
  const m = String(mode || "").toLowerCase();
  const finalMode = m === "batch" ? "batch" : m === "off" ? "off" : "single";

  // zabezpieczenie: link musi nale≈ºeƒá do usera
  const chk = await dbQuery(
    `SELECT id FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
    [Number(linkId), Number(userId)]
  );
  if (!chk.rowCount) return { ok: false, reason: "Link nie nale≈ºy do Twojego konta." };

  await dbQuery(
    `
    INSERT INTO link_notification_modes (user_id, chat_id, link_id, mode, updated_at)
    VALUES ($1, $2, $3, $4, NOW())
    ON CONFLICT (user_id, chat_id, link_id) DO UPDATE SET
      mode = EXCLUDED.mode,
      updated_at = NOW()
    `,
    [Number(userId), String(chatId), Number(linkId), finalMode]
  );

  return { ok: true, mode: finalMode };
}

// ---------- cisza nocna ----------

async function handleQuiet(msg) {
  const chatId = String(msg.chat.id);
  const arg = (msg.text || "").trim().split(/\s+/).slice(1).join(" ").trim();

  if (!arg) {
    const qh = await getQuietHours(chatId);
    if (qh?.quiet_enabled) {
      await tgSend(chatId, `üåô Cisza nocna: <b>W≈ÅƒÑCZONA</b>, godziny ${qh.quiet_from}:00‚Äì${qh.quiet_to}:00`);
    } else {
      await tgSend(chatId, "üåô Cisza nocna: <b>wy≈ÇƒÖczona</b>.\nUstaw: <code>/cisza 22-7</code>");
    }
    return;
  }

  const m = arg.match(/^(\d{1,2})\s*-\s*(\d{1,2})$/);
  if (!m) {
    await tgSend(chatId, "Podaj zakres jako HH-HH, np. <code>/cisza 22-7</code>");
    return;
  }

  const fromHour = Number(m[1]);
  const toHour = Number(m[2]);

  if (
    !Number.isFinite(fromHour) || !Number.isFinite(toHour) ||
    fromHour < 0 || fromHour > 23 || toHour < 0 || toHour > 23
  ) {
    await tgSend(chatId, "Godziny muszƒÖ byƒá w zakresie 0‚Äì23, np. <code>/cisza 22-7</code>");
    return;
  }

  await setQuietHours(chatId, fromHour, toHour);
  await tgSend(chatId, `üåô Ustawiono ciszƒô nocnƒÖ: <b>${fromHour}:00‚Äì${toHour}:00</b>`);
}

async function handleQuietOff(msg) {
  const chatId = String(msg.chat.id);
  await disableQuietHours(chatId);
  await tgSend(chatId, "üåô Cisza nocna: <b>WY≈ÅƒÑCZONA</b>");
}

// ---------- /najnowsze ----------

async function handleNajnowsze(msg, user, argText) {
  const chatId = String(msg.chat.id);
  const linkId = Number(argText);

  if (!Number.isFinite(linkId) || linkId <= 0) {
    await tgSend(chatId, "U≈ºycie: <code>/najnowsze ID</code>\nnp. <code>/najnowsze 18</code>");
    return;
  }

  // link musi nale≈ºeƒá do usera
  const chk = await dbQuery(
    `SELECT id, name, url, source FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
    [linkId, user.id]
  );

  if (!chk.rowCount) {
    await tgSend(chatId, `Nie widzƒô linku <b>${linkId}</b> na Twoim koncie. Sprawd≈∫ <code>/lista</code>.`);
    return;
  }

  const perLimit = getPerLinkItemLimit(user);

  const itemsQ = await dbQuery(
    `
    SELECT title, price, currency, url, first_seen_at
    FROM link_items
    WHERE link_id = $1
    ORDER BY first_seen_at DESC, id DESC
    LIMIT $2
    `,
    [linkId, perLimit]
  );

  const linkRow = chk.rows[0];
  const header = `üßæ Najnowsze oferty\n<b>${escapeHtml(linkRow.name || ("ID " + linkRow.id))}</b> <i>(ID ${linkRow.id})</i>\n`;

  if (!itemsQ.rowCount) {
    await tgSend(chatId, header + "\nBrak zapisanej historii dla tego linku (jeszcze).");
    return;
  }

  // buduj wiadomo≈õƒá (limit d≈Çugo≈õci Telegrama ~4096)
  let out = header + "\n";
  let i = 1;
  for (const it of itemsQ.rows) {
    const title = escapeHtml(it.title || "(bez tytu≈Çu)");
    const priceStr =
      it.price != null ? `${it.price} ${it.currency || ""}`.trim() : "";
    const line =
      `${i}. <b>${title}</b>` +
      (priceStr ? `\nüí∞ ${escapeHtml(priceStr)}` : "") +
      (it.url ? `\n${escapeHtml(it.url)}` : "") +
      "\n\n";

    if ((out + line).length > 3800) {
      out += "‚Ä¶ (uciƒôto ‚Äì limit d≈Çugo≈õci wiadomo≈õci)\n";
      break;
    }
    out += line;
    i++;
  }

  await tgSend(chatId, out.trim(), { disable_web_page_preview: true });
}

// ---------- callback_query z przycisk√≥w (lnmode:ID:mode) ----------

async function handleCallback(update) {
  const cq = update.callback_query;
  if (!cq) return;

  const data = cq.data || "";
  const chatId = cq.message?.chat?.id;
  const fromId = cq.from?.id ? String(cq.from.id) : null;

  if (!chatId || !fromId) {
    await tgAnswerCb(cq.id, "Brak danych czatu/u≈ºytkownika.");
    return;
  }

  const userId = await resolveUserIdFromTg(fromId);
  if (!userId) {
    await tgAnswerCb(cq.id, "Nie widzƒô Ciƒô w bazie. U≈ºyj /start lub /dodaj.");
    return;
  }

  await ensureChatNotificationsRow(String(chatId), userId);

  // lnmode:<linkId>:<off|single|batch>
  const m = data.match(/^lnmode:(\d+):(off|single|batch)$/i);
  if (m) {
    const linkId = Number(m[1]);
    const mode = String(m[2]).toLowerCase();

    const res = await setPerLinkMode(String(chatId), userId, linkId, mode);
    if (!res.ok) {
      await tgAnswerCb(cq.id, res.reason || "Nie uda≈Ço siƒô ustawiƒá trybu.", true);
      return;
    }

    const pretty =
      res.mode === "batch" ? "zbiorczo" : res.mode === "off" ? "OFF" : "pojedynczo";

    await tgAnswerCb(cq.id, `Ustawiono: ${pretty}`);
    return;
  }

  await tgAnswerCb(cq.id, "Nieznana akcja.");
}

// ---------- obs≈Çuga pojedynczego update ----------

async function handleUpdate(update) {
  if (update.callback_query) {
    await handleCallback(update);
    return;
  }

  const msg = update.message;
  if (!msg || !msg.text) return;


  // FYD: bot dzia≈Ça tylko w czacie prywatnym (blokada grup/kana≈Ç√≥w)
  const chatType = msg.chat?.type || "";
  if (chatType && chatType !== "private") {
    await tgSend(String(msg.chat.id), "‚ùå Ta komenda dzia≈Ça tylko w czacie prywatnym z botem. Napisz do mnie prywatnie.");
    return;
  }

  const chatId = msg.chat.id;
  const from = msg.from || {};
  const tgId = from.id ? String(from.id) : null;
let text = (msg.text ?? "").trim();

// NORMALIZACJA: pozw√≥l na spacjƒô zamiast "_"
const m = text.match(/^\/(on|off|pojedyncze|pojedynczo|zbiorcze)\s+(\d+)\b/i);
if (m) {
  const cmd = m[1].toLowerCase() === "pojedynczo" ? "pojedyncze" : m[1].toLowerCase();
  text = `/${cmd}_${m[2]}`;
}

  console.log("TG message:", chatId, text);

  if (!tgId) {
    await tgSend(chatId, "Nie uda≈Ço siƒô ustaliƒá Twojego ID Telegram. Spr√≥buj ponownie.");
    return;
  }

  // rejestracja / aktualizacja profilu
  await initDb();
// W grupach mo≈ºe nie byƒá from (anonimowy admin / sender_chat)
if (!from || !from.id) {
  console.warn("TG update bez from.id (anon admin / sender_chat) ‚Äì pomijam komendƒô");
  return;
}


await ensureUser(
  from.id,
  from.username || null,
  from.first_name || null,
  from.last_name || null,
  from.language_code || null
);

  // alias / user
  const resolvedId = await resolveUserIdFromTg(tgId);

  let user = null;
  if (resolvedId === 1) {
    user = await getUserById(1);
  } else {
    user = await getUserWithPlanByTelegramId(tgId);
  }

  if (!user) {
    await tgSend(
      chatId,
      "Nie widzƒô Ciƒô jeszcze w bazie.\nNajpierw u≈ºyj /dodaj (zarejestruje konto), a potem /status."
    );
    return;
  }

  await ensureChatNotificationsRow(String(chatId), user.id);

  // parsowanie komend
  const [commandRaw, ...rest] = text.split(/\s+/);
  const command = commandRaw.toLowerCase().split("\@")[0];
  const argText = rest.join(" ").trim();

// komendy per-link: /pojedyncze_18 /zbiorcze_18 /off_18 /on_18
const perLink = command.match(/^\/(pojedyncze|zbiorcze|off|on)_(\d+)$/i);
if (perLink) {
  const kind = perLink[1].toLowerCase();
  const linkId = Number(perLink[2]);

  // /on_ID = usu≈Ñ override (wraca do domy≈õlnego trybu czatu)
  if (kind === "on") {
    // zabezpieczenie: link musi nale≈ºeƒá do usera
    const chk = await dbQuery(
      `SELECT id FROM links WHERE id = $1 AND user_id = $2 LIMIT 1`,
      [Number(linkId), Number(user.id)]
    );
    if (!chk.rowCount) {
      await tgSend(chatId, `‚ùå Link <b>${linkId}</b> nie nale≈ºy do Twojego konta.`);
      return;
    }

    await clearLinkNotificationMode(user.id, String(chatId), linkId);

    // odczytaj domy≈õlny tryb czatu (≈ºeby ≈Çadnie potwierdziƒá)
    const cn = await dbQuery(
      `SELECT mode FROM chat_notifications WHERE chat_id = $1 AND user_id = $2 LIMIT 1`,
      [String(chatId), Number(user.id)]
    );
    const chatMode =
      (cn.rows[0]?.mode || "single").toLowerCase() === "batch" ? "zbiorczo" : "pojedynczo";

    await tgSend(
      chatId,
      `‚úÖ Link <b>${linkId}</b> na tym czacie W≈ÅƒÑCZONY (dziedziczy tryb czatu: <b>${chatMode}</b>).`
    );
    return;
  }

  const mode = kind === "zbiorcze" ? "batch" : kind === "off" ? "off" : "single";
  const res = await setPerLinkMode(String(chatId), user.id, linkId, mode);

  if (!res.ok) {
    await tgSend(chatId, `‚ùå ${escapeHtml(res.reason || "Nie uda≈Ço siƒô ustawiƒá trybu.")}`);
    return;
  }

  const pretty =
    res.mode === "batch" ? "zbiorczo" : res.mode === "off" ? "OFF" : "pojedynczo";

  await tgSend(chatId, `‚úÖ Link <b>${linkId}</b> na tym czacie ustawiony: <b>${pretty}</b>`);
  return;
}
  if (command.startsWith("/help")) {
    await handleHelp(msg);
  } else if (command.startsWith("/start")) {
    await handleStart(msg, user, argText);
  } else if (command === "/panel") {
    await handlePanel(msg, user);
  } else if (command.startsWith("/lista")) {
    await handleLista(msg, user);
  } else if (command.startsWith("/usun")) {
    await handleUsun(msg, user, argText);
  } else if (command.startsWith("/dodaj")) {
    await handleDodaj(msg, user, argText);
  } else if (command.startsWith("/status") || command.startsWith("/config")) {
    await handleStatus(msg, user);
  } else if (command === "/on") {
    await handleNotificationsOn(msg, user);
  } else if (command === "/off") {
    await handleNotificationsOff(msg, user);
  } else if (command === "/pojedyncze") {
    await handleModeSingle(msg, user);
  } else if (command === "/zbiorcze") {
    await handleModeBatch(msg, user);
  } else if (command.startsWith("/cisza_off")) {
    await handleQuietOff(msg);
  } else if (command.startsWith("/cisza")) {
    await handleQuiet(msg);
  } else if (command.startsWith("/najnowsze")) {
    await handleNajnowsze(msg, user, argText);
  } else {
    await tgSend(chatId, "‚ùì Nieznana komenda. U≈ºyj /help.");
  }
}

 // ---------- main loop ----------


async function main() {
  console.log("telegram-bot.js start");

  await initDb();

  while (true) {
    try {
      const updates = await fetchUpdates();

      for (const u of updates) {
        offset = u.update_id + 1;
        try {
          await handleUpdate(u);
        } catch (e) {
          console.error("handleUpdate error:", e);
        }
      }
    } catch (e) {
      console.error("polling error:", e);
      // kr√≥tka pauza przy b≈Çƒôdach sieci
      await new Promise((r) => setTimeout(r, 1500));
    }
  }
}

main().catch((err) => {
  console.error("telegram-bot fatal error", err);
  process.exit(1);
});
